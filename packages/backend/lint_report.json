[{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/audit.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[701,704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[701,704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logEntry' is assigned a value but never used.","line":30,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2754,2757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2754,2757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\n\nexport enum AuditActionType {\n    PIX_KEY_UPDATE = 'PIX_KEY_UPDATE',\n    CPF_UPDATE = 'CPF_UPDATE',\n    SECURITY_PHRASE_UPDATE = 'SECURITY_PHRASE_UPDATE',\n    PASSWORD_CHANGE = 'PASSWORD_CHANGE',\n    ADMIN_ACTION = 'ADMIN_ACTION',\n    WITHDRAWAL_REQUEST = 'WITHDRAWAL_REQUEST',\n    BUY_QUOTA = 'BUY_QUOTA',\n    SELL_QUOTA = 'SELL_QUOTA',\n    LOAN_REQUEST = 'LOAN_REQUEST',\n    LOAN_PAYMENT = 'LOAN_PAYMENT'\n}\n\nexport class AuditService {\n    /**\n     * Registra uma a√ß√£o sens√≠vel para auditoria\n     */\n    static async logSensitiveAction(\n        pool: Pool | PoolClient,\n        userId: string | number,\n        actionType: AuditActionType,\n        metadata: any,\n        ip: string = 'unknown'\n    ) {\n        try {\n            // Por enquanto, logamos no console e podemos inserir em uma tabela 'audit_logs'\n            const timestamp = new Date().toISOString();\n            const logEntry = {\n                timestamp,\n                userId,\n                actionType,\n                ip,\n                metadata\n            };\n\n            console.log(`[AUDIT] [${actionType}] User: ${userId} | IP: ${ip} | Data:`, JSON.stringify(metadata));\n\n            // Implementa√ß√£o Ativa: Persist√™ncia Fintech Imut√°vel\n            const { entityType, entityId, oldValues, newValues, ...otherMetadata } = metadata || {};\n\n            await pool.query(\n                `INSERT INTO audit_logs (\n                    user_id, \n                    action, \n                    entity_type, \n                    entity_id, \n                    old_values, \n                    new_values, \n                    ip_address, \n                    created_at\n                )\n                 VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`,\n                [\n                    userId,\n                    actionType,\n                    entityType || null,\n                    entityId || null,\n                    oldValues || (Object.keys(otherMetadata).length > 0 ? otherMetadata : null), // Fallback para salvar outros dados se n√£o houver oldValues\n                    newValues || JSON.stringify(metadata), // Garante que tudo seja salvo em new_values se n√£o estiver estruturado\n                    ip\n                ]\n            );\n\n        } catch (error) {\n            console.error('[AuditService] Erro cr√≠tico ao persistir log de auditoria:', error);\n            // Em sistema financeiro, falha de auditoria √© grave, mas n√£o deve derrubar a transa√ß√£o principal se n√£o for bloqueante.\n            // Manteremos log de erro no console por enquanto.\n        }\n    }\n}\n\n/**\n * Atalho para registrar logs de auditoria t√©cnica (legado/compatibilidade)\n */\nexport async function logAudit(pool: Pool | PoolClient, data: any) {\n    const userId = data.userId || 'system';\n    const action = (data.action || 'UNKNOWN_ACTION') as AuditActionType;\n    delete data.userId;\n    delete data.action;\n\n    return AuditService.logSensitiveAction(pool, userId, action, data);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/auto-liquidation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/backup.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[550,553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[550,553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Pool } from 'pg';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Servi√ßo respons√°vel por gerar backups dos dados cr√≠ticos do sistema\n */\nexport const backupDatabase = async (pool: Pool): Promise<{ success: boolean; filePath?: string; error?: string }> => {\n    try {\n        console.log('üì¶ Iniciando backup de dados cr√≠ticos...');\n\n        // Tabelas para backup\n        const tables = ['users', 'quotas', 'loans', 'transactions', 'system_config', 'admin_logs', 'referral_codes'];\n        const backupData: Record<string, any[]> = {};\n\n        for (const table of tables) {\n            const result = await pool.query(`SELECT * FROM ${table}`);\n            backupData[table] = result.rows;\n        }\n\n        // Criar diret√≥rio de backup se n√£o existir\n        const backupDir = path.join(process.cwd(), 'backups');\n        if (!fs.existsSync(backupDir)) {\n            fs.mkdirSync(backupDir, { recursive: true });\n        }\n\n        // Nome do arquivo com timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const fileName = `backup-${timestamp}.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        // Salvar JSON\n        fs.writeFileSync(filePath, JSON.stringify(backupData, null, 2));\n\n        console.log(`‚úÖ Backup conclu√≠do com sucesso: ${filePath}`);\n\n        // Opcional: Limpar backups antigos (manter apenas os √∫ltimos 7)\n        const files = fs.readdirSync(backupDir)\n            .filter(f => f.startsWith('backup-'))\n            .map(f => ({ name: f, time: fs.statSync(path.join(backupDir, f)).mtime.getTime() }))\n            .sort((a, b) => b.time - a.time);\n\n        if (files.length > 7) {\n            files.slice(7).forEach(f => {\n                fs.unlinkSync(path.join(backupDir, f.name));\n                console.log(`üóëÔ∏è Backup antigo removido: ${f.name}`);\n            });\n        }\n\n        return { success: true, filePath };\n    } catch (error) {\n        console.error('‚ùå Erro ao realizar backup:', error);\n        return { success: false, error: error instanceof Error ? error.message : 'Erro desconhecido' };\n    }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/credit-analysis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'systemTotalQuotas' is assigned a value but never used.","line":140,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":140,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11182,11185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11182,11185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Pool, PoolClient } from 'pg';\n\n/**\n * Sistema de Empr√©stimo por M√©rito com Garantia Flex√≠vel\n * \n * REGRAS:\n * 1. LIMITE M√ÅXIMO = 80% do Total Gasto (sem cotas)\n * 2. Usu√°rio escolhe % de garantia (m√≠nimo 50% das cotas)\n * 3. Quanto MENOR a garantia, MAIOR os juros (prote√ß√£o contra calote)\n * \n * TABELA DE JUROS (baseado na garantia):\n * - 50% garantia ‚Üí 35% juros\n * - 60% garantia ‚Üí 28% juros\n * - 70% garantia ‚Üí 22% juros\n * - 80% garantia ‚Üí 18% juros\n * - 90% garantia ‚Üí 14% juros\n * - 100% garantia ‚Üí 10% juros\n */\n\n// Constantes\n// Constantes de Meritocracia Flex√≠vel\nconst MIN_SCORE_FOR_LOAN = 0; // Removido bloqueio por score - garantia real via cotas √© suficiente\nconst MIN_MARKETPLACE_TRANSACTIONS = 0; // Se tem cota, j√° √© parceiro\nconst MIN_ACCOUNT_AGE_DAYS = 0;  // Libera√ß√£o imediata para detentores de cotas\nconst SYSTEM_LIQUIDITY_RESERVE = 0.30;\nconst LIMIT_PERCENTAGE_OF_SPENT = 0.70; // 70% do que \"sumiu\" (gastou/taxas)\nconst LIMIT_PERCENTAGE_OF_QUOTAS = 0.70; // 70% do capital social (cotas) - Margem de Seguran√ßa (LTV)\n\n// Tabela de juros baseada na garantia\nconst INTEREST_RATES: { [key: number]: number } = {\n    50: 0.35,   // 50% garantia = 35% juros\n    60: 0.28,   // 60% garantia = 28% juros\n    70: 0.22,   // 70% garantia = 22% juros\n    80: 0.18,   // 80% garantia = 18% juros\n    90: 0.14,   // 90% garantia = 14% juros\n    100: 0.10,  // 100% garantia = 10% juros\n};\n\nconst VALID_GUARANTEE_PERCENTAGES = [50, 60, 70, 80, 90, 100];\n\n/**\n * Calcula a taxa de juros baseada na garantia oferecida.\n * Retorna taxa mensal (ex: 0.015 = 1.5% ao m√™s).\n */\nexport const calculateMonthlyInterestRate = (guaranteePercentage: number): number => {\n    // Tabela de juros MENSAIS baseada na garantia\n    // 50% garantia ‚Üí 3.5% ao m√™s\n    // 100% garantia ‚Üí 1.5% ao m√™s (M√≠nimo hist√≥rico)\n    if (guaranteePercentage <= 50) return 0.035;\n    if (guaranteePercentage <= 60) return 0.030;\n    if (guaranteePercentage <= 70) return 0.025;\n    if (guaranteePercentage <= 80) return 0.022;\n    if (guaranteePercentage <= 90) return 0.018;\n    return 0.015; // 1.5% ao m√™s para 100% de garantia\n};\n\n/**\n * Calcula a taxa de juros FLAT baseada na garantia oferecida (LEGADO - USADO EM APOIO M√öTUO)\n */\nexport const calculateInterestRate = (guaranteePercentage: number): number => {\n    if (guaranteePercentage <= 50) return INTEREST_RATES[50];\n    if (guaranteePercentage <= 60) return INTEREST_RATES[60];\n    if (guaranteePercentage <= 70) return INTEREST_RATES[70];\n    if (guaranteePercentage <= 80) return INTEREST_RATES[80];\n    if (guaranteePercentage <= 90) return INTEREST_RATES[90];\n    return INTEREST_RATES[100];\n};\n\n/**\n * Verifica elegibilidade para empr√©stimo\n */\nexport const checkLoanEligibility = async (pool: Pool | PoolClient, userId: string): Promise<{\n    eligible: boolean;\n    reason?: string;\n    details: {\n        score: number;\n        quotasCount: number;\n        quotasValue: number;\n        marketplaceTransactions: number;\n        accountAgeDays: number;\n        hasOverdue: boolean;\n        totalSpent: number;\n        maxLoanAmount: number;\n        activeDebt: number;\n        availableLimit: number;\n    }\n}> => {\n    try {\n        // Dados do usu√°rio e gastos\n        const userDataRes = await pool.query(`\n            SELECT \n                u.score, \n                u.membership_type,\n                u.role,\n                u.created_at,\n                (SELECT COUNT(*) FROM quotas WHERE user_id = $1 AND (status = 'ACTIVE' OR status IS NULL)) as quotas_count,\n                (SELECT COALESCE(SUM(current_value), 0) FROM quotas WHERE user_id = $1 AND (status = 'ACTIVE' OR status IS NULL)) as total_quotas_value,\n                (SELECT COUNT(*) FROM marketplace_orders WHERE buyer_id = $1 AND status = 'COMPLETED') as purchases,\n                (SELECT COUNT(*) FROM marketplace_orders mo JOIN marketplace_listings ml ON mo.listing_id = ml.id WHERE ml.seller_id = $1 AND mo.status = 'COMPLETED') as sales,\n                (SELECT COUNT(*) FROM loans WHERE user_id = $1 AND status = 'APPROVED' AND due_date < NOW()) as overdue_loans,\n                -- Total gasto (sem cotas)\n                COALESCE((SELECT SUM(amount) FROM marketplace_orders WHERE buyer_id = $1 AND status = 'COMPLETED'), 0) as marketplace_spent,\n                COALESCE((SELECT SUM(budget_gross) FROM promo_videos WHERE user_id = $1), 0) as campaign_spent,\n                COALESCE((SELECT SUM(ABS(amount)) FROM transactions \n                    WHERE user_id = $1 AND status = 'APPROVED' \n                    AND type IN ('MEMBERSHIP_UPGRADE', 'BUY_VERIFIED_BADGE', 'BUY_SCORE_PACKAGE', 'MARKET_BOOST')\n                ), 0) as platform_spent,\n                (SELECT COUNT(*) FROM transactions WHERE user_id = $1 AND type = 'BUY_QUOTA' AND status = 'PENDING') as pending_quotas\n            FROM users u\n            WHERE u.id = $1\n        `, [userId]);\n\n        if (userDataRes.rows.length === 0) {\n            return { eligible: false, reason: 'Usu√°rio n√£o encontrado', details: { score: 0, quotasCount: 0, quotasValue: 0, marketplaceTransactions: 0, accountAgeDays: 0, hasOverdue: false, totalSpent: 0, maxLoanAmount: 0, activeDebt: 0, availableLimit: 0 } };\n        }\n\n        const userData = userDataRes.rows[0];\n        const score = parseInt(userData.score) || 0;\n        const quotasCount = parseInt(userData.quotas_count) || 0;\n        const quotasValue = parseFloat(userData.total_quotas_value) || 0;\n        const marketplaceTransactions = parseInt(userData.purchases || 0) + parseInt(userData.sales || 0);\n        const accountAgeDays = Math.max(0, Math.floor((Date.now() - new Date(userData.created_at).getTime()) / (1000 * 60 * 60 * 24)));\n        const hasOverdue = parseInt(userData.overdue_loans) > 0;\n\n        // Total gasto (sem cotas resgat√°veis) + Taxa Adm das Cotas (que √© gasto)\n        const totalSpent = parseFloat(userData.marketplace_spent || 0) +\n            parseFloat(userData.campaign_spent || 0) +\n            parseFloat(userData.platform_spent || 0) +\n            (quotasCount * 8.0); // 8,00 por cota √© taxa de manuten√ß√£o (gasto)\n\n        // BUSCA DE LUCRO REAL DO SISTEMA PARA B√îNUS DE LIMITE\n        const systemProfitRes = await pool.query(`\n            SELECT \n                COALESCE(profit_pool, 0) as profit_pool,\n                (SELECT COUNT(*) FROM quotas WHERE status = 'ACTIVE' OR status IS NULL) as system_total_quotas\n            FROM system_config LIMIT 1\n        `);\n        const systemProfitPool = parseFloat(systemProfitRes.rows[0]?.profit_pool || 0);\n        const systemTotalQuotas = parseInt(systemProfitRes.rows[0]?.system_total_quotas || 1);\n\n        // VERIFICA√á√ÉO DE HIST√ìRICO DE ATRASOS (Para b√¥nus de lucro - Elite)\n        const lateHistoryRes = await pool.query(`\n            SELECT COUNT(*) as late_count \n            FROM transactions \n            WHERE user_id = $1 \n            AND type = 'LOAN_REPAYMENT' \n            AND (metadata->>'penaltyPaid')::numeric > 0\n        `, [userId]);\n        const hasLateHistory = parseInt(lateHistoryRes.rows[0].late_count) > 0;\n\n        // REGRA DE OURO DO JOSIAS (ELITE): \n        // B√¥nus de 5% no limite APENAS se:\n        // 1. Score >= 950\n        // 2. Conta com > 90 dias\n        // 3. NENHUM hist√≥rico de atraso\n        // 4. Lucro Real > 0\n        const isElite = score >= 950 && accountAgeDays >= 90 && !hasLateHistory;\n        const profitBonusFactor = (systemProfitPool > 0 && isElite) ? 0.05 : 0;\n\n        // Bypass de Admin removido para seguir as mesmas regras dos demais usu√°rios (solicita√ß√£o Josias)\n\n        // INFLU√äNCIA DO SCORE (Novo Pedido):\n        // Score 0 a 1000.\n        // Fator: (Score / 1000) * 0.10. Ou seja, Score 1000 d√° +10% de limite. Score 500 d√° +5%.\n        const scoreBonus = (score / 1000) * 0.10;\n\n        // B√îNUS DE ASSINATURA PRO (Novo Pedido):\n        // Membros PRO ganham +5% de limite garantido pelo pagamento recorrente\n        const isPro = userData.membership_type === 'PRO';\n        const proBonus = isPro ? 0.05 : 0;\n\n        // Limite = (70% + b√¥nus lucro + b√¥nus score + b√¥nus PRO) do gasto + (70% + b√¥nus lucro + b√¥nus score + b√¥nus PRO) do valor das cotas\n        // O Score potencializa tanto o m√©rito quanto a confian√ßa na garantia\n        const totalBonus = profitBonusFactor + scoreBonus + proBonus;\n\n        const spentLimit = totalSpent * (LIMIT_PERCENTAGE_OF_SPENT + totalBonus);\n        const quotasLimit = quotasValue * (LIMIT_PERCENTAGE_OF_QUOTAS + totalBonus);\n\n        // CORRE√á√ÉO DE RISCO: N√£o somamos mais o userProfitShare direto.\n        // O lucro do sistema serve apenas para ativar o 'profitBonusFactor'.\n        const maxLoanAmount = Math.floor(spentLimit + quotasLimit);\n\n        // NOVA VERIFICA√á√ÉO: O usu√°rio j√° √© fiador de algu√©m?\n        const isGuarantorResult = await pool.query(`\n            SELECT COUNT(*) FROM loans \n            WHERE status IN ('APPROVED', 'PAYMENT_PENDING') \n            AND (metadata->>'guarantorId' = $1::text OR metadata->>'guarantor_id' = $1::text)\n        `, [userId]);\n        const isCurrentlyGuarantor = parseInt(isGuarantorResult.rows[0].count) > 0;\n\n        // C√ÅLCULO DE D√çVIDA ATIVA (NOVO: UNIFICADO)\n        const activeDebt = await getUserActiveDebt(pool, userId);\n        const availableLimit = Math.max(0, maxLoanAmount - activeDebt);\n\n        const details = { score, quotasCount, quotasValue, marketplaceTransactions, accountAgeDays, hasOverdue, totalSpent, maxLoanAmount, activeDebt, availableLimit, isCurrentlyGuarantor };\n\n        console.log(`[DEBUG_CREDIT] User ${userId}: Score=${score}, Quotas=${quotasCount} (R$ ${quotasValue}), Spent=R$ ${totalSpent}, Limit=R$ ${maxLoanAmount}, Eligible=${!hasOverdue}`);\n        if (hasOverdue) {\n            return { eligible: false, reason: 'Voc√™ possui empr√©stimos em atraso.', details };\n        }\n        if (isCurrentlyGuarantor) {\n            return { eligible: false, reason: 'Voc√™ n√£o pode solicitar apoio enquanto for fiador ativo de outro membro.', details };\n        }\n        if (score < MIN_SCORE_FOR_LOAN) {\n            return { eligible: false, reason: `Score m√≠nimo de ${MIN_SCORE_FOR_LOAN} necess√°rio. Seu: ${score}`, details };\n        }\n\n        if (quotasCount < 1) {\n            const pendingQuotas = parseInt(userData.pending_quotas || 0);\n            if (pendingQuotas > 0) {\n                return { eligible: false, reason: 'Sua participa√ß√£o est√° aguardando aprova√ß√£o banc√°ria. O limite ser√° liberado assim que confirmarmos seu PIX.', details };\n            }\n            return { eligible: true, reason: 'Voc√™ n√£o possui participa√ß√µes. Para solicitar apoio, voc√™ precisar√° de um Fiador.', details };\n        }\n\n        if (marketplaceTransactions < MIN_MARKETPLACE_TRANSACTIONS) {\n            return { eligible: false, reason: `Voc√™ precisa de pelo menos ${MIN_MARKETPLACE_TRANSACTIONS} transa√ß√µes conclu√≠das no Marketplace.`, details };\n        }\n        if (accountAgeDays < MIN_ACCOUNT_AGE_DAYS) {\n            return { eligible: false, reason: `Seu perfil est√° em an√°lise de seguran√ßa. Dispon√≠vel em ${MIN_ACCOUNT_AGE_DAYS - accountAgeDays} dias.`, details };\n        }\n\n        return { eligible: true, details };\n    } catch (error: any) {\n        console.error('Erro ao verificar elegibilidade:', error);\n        return { eligible: false, reason: `Erro t√©cnico na an√°lise: ${error.message}`, details: { score: 0, quotasCount: 0, quotasValue: 0, marketplaceTransactions: 0, accountAgeDays: 0, hasOverdue: false, totalSpent: 0, maxLoanAmount: 0, activeDebt: 0, availableLimit: 0 } };\n    }\n};\n\n/**\n * Calcula o empr√©stimo com base na garantia escolhida\n */\nexport const calculateLoanOffer = async (\n    pool: Pool | PoolClient,\n    userId: string,\n    requestedAmount: number,\n    guaranteePercentage: number, // 50, 60, 70, 80, 90 ou 100\n    guarantorId?: string // Opcional: ID do Fiador\n): Promise<{\n    approved: boolean;\n    reason?: string;\n    requiresGuarantorApproval?: boolean;\n    offer?: {\n        amount: number;\n        guaranteePercentage: number;\n        guaranteeValue: number; // Valor em R$ das cotas bloqueadas (Pessoal + Fiador)\n        guarantorName?: string;\n        interestRate: number;   // Taxa de juros (ex: 0.35 = 35%)\n        totalRepayment: number; // Valor total a pagar\n        availableInterestRates: { percentage: number; rate: number }[];\n    }\n}> => {\n    try {\n        // Validar % de garantia\n        if (!VALID_GUARANTEE_PERCENTAGES.includes(guaranteePercentage)) {\n            return { approved: false, reason: 'Percentual de garantia inv√°lido. Use: 50, 60, 70, 80, 90 ou 100%' };\n        }\n\n        // Se houver fiador, n√£o pode ser o mesmo usu√°rio\n        if (guarantorId && guarantorId === userId) {\n            return { approved: false, reason: 'Voc√™ n√£o pode ser seu pr√≥prio fiador.' };\n        }\n\n        // Verificar elegibilidade do Tomador\n        const eligibility = await checkLoanEligibility(pool, userId);\n        if (!eligibility.eligible) {\n            return { approved: false, reason: eligibility.reason };\n        }\n\n        const { quotasValue: userQuotasValue, maxLoanAmount } = eligibility.details;\n\n        // Se N√ÉO tem fiador, o valor solicitado deve respeitar o limite individual.\n        // Se TEM fiador, o limite √© expandido pelas cotas do fiador.\n        if (!guarantorId && requestedAmount > maxLoanAmount) {\n            return { approved: false, reason: `Valor m√°ximo dispon√≠vel: R$ ${maxLoanAmount.toFixed(2)} (Baseado no seu gasto anterior e capital acumulado)` };\n        }\n\n        // Calcular garantia Pessoal\n        let totalGuaranteeValue = userQuotasValue;\n        let guarantorName = '';\n\n        // Se tiver fiador, somar garantia dele\n        if (guarantorId) {\n            // Regra 2.0: Se tiver fiador, a garantia √© AUTOMATICAMENTE 100% (mais seguro para o clube)\n            guaranteePercentage = 100;\n\n            const guarantorRes = await pool.query(`\n                SELECT u.id, u.name,\n                COALESCE((SELECT SUM(current_value) FROM quotas WHERE user_id = u.id AND (status = 'ACTIVE' OR status IS NULL)), 0) as total_quotas,\n                (SELECT COUNT(*) FROM loans WHERE user_id = u.id AND status IN ('APPROVED', 'PAYMENT_PENDING')) as active_loans_count,\n                (SELECT COUNT(*) FROM loans WHERE (metadata->>'guarantorId' = u.id::text OR metadata->>'guarantor_id' = u.id::text) AND status IN ('APPROVED', 'PAYMENT_PENDING')) as active_guarantorships\n                FROM users u WHERE u.id::text = $1 OR u.email = $1 -- Permitir buscar por ID ou Email\n            `, [guarantorId]);\n\n            if (guarantorRes.rows.length === 0) {\n                return { approved: false, reason: 'Fiador n√£o encontrado. Verifique o ID ou Email informado.' };\n            }\n\n            const guarantorData = guarantorRes.rows[0];\n            const guarantorQuotas = parseFloat(guarantorData.total_quotas);\n\n            // TRAVA: Fiador n√£o pode ter empr√©stimos ativos pr√≥prios\n            if (parseInt(guarantorData.active_loans_count) > 0) {\n                return { approved: false, reason: 'Este fiador n√£o pode ser usado pois possui empr√©stimos ativos pr√≥prios.' };\n            }\n\n            // TRAVA: Fiador n√£o pode j√° ser fiador de outra pessoa (um por vez)\n            if (parseInt(guarantorData.active_guarantorships) > 0) {\n                return { approved: false, reason: 'Este fiador j√° est√° apadrinhando outro membro no momento.' };\n            }\n\n            totalGuaranteeValue += guarantorQuotas;\n            guarantorName = guarantorData.name;\n        }\n\n        // A garantia necess√°ria √© baseada na porcentagem escolhida do valor do empr√©stimo\n        const requiredGuaranteeValue = requestedAmount * (guaranteePercentage / 100);\n\n        if (totalGuaranteeValue < requiredGuaranteeValue) {\n            return {\n                approved: false,\n                reason: `Garantia insuficiente. Suas cotas ${guarantorId ? '+ Fiador ' : ''}somam R$ ${totalGuaranteeValue.toFixed(2)}. Para apoio de R$ ${requestedAmount.toFixed(2)} com ${guaranteePercentage}% de garantia, voc√™ precisa de R$ ${requiredGuaranteeValue.toFixed(2)} em capital social.`\n            };\n        }\n\n        // Verificar liquidez do sistema\n        const systemRes = await pool.query(`\n            SELECT \n                (SELECT COALESCE(system_balance, 0) FROM system_config LIMIT 1) as system_balance,\n                (SELECT COALESCE(SUM(amount), 0) FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING')) as total_loaned\n        `);\n        const systemBalance = parseFloat(systemRes.rows[0].system_balance) || 0;\n        const totalLoaned = parseFloat(systemRes.rows[0].total_loaned) || 0;\n        const disponivel = Math.max(0, (systemBalance * (1 - SYSTEM_LIQUIDITY_RESERVE)) - totalLoaned);\n\n        if (requestedAmount > disponivel) {\n            return { approved: false, reason: 'Liquidez do sistema insuficiente no momento.' };\n        }\n\n        // Calcular taxa de juros baseada na garantia\n        const interestRate = calculateInterestRate(guaranteePercentage);\n        const totalRepayment = requestedAmount * (1 + interestRate);\n\n        // Montar lista de taxas dispon√≠veis\n        const availableInterestRates = VALID_GUARANTEE_PERCENTAGES.map(pct => ({\n            percentage: pct,\n            rate: INTEREST_RATES[pct] * 100 // converter para %\n        }));\n\n        console.log('DEBUG - Oferta de Empr√©stimo:', {\n            userId, requestedAmount, guaranteePercentage, totalGuaranteeValue,\n            interestRate, totalRepayment, maxLoanAmount, guarantorId\n        });\n\n        return {\n            approved: true,\n            requiresGuarantorApproval: !!guarantorId,\n            offer: {\n                amount: requestedAmount,\n                guaranteePercentage,\n                guaranteeValue: requiredGuaranteeValue, // Valor Comprometido\n                guarantorName,\n                interestRate,\n                totalRepayment: Math.ceil(totalRepayment * 100) / 100,\n                availableInterestRates\n            }\n        };\n    } catch (error) {\n        console.error('Erro ao calcular oferta:', error);\n        return { approved: false, reason: 'Erro ao processar' };\n    }\n};\n\n/**\n * Retorna informa√ß√µes para o frontend\n */\nexport const getCreditAnalysis = async (pool: Pool | PoolClient, userId: string) => {\n    const eligibility = await checkLoanEligibility(pool, userId);\n\n    return {\n        eligible: eligibility.eligible,\n        reason: eligibility.reason,\n        limit: eligibility.details.maxLoanAmount,\n        details: {\n            ...eligibility.details,\n            minScore: MIN_SCORE_FOR_LOAN,\n            minMarketplaceTransactions: MIN_MARKETPLACE_TRANSACTIONS,\n            minAccountAgeDays: MIN_ACCOUNT_AGE_DAYS,\n            interestRates: VALID_GUARANTEE_PERCENTAGES.map(pct => ({\n                guaranteePercentage: pct,\n                interestRate: INTEREST_RATES[pct] * 100 // em %\n            })),\n            monthlyInterestRates: VALID_GUARANTEE_PERCENTAGES.map(pct => ({\n                guaranteePercentage: pct,\n                interestRate: calculateMonthlyInterestRate(pct) * 100 // em %\n            }))\n        }\n    };\n};\n\n/**\n * Calcula a d√≠vida ativa real do usu√°rio (Soma dos saldos devedores de empr√©stimos ativos)\n */\nexport const getUserActiveDebt = async (pool: Pool | PoolClient, userId: string): Promise<number> => {\n    // D√≠vida = Valor Total a Repagar - Parcelas j√° pagas\n    const res = await pool.query(`\n        SELECT \n            COALESCE(SUM(l.total_repayment), 0) as total_owed,\n            COALESCE((\n                SELECT SUM(li.amount) \n                FROM loan_installments li \n                JOIN loans l2 ON li.loan_id = l2.id \n                WHERE (l2.user_id = $1::integer OR l2.metadata->>'guarantorId' = $1::text OR l2.metadata->>'guarantor_id' = $1::text) AND l2.status IN ('APPROVED', 'PAYMENT_PENDING') AND li.status = 'PAID'\n            ), 0) as total_paid\n        FROM loans l\n        WHERE (l.user_id = $1::integer OR l.metadata->>'guarantorId' = $1::text OR l.metadata->>'guarantor_id' = $1::text) AND l.status IN ('APPROVED', 'PAYMENT_PENDING')\n    `, [userId]);\n\n    const owed = parseFloat(res.rows[0].total_owed || 0);\n    const paid = parseFloat(res.rows[0].total_paid || 0);\n\n    return Math.max(0, owed - paid);\n};\n\n// Manter compatibilidade com c√≥digo existente\nexport const calculateUserLoanLimit = async (pool: Pool | PoolClient, userId: string): Promise<number> => {\n    const eligibility = await checkLoanEligibility(pool, userId);\n    return eligibility.details.availableLimit; // RETORNA O DISPON√çVEL (Unificando comportamento)\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/credit-protection.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/disbursement-queue.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/image.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/liquidation.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1613,1616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1613,1616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalQuotasValue' is assigned a value but never used.","line":55,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\nimport { QUOTA_SHARE_VALUE } from '../../shared/constants/business.constants';\nimport { executeInTransaction, updateUserBalance, createTransaction } from '../../domain/services/transaction.service';\nimport { logAudit } from './audit.service';\nimport { notificationService } from './notification.service';\n\nexport class LiquidationService {\n    /**\n     * Verifica e processa liquida√ß√µes devidas por atraso superior a 35 dias (30 + 5 car√™ncia)\n     */\n    static async processOverdueInstallments(pool: Pool) {\n        try {\n            // 1. Buscar parcelas PENDENTES com atraso > 35 dias\n            const overdueRes = await pool.query(`\n                SELECT li.*, l.user_id, u.name as user_name\n                FROM loan_installments li\n                JOIN loans l ON l.id = li.loan_id\n                JOIN users u ON u.id = l.user_id\n                WHERE li.status = 'PENDING' \n                  AND li.due_date < NOW() - INTERVAL '35 days'\n                ORDER BY li.due_date ASC\n            `);\n\n            if (overdueRes.rows.length === 0) return;\n\n            console.log(`[LIQUIDATION] Encontradas ${overdueRes.rows.length} parcelas para liquida√ß√£o.`);\n\n            for (const installment of overdueRes.rows) {\n                await this.liquidateInstallment(pool, installment);\n            }\n        } catch (error) {\n            console.error('[LIQUIDATION_ERROR] Erro ao processar atrasos:', error);\n        }\n    }\n\n    /**\n     * Executa a liquida√ß√£o de uma parcela espec√≠fica\n     */\n    private static async liquidateInstallment(pool: Pool, installment: any) {\n        return executeInTransaction(pool, async (client: PoolClient) => {\n            const debtAmount = parseFloat(installment.expected_amount);\n\n            // 1. Bloquear usu√°rio e buscar cotas ativas\n            const quotasRes = await client.query(\n                \"SELECT id FROM quotas WHERE user_id = $1 AND status = 'ACTIVE' ORDER BY purchase_date ASC FOR UPDATE\",\n                [installment.user_id]\n            );\n\n            if (quotasRes.rows.length === 0) {\n                console.warn(`[LIQUIDATION_FAIL] Usu√°rio ${installment.user_id} n√£o possui cotas para liquidar a parcela ${installment.id}`);\n                // Aqui poder√≠amos marcar o usu√°rio como inadimplente ou avisar o admin\n                return;\n            }\n\n            const totalQuotasValue = quotasRes.rows.length * QUOTA_SHARE_VALUE;\n\n            // 2. Calcular quantas cotas precisam ser \"comidas\"\n            // Se uma cota vale 42 e a parcela √© 100, precisamos de 3 cotas (126). \n            // O troco volta para o saldo do usu√°rio.\n            const quotasNeeded = Math.ceil(debtAmount / QUOTA_SHARE_VALUE);\n            const quotasToRedeem = quotasRes.rows.slice(0, quotasNeeded);\n            const actualRedeemedValue = quotasToRedeem.length * QUOTA_SHARE_VALUE;\n            const change = actualRedeemedValue - debtAmount;\n\n            console.log(`[LIQUIDATION_EXEC] Liquidando ${quotasToRedeem.length} cotas de ${installment.user_name} para pagar R$ ${debtAmount}`);\n\n            // 3. Invalidar as cotas\n            const quotaIds = quotasToRedeem.map(q => q.id);\n            await client.query(\n                \"UPDATE quotas SET status = 'LIQUIDATED', metadata = metadata || $1::jsonb WHERE id = ANY($2)\",\n                [JSON.stringify({ liquidationReason: 'OVERDUE_LOAN', installmentId: installment.id }), quotaIds]\n            );\n\n            // 4. Se houver troco, creditar no saldo do usu√°rio\n            if (change > 0) {\n                await updateUserBalance(client, installment.user_id, change, 'credit');\n            }\n\n            // 5. Marcar parcela como PAGA\n            await client.query(\n                \"UPDATE loan_installments SET status = 'PAID', amount = $1, use_balance = false, paid_at = NOW(), metadata = metadata || $2::jsonb WHERE id = $3\",\n                [debtAmount, JSON.stringify({ liquidationApplied: true, quotasCount: quotasToRedeem.length }), installment.id]\n            );\n\n            // 6. Registrar Transa√ß√£o de Liquida√ß√£o\n            await createTransaction(\n                client,\n                installment.user_id,\n                'LOAN_PAYMENT',\n                debtAmount,\n                `Liquida√ß√£o Autom√°tica (Garantia de Cotas) - Parcela ${installment.installment_number}`,\n                'APPROVED',\n                {\n                    loanId: installment.loan_id,\n                    installmentId: installment.id,\n                    isLiquidation: true,\n                    quotasRedeemed: quotasToRedeem.length,\n                    redeemedValue: actualRedeemedValue,\n                    change\n                }\n            );\n\n            // 7. Auditoria\n            await logAudit(client, {\n                userId: installment.user_id,\n                action: 'QUOTA_LIQUIDATION_OVERDUE',\n                entityType: 'loan_installment',\n                entityId: installment.id,\n                newValues: { status: 'PAID', liquidatedQuotas: quotasToRedeem.length }\n            });\n\n            // 8. Notificar\n            notificationService.notifyUser(\n                installment.user_id,\n                'Execu√ß√£o de Garantia',\n                `Uma parcela do seu apoio venceu h√° mais de 35 dias. Conforme regras, ${quotasToRedeem.length} cota(s) foram liquidadas para quitar o d√©bito.`\n            );\n        });\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/liquidity.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDbPool' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":19,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"getDbPool"},"fix":{"range":[0,86],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[227,230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[227,230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[354,357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[354,357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1202,1205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1202,1205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pool' is assigned a value but never used.","line":71,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":152,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":155,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3084,3087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3084,3087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDbPool } from '../../infrastructure/database/postgresql/connection/pool';\n\n// Gerenciador de conex√µes em tempo real (SSE)\n// Map<userId, Map<connectionId, sendFn>>\nconst clients = new Map<string, Map<string, (data: any) => void>>();\n\ninterface NotificationService {\n    addClient(userId: string | number, connectionId: string, sendFn: (data: any) => void): void;\n    removeClient(userId: string | number, connectionId: string): void;\n    notifyAdmin(message: string, type?: 'ALERT' | 'INFO' | 'SUCCESS'): Promise<void>;\n    notifyUser(userId: string | number, title: string, body: string, type?: 'INFO' | 'SUCCESS' | 'WARNING' | 'ERROR' | 'PAYMENT' | 'ORDER' | 'DELIVERY'): Promise<void>;\n    notifyNewWithdrawal(userName: string, amount: number): Promise<void>;\n    notifyProfitDistributed(totalAmount: number): Promise<void>;\n    sendDuressAlert(userName: string, safePhone: string): Promise<void>;\n}\n\n/**\n * Servi√ßo de Notifica√ß√µes Cred30\n * Gerencia o envio de alertas para usu√°rios e administradores\n */\nexport const notificationService: NotificationService = {\n    /**\n     * Adiciona um cliente SSE\n     */\n    addClient(userId: string | number, connectionId: string, sendFn: (data: any) => void) {\n        const uId = userId.toString();\n        if (!clients.has(uId)) {\n            clients.set(uId, new Map());\n        }\n        clients.get(uId)!.set(connectionId, sendFn);\n\n        let total = 0;\n        clients.forEach(c => total += c.size);\n        // console.log(`üì° [SSE] Cliente conectado: ${userId} (${connectionId}). Total: ${total}`);\n    },\n\n    /**\n     * Remove um cliente SSE\n     */\n    removeClient(userId: string | number, connectionId: string) {\n        const uId = userId.toString();\n        const userClients = clients.get(uId);\n        if (userClients) {\n            userClients.delete(connectionId);\n            if (userClients.size === 0) {\n                clients.delete(uId);\n            }\n        }\n    },\n\n    /**\n     * Envia um alerta de sistema para o administrador\n     */\n    async notifyAdmin(message: string, type: 'ALERT' | 'INFO' | 'SUCCESS' = 'INFO') {\n        const emoji = type === 'ALERT' ? 'üö®' : type === 'SUCCESS' ? '‚úÖ' : '‚ÑπÔ∏è';\n        console.log(`${emoji} [ADMIN NOTIFICATION]: ${message}`);\n\n        // TODO: Inserir em tabela notifications_admin se houver\n    },\n\n    /**\n     * Envia uma notifica√ß√£o para um usu√°rio espec√≠fico (COM PERSIST√äNCIA)\n     */\n    async notifyUser(userId: string | number, title: string, body: string, type: 'INFO' | 'SUCCESS' | 'WARNING' | 'ERROR' | 'PAYMENT' | 'ORDER' | 'DELIVERY' = 'INFO') {\n        console.log(`üîî [USER NOTIFICATION] User: ${userId} | ${title}: ${body}`);\n\n        try {\n            // 1. Persistir no Banco de Dados\n            // Como notificationService √© agn√≥stico de contexto, precisamos de uma inst√¢ncia do pool global\n            // Aqui vamos usar um hack para pegar o pool global ou importar uma inst√¢ncia\n            const pool = await import('../../infrastructure/database/postgresql/connection/pool').then(m => m.generateReferralCode ? m.getDbPool({} as any) : null);\n\n            // Simplifica√ß√£o: vamos fazer o import funcionar corretamente, mas getDbPool exige Contexto Hono\n            // Vamos implementar um m√©todo `getGlobalPool` no pool.ts para services isolados, ou usar require.\n\n            // Solu√ß√£o Correta: Injetar pool ou criar nova conex√£o.\n            // Para n√£o quebrar a arquitetura existente, vamos instanciar aqui pontualmente\n            const { Pool } = await import('pg');\n            const newPool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });\n\n            await newPool.query(\n                `INSERT INTO notifications (user_id, title, message, type) VALUES ($1, $2, $3, $4)`,\n                [userId, title, body, type]\n            );\n            await newPool.end(); // Fechar para n√£o vazar conex√µes\n\n            // 2. Enviar via SSE (Tempo Real)\n            const userClients = clients.get(userId.toString());\n            if (userClients) {\n                userClients.forEach((send) => {\n                    send({\n                        event: 'notification',\n                        title,\n                        body, // Legacy SSE format\n                        message: body,\n                        type,\n                        timestamp: new Date().toISOString()\n                    });\n                });\n            }\n        } catch (error) {\n            console.error('Erro ao persistir notifica√ß√£o:', error);\n            // Fallback: Tenta enviar online mesmo sem salvar no banco\n            const userClients = clients.get(userId.toString());\n            if (userClients) {\n                userClients.forEach((send) => send({ event: 'notification', title, body, type, timestamp: new Date().toISOString(), error: 'Not persisted' }));\n            }\n        }\n    },\n\n    /**\n     * Alerta sobre novo saque solicitado\n     */\n    async notifyNewWithdrawal(userName: string, amount: number) {\n        const msg = `Novo saque solicitado!\\nCliente: ${userName}\\nValor: R$ ${amount.toFixed(2)}\\n\\nAcesse o painel para aprovar.`;\n        await this.notifyAdmin(msg, 'ALERT');\n    },\n\n    /**\n     * Alerta sobre lucro distribu√≠do\n     */\n    async notifyProfitDistributed(totalAmount: number) {\n        const msg = `Distribui√ß√£o di√°ria realizada com sucesso!\\nTotal distribu√≠do: R$ ${totalAmount.toFixed(2)}`;\n        await this.notifyAdmin(msg, 'SUCCESS');\n    },\n\n    /**\n     * Envia alerta de coa√ß√£o para o contato seguro\n     */\n    async sendDuressAlert(userName: string, safePhone: string) {\n        const message = `üö® ALERTA DE EMERG√äNCIA CRED30: O associado ${userName} acaba de ativar o modo de p√¢nico no aplicativo. Isso indica uma situa√ß√£o de perigo ou coa√ß√£o. Por favor, tente contato ou chame as autoridades (190) se necess√°rio.`;\n        console.log(`‚ö†Ô∏è [DURESS ALERT SENT TO ${safePhone}]: ${message}`);\n    }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/points.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4034,4037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4034,4037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\nimport { executeInTransaction, createTransaction } from '../../domain/services/transaction.service';\n\n/**\n * Taxa de Convers√£o Oficial: 1000 pontos = R$ 0,07\n */\nexport const VALUE_PER_1000_POINTS = 0.07;\nexport const MIN_POINTS_FOR_CONVERSION = 1000;\nexport const POINTS_CONVERSION_RATE = 1000 / VALUE_PER_1000_POINTS; // ~14285.71\n\nexport class PointsService {\n    /**\n     * Adiciona pontos ao usu√°rio\n     */\n    static async addPoints(\n        pool: Pool | PoolClient,\n        userId: string | number,\n        amount: number,\n        reason: string\n    ) {\n        if (amount <= 0) return;\n\n        await pool.query(\n            `UPDATE users \n             SET ad_points = COALESCE(ad_points, 0) + $1, \n                 total_ad_points = COALESCE(total_ad_points, 0) + $1 \n             WHERE id = $2`,\n            [amount, userId]\n        );\n\n        console.log(`[PointsService] +${amount} pts para usu√°rio ${userId}. Motivo: ${reason}`);\n    }\n\n    /**\n     * Converte pontos em saldo (balance)\n     */\n    static async convertPointsToBalance(\n        pool: Pool,\n        userId: string | number\n    ): Promise<{ success: boolean; message?: string; data?: { convertedAmount: number; remainingPoints: number } }> {\n        try {\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Buscar dados do usu√°rio e config do sistema\n                const userRes = await client.query('SELECT ad_points, balance FROM users WHERE id = $1 FOR UPDATE', [userId]);\n                const user = userRes.rows[0];\n\n                if (!user) throw new Error('Usu√°rio n√£o encontrado.');\n\n                const currentPoints = Math.floor(user.ad_points || 0);\n\n                if (currentPoints < MIN_POINTS_FOR_CONVERSION) {\n                    throw new Error(`M√≠nimo de ${MIN_POINTS_FOR_CONVERSION} pontos para convers√£o.`);\n                }\n\n                const systemRes = await client.query('SELECT total_operational_reserve FROM system_config LIMIT 1 FOR UPDATE');\n                const systemBalance = parseFloat(systemRes.rows[0]?.total_operational_reserve || '0');\n\n                // 2. Calcular valores\n                const pointsToConvert = Math.floor(currentPoints / MIN_POINTS_FOR_CONVERSION) * MIN_POINTS_FOR_CONVERSION;\n                // Ex: 1000 pts -> 1 unidade * R$ 0.07 = R$ 0.07\n                const amountToAdd = (pointsToConvert / 1000) * VALUE_PER_1000_POINTS;\n\n                if (systemBalance < amountToAdd) {\n                    throw new Error('Fundo de Reserva Operacional insuficiente no momento. Tente novamente mais tarde.');\n                }\n\n                // 3. Executar atualiza√ß√µes\n                // Debita da Reserva Operacional (que recebe 25% das taxas)\n                await client.query('UPDATE system_config SET total_operational_reserve = total_operational_reserve - $1', [amountToAdd]);\n                await client.query('UPDATE users SET ad_points = ad_points - $1, balance = balance + $2 WHERE id = $3', [pointsToConvert, amountToAdd, userId]);\n\n                // 4. Registrar transa√ß√£o\n                await createTransaction(\n                    client,\n                    userId.toString(),\n                    'POINTS_CONVERSION',\n                    amountToAdd,\n                    `Convers√£o de ${pointsToConvert} pontos em saldo`,\n                    'APPROVED',\n                    { points: pointsToConvert, rate: VALUE_PER_1000_POINTS }\n                );\n\n                console.log(`[PointsService] Convers√£o: ${pointsToConvert} pts -> R$ ${amountToAdd.toFixed(2)} para usu√°rio ${userId}`);\n\n                return {\n                    convertedAmount: amountToAdd,\n                    remainingPoints: currentPoints - pointsToConvert\n                };\n            });\n\n            if (!result.success) {\n                return { success: false, message: result.error };\n            }\n\n            return { success: true, data: result.data };\n\n        } catch (error: any) {\n            console.error('[PointsService] Erro na convers√£o:', error.message);\n            return { success: false, message: error.message };\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/profit-distribution.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[419,422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[419,422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\nimport {\n    DIVIDEND_USER_SHARE,\n    MAINTENANCE_TAX_SHARE,\n    MAINTENANCE_OPERATIONAL_SHARE,\n    MAINTENANCE_OWNER_SHARE,\n    MAINTENANCE_INVESTMENT_SHARE,\n    MAINTENANCE_CORPORATE_SHARE\n} from '../../shared/constants/business.constants';\nimport { notificationService } from './notification.service';\n\nexport const distributeProfits = async (pool: Pool | PoolClient): Promise<any> => {\n    try {\n        // Buscar configura√ß√£o do sistema\n        const configResult = await pool.query('SELECT * FROM system_config LIMIT 1');\n        const config = configResult.rows[0];\n\n        if (!config || parseFloat(config.profit_pool) <= 0) {\n            return { success: false, message: 'N√£o h√° resultados acumulados para distribuir' };\n        }\n\n        // ---------------------------------------------------------------------\n        // NOVA L√ìGICA DE DISTRIBUI√á√ÉO PONDERADA (Score-Based)\n        // Incentivos:\n        // 1. Hist√≥rico de Pagamento (Loans Paid) -> Ganha peso\n        // 2. Volume de Gastos (Total Spent) -> Ganha peso\n        // 3. Ativa√ß√£o (2FA, PRO) -> Ganha peso\n        // 4. NOVO: S√≥ quem GEROU RECEITA (pagou taxas/juros) √© eleg√≠vel\n        // ---------------------------------------------------------------------\n\n        // Tipos de transa√ß√£o que GERAM RECEITA para a plataforma:\n        // - LOAN_INTEREST: Juros de empr√©stimo\n        // - MARKET_SALE: Vendeu no marketplace (pagou taxa)\n        // - MARKET_BOOST: Impulsionou an√∫ncio\n        // - MEMBERSHIP_UPGRADE: Virou PRO\n        // - WITHDRAWAL: Sacou (pagou taxa)\n        // - BUY_QUOTA: Comprou cota (pagou taxa)\n        // - MARKET_PURCHASE: Comprou no marketplace (taxa vai pro vendedor/sistema)\n        // - REPUTATION_CONSULT: Consultou reputa√ß√£o (servi√ßo pago)\n        // - LOGISTIC_DELIVERY: Pagou frete\n\n        const eligibleUsersQuery = `\n            SELECT \n                q.user_id, \n                COUNT(q.id) as quota_count,\n                u.two_factor_enabled,\n                u.membership_type,\n                COALESCE((SELECT COUNT(*) FROM loans l WHERE l.user_id = q.user_id AND l.status = 'PAID'), 0) as paid_loans,\n                -- 1. Total Gasto em Toda a Plataforma (Consumo Real)\n                COALESCE((SELECT SUM(ABS(amount)) FROM transactions t \n                 WHERE t.user_id = q.user_id \n                 AND t.status = 'APPROVED'\n                 AND t.type NOT IN ('DEPOSIT', 'WITHDRAWAL', 'TRANSFER', 'BONUS', 'REFERRAL_BONUS')\n                ), 0) as total_spent,\n                -- 2. Receita Real Gerada para o Clube (Taxas e Juros)\n                COALESCE((\n                    SELECT SUM(CASE \n                        WHEN t.type = 'BUY_QUOTA' THEN COALESCE((t.metadata->>'serviceFee')::decimal, 0) -- Taxa Adm Fixa (R$ 8 por cota)\n                        WHEN t.type = 'MEMBERSHIP_UPGRADE' THEN ABS(t.amount) -- Upgrade PRO\n                        WHEN t.type = 'PREMIUM_PURCHASE' THEN ABS(t.amount)    -- Verificado/Score Boost\n                        WHEN t.type = 'MARKET_BOOST' THEN ABS(t.amount)       -- Impulsionamento\n                        WHEN t.type = 'REPUTATION_CONSULT' THEN ABS(t.amount) -- Consultas\n                        WHEN t.type = 'WITHDRAWAL' THEN 3.50                  -- Taxa de Saque\n                        WHEN t.type = 'MARKET_PURCHASE' THEN ABS(t.amount) * 0.12 -- Taxa Marketplace\n                        WHEN t.type = 'LOGISTIC_PAY' THEN ABS(t.amount) * 0.10    -- Taxa Log√≠stica\n                        WHEN t.type = 'PROMO_VIDEO_BUDGET' THEN ABS(t.amount) * 0.40 -- 40% (25% pool + 15% sist)\n                        ELSE 0\n                    END)\n                    FROM transactions t \n                    WHERE t.user_id = q.user_id \n                    AND t.status IN ('APPROVED', 'COMPLETED')\n                ), 0) +\n                -- Juros de empr√©stimos (Diferen√ßa entre o que pagou e o que pegou)\n                COALESCE((\n                    SELECT SUM(l.total_repayment - l.amount) \n                    FROM loans l \n                    WHERE l.user_id = q.user_id \n                    AND l.status = 'PAID'\n                ), 0) as total_revenue_generated\n            FROM quotas q\n            JOIN users u ON u.id = q.user_id\n            WHERE (q.status = 'ACTIVE' OR q.status IS NULL)\n            AND (\n                -- NOVO: S√≥ quem GEROU RECEITA para a plataforma √© eleg√≠vel\n                -- Pagou empr√©stimo (gerou juros)\n                EXISTS (SELECT 1 FROM loans l WHERE l.user_id = q.user_id AND l.status = 'PAID')\n                OR \n                -- Vendeu no marketplace (pagou taxa de venda)\n                EXISTS (SELECT 1 FROM marketplace_orders mo WHERE mo.seller_id = q.user_id AND mo.status = 'COMPLETED')\n                OR \n                -- Fez transa√ß√µes que geram receita\n                EXISTS (\n                    SELECT 1 FROM transactions t \n                    WHERE t.user_id = q.user_id \n                    AND t.status = 'APPROVED'\n                    AND t.type IN (\n                        'WITHDRAWAL',          -- Pagou taxa de saque\n                        'MEMBERSHIP_UPGRADE',  -- Pagou PRO\n                        'MARKET_BOOST',        -- Pagou impulsionamento\n                        'REPUTATION_CONSULT',  -- Pagou consulta de reputa√ß√£o\n                        'MARKET_PURCHASE',     -- Comprou no marketplace (taxa vai pro sistema)\n                        'MARKET_PURCHASE_CREDIT', -- Credi√°rio (juros + taxa)\n                        'BUY_QUOTA'       -- Comprou cota (taxa administrativa)\n                    )\n                )\n            )\n            GROUP BY q.user_id, u.two_factor_enabled, u.membership_type\n        `;\n\n        const eligibleResult = await pool.query(eligibleUsersQuery);\n        let usersWithQuotas = eligibleResult.rows;\n\n        // Calcular \"Cotas Ponderadas\" (Weighted Shares)\n        // Multiplicador Base = 1.0\n        usersWithQuotas = usersWithQuotas.map(user => {\n            let multiplier = 1.0;\n\n            // B√¥nus 1: Ativa√ß√£o (+10% se tiver 2FA, +20% se for PRO)\n            if (user.two_factor_enabled) multiplier += 0.1;\n            if (user.membership_type === 'PRO') multiplier += 0.2;\n\n            // B√¥nus 2: Bom Pagador (+5% por empr√©stimo pago, limitado a +50%)\n            const paidLoansBonus = Math.min(parseInt(user.paid_loans || 0) * 0.05, 0.5);\n            multiplier += paidLoansBonus;\n\n            // B√¥nus 3: Grande Gastador (+10% a cada R$ 500 gastos, limitado a +200%)\n            const spent = parseFloat(user.total_spent || 0);\n            if (spent > 0) {\n                const spendBonus = Math.min(spent / 500, 2.0); // +0.1 a cada 500, max 2.0\n                multiplier += spendBonus * 0.1;\n            }\n\n            // B√¥nus 4: GERADOR DE RECEITA (+20% a cada R$ 100 de lucro deixado na casa)\n            const revenue = parseFloat(user.total_revenue_generated || 0);\n            if (revenue > 0) {\n                const revenueBonus = Math.min(revenue / 100, 3.0); // +0.2 a cada 100, max 3.0 (300%)\n                multiplier += revenueBonus * 0.2;\n            }\n\n            // Apply weighting\n            const rawQuotas = parseInt(user.quota_count);\n            const weightedQuotas = rawQuotas * multiplier;\n\n            return {\n                ...user,\n                raw_quotas: rawQuotas,\n                multiplier: multiplier,\n                weighted_quotas: weightedQuotas,\n                revenue_generated: revenue\n            };\n        });\n\n        // Calcular total de COTAS PONDERADAS (n√£o cotas f√≠sicas)\n        const totalWeightedQuotas = usersWithQuotas.reduce((acc, row) => acc + row.weighted_quotas, 0);\n\n        console.log('DEBUG - Cotas Ponderadas Totais:', totalWeightedQuotas.toFixed(2));\n\n        if (totalWeightedQuotas <= 0) {\n            return {\n                success: false,\n                message: `N√£o h√° elegibilidade suficiente. Lucro retido.`,\n                data: { profitPoolRetained: parseFloat(config.profit_pool) }\n            };\n        }\n\n        const profit = parseFloat(config.profit_pool);\n        const totalForUsers = profit * DIVIDEND_USER_SHARE;\n\n        // Rateio detalhado da manuten√ß√£o\n        const taxAmount = profit * MAINTENANCE_TAX_SHARE;\n        const operationalAmount = profit * MAINTENANCE_OPERATIONAL_SHARE;\n        const ownerAmount = profit * MAINTENANCE_OWNER_SHARE;\n        const investmentAmount = profit * MAINTENANCE_INVESTMENT_SHARE;\n        const corporateAmount = profit * MAINTENANCE_CORPORATE_SHARE;\n        const totalForMaintenance = taxAmount + operationalAmount + ownerAmount + investmentAmount + corporateAmount;\n\n        // O valor agora √© por \"Cota Ponderada\"\n        const dividendPerWeightedQuota = totalForUsers / totalWeightedQuotas;\n\n        // Distribuir\n        console.log('DEBUG - Iniciando distribui√ß√£o ponderada...', { totalProfit: profit, usersCount: usersWithQuotas.length });\n\n        const userIds = usersWithQuotas.map(u => u.user_id);\n        const userAmounts = usersWithQuotas.map(u => Number((u.weighted_quotas * dividendPerWeightedQuota).toFixed(2)));\n        const userDescriptions = usersWithQuotas.map(u => {\n            const extra = ((u.multiplier - 1) * 100).toFixed(0);\n            return `Excedente Social (${u.raw_quotas} cotas + ${extra}% b√¥nus de reciprocidade)`;\n        });\n\n        // Executar atualiza√ß√£o em massa\n        if (userIds.length > 0) {\n            await pool.query(`\n                WITH distribution_data AS (\n                    SELECT \n                        unnest($1::int[]) as u_id, \n                        unnest($2::decimal[]) as u_amount,\n                        unnest($3::text[]) as u_desc\n                ),\n                update_balances AS (\n                    UPDATE users u\n                    SET balance = u.balance + dd.u_amount\n                    FROM distribution_data dd\n                    WHERE u.id = dd.u_id\n                )\n                INSERT INTO transactions (user_id, type, amount, description, status)\n                SELECT u_id, 'DIVIDEND', u_amount, u_desc, 'APPROVED'\n                FROM distribution_data\n                WHERE u_amount > 0;\n            `, [userIds, userAmounts, userDescriptions]);\n        }\n\n        const distributedTotal = userAmounts.reduce((acc, val) => acc + val, 0);\n        const roundingDifference = totalForUsers - distributedTotal;\n        const finalMaintenance = totalForMaintenance + roundingDifference;\n\n        // Atualizar config\n        await pool.query(\n            `UPDATE system_config \n             SET system_balance = system_balance + $1, \n                 total_tax_reserve = total_tax_reserve + $2,\n                 total_operational_reserve = total_operational_reserve + $3,\n                 total_owner_profit = total_owner_profit + $4,\n                 investment_reserve = investment_reserve + $5,\n                 total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6,\n                 profit_pool = 0`,\n            [finalMaintenance, taxAmount, operationalAmount, ownerAmount, investmentAmount, corporateAmount]\n        );\n\n        // Notificar Admin\n        notificationService.notifyProfitDistributed(profit).catch(e => console.error('Erro ao notificar admin:', e));\n\n        // Notificar cada usu√°rio que recebeu lucro via SSE (para o sino)\n        for (let i = 0; i < usersWithQuotas.length; i++) {\n            const user = usersWithQuotas[i];\n            const amount = userAmounts[i];\n            if (amount > 0) {\n                notificationService.notifyUser(\n                    user.user_id,\n                    'üí∞ Excedente Social Recebido!',\n                    `Voc√™ recebeu R$ ${amount.toFixed(2)} de excedentes das suas ${user.raw_quotas} cotas!`\n                ).catch(() => { /* ignore */ });\n            }\n        }\n\n        return {\n            success: true,\n            message: 'Distribui√ß√£o Ponderada realizada com sucesso!',\n            data: {\n                totalProfit: profit,\n                distributed: distributedTotal,\n                dividendPerWeightedQuota,\n                totalWeightedQuotas\n            },\n        };\n    } catch (error) {\n        console.error('Erro ao distribuir b√¥nus:', error);\n        throw error;\n    }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/score.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/two-factor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/application/services/welcome-benefit.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/entities/loan.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/entities/quota.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/entities/transaction.entity.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[269,272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[269,272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[405,408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[405,408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface Transaction {\n  id: string | number;\n  userId: string | number;\n  type: string;\n  amount: number;\n  gateway_cost?: number;\n  created_at?: Date;\n  description: string;\n  status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'FAILED' | 'CANCELLED';\n  metadata?: any;\n}\n\nexport interface CreateTransactionRequest {\n  type: Transaction['type'];\n  amount: number;\n  description?: string;\n  metadata?: any;\n}\n\nexport interface UpdateTransactionStatusRequest {\n  transactionId: string;\n  status: 'APPROVED' | 'REJECTED';\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/entities/user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/services/governance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/services/order.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Pool' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Pool"},"fix":{"range":[9,14],"text":""},"desc":"Remove unused variable \"Pool\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_TAX_SHARE' is defined but never used.","line":5,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_TAX_SHARE"},"fix":{"range":[118,146],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_TAX_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_OPERATIONAL_SHARE' is defined but never used.","line":6,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":35,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_OPERATIONAL_SHARE"},"fix":{"range":[146,182],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_OPERATIONAL_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_OWNER_SHARE' is defined but never used.","line":7,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":29,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_OWNER_SHARE"},"fix":{"range":[182,212],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_OWNER_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_INVESTMENT_SHARE' is defined but never used.","line":8,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_INVESTMENT_SHARE"},"fix":{"range":[212,247],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_INVESTMENT_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_CORPORATE_SHARE' is defined but never used.","line":9,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":33,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_CORPORATE_SHARE"},"fix":{"range":[247,281],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_CORPORATE_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuditService' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AuditService"},"fix":{"range":[343,356],"text":""},"desc":"Remove unused variable \"AuditService\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuditActionType' is defined but never used.","line":11,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":39,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"AuditActionType"},"fix":{"range":[334,424],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notificationService' is defined but never used.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":29,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"notificationService"},"fix":{"range":[501,588],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3409,3412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3409,3412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4970,4973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4970,4973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":297,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12723,12726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12723,12726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\nimport {\n    MARKETPLACE_ESCROW_FEE_RATE,\n    MARKETPLACE_NON_VERIFIED_FEE_RATE,\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE,\n    PLATFORM_FEE_CORPORATE_SHARE\n} from '../../shared/constants/business.constants';\nimport { AuditService, AuditActionType } from '../../application/services/audit.service';\nimport { calculateShippingQuote } from '../../shared/utils/logistics.utils';\nimport { notificationService } from '../../application/services/notification.service';\nimport { updateScore, SCORE_REWARDS } from '../../application/services/score.service';\nimport { lockUserBalance, updateUserBalance, createTransaction } from './transaction.service';\nimport { calculateLoanOffer } from '../../application/services/credit-analysis.service';\n\nexport interface CreateOrderParams {\n    userId: number | string;\n    listingIds: number[];\n    quantity: number;\n    deliveryType: 'SELF_PICKUP' | 'COURIER_REQUEST' | 'EXTERNAL_SHIPPING';\n    offeredDeliveryFee: number;\n    deliveryAddress: string;\n    contactPhone: string;\n    paymentMethod: 'BALANCE' | 'PIX' | 'CARD' | 'CRED30_CREDIT';\n    selectedVariantId?: number;\n    selectedOptions?: Array<{ name: string; price: number }>;\n    pickupAddress?: string;\n    deliveryLat?: number;\n    deliveryLng?: number;\n    pickupLat?: number;\n    pickupLng?: number;\n    invitedCourierId?: string;\n    offlineToken?: string;\n}\n\nexport class OrderService {\n    /**\n     * Valida o hor√°rio de funcionamento de um vendedor\n     */\n    static async validateOpeningHours(client: PoolClient, sellerId: number) {\n        const sellerRes = await client.query(\n            'SELECT opening_hours, is_paused, is_restaurant FROM users WHERE id = $1',\n            [sellerId]\n        );\n        const seller = sellerRes.rows[0];\n\n        if (seller?.is_paused) {\n            throw new Error('Este estabelecimento est√° temporariamente fechado.');\n        }\n\n        if (seller?.opening_hours) {\n            const now = new Date();\n            const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n            const currentDay = dayNames[now.getDay()];\n            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();\n\n            const hours = seller.opening_hours[currentDay];\n            if (!hours || !hours.open || !hours.close) {\n                throw new Error('Este estabelecimento est√° fechado hoje.');\n            }\n\n            const [openH, openM] = hours.open.split(':').map(Number);\n            const [closeH, closeM] = hours.close.split(':').map(Number);\n            const openMin = openH * 60 + openM;\n            const closeMin = closeH * 60 + closeM;\n\n            let isOpen = false;\n            if (closeMin < openMin) { // Caso vire a noite\n                isOpen = currentTimeMinutes >= openMin || currentTimeMinutes <= closeMin;\n            } else {\n                isOpen = currentTimeMinutes >= openMin && currentTimeMinutes <= closeMin;\n            }\n\n            if (!isOpen) {\n                throw new Error(`Estabelecimento fechado. Abre √†s ${hours.open} e fecha √†s ${hours.close}.`);\n            }\n        }\n    }\n\n    /**\n     * Calcula o frete baseado no tipo e dist√¢ncia/peso\n     */\n    static async calculateDeliveryFee(client: PoolClient, params: CreateOrderParams, listings: any[]) {\n        if (params.deliveryType === 'SELF_PICKUP') return 0;\n\n        if (params.deliveryType === 'COURIER_REQUEST') {\n            if (params.deliveryLat && params.deliveryLng && params.pickupLat && params.pickupLng) {\n                const R = 6371; // km\n                const dLat = (params.deliveryLat - params.pickupLat) * Math.PI / 180;\n                const dLon = (params.deliveryLng - params.pickupLng) * Math.PI / 180;\n                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                    Math.cos(params.pickupLat * Math.PI / 180) * Math.cos(params.deliveryLat * Math.PI / 180) *\n                    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                const distanceKm = R * c;\n\n                const configRes = await client.query('SELECT courier_price_per_km FROM system_config LIMIT 1');\n                const basePriceKm = parseFloat(configRes.rows[0]?.courier_price_per_km || '2.50');\n\n                return (5.00 + (distanceKm * basePriceKm)) * 1.275;\n            }\n            return Math.max(5.00, params.offeredDeliveryFee);\n        }\n\n        if (params.deliveryType === 'EXTERNAL_SHIPPING') {\n            const listing = listings[0];\n            const originCep = listing.pickup_postal_code || '00000000';\n            const destCepMatch = (params.deliveryAddress || '').match(/\\d{5}-?\\d{3}/);\n            const destCep = destCepMatch ? destCepMatch[0] : '00000000';\n\n            const totalWeight = listings.reduce((acc: number, l: any) => acc + (l.weight_grams || 1000), 0);\n            const quote = calculateShippingQuote(originCep, destCep, totalWeight, listing.free_shipping);\n\n            return listing.shipping_price > 0 && !listing.free_shipping ? parseFloat(listing.shipping_price) : quote.fee;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Verifica e valida limites de vendas do vendedor (CPF vs CNPJ)\n     */\n    static async validateSellerLimits(client: PoolClient, sellerId: number, orderAmount: number) {\n        const sellerRes = await client.query(\n            'SELECT seller_cpf_cnpj FROM users WHERE id = $1',\n            [sellerId]\n        );\n        const seller = sellerRes.rows[0];\n\n        const docClean = seller?.seller_cpf_cnpj ? seller.seller_cpf_cnpj.replace(/\\D/g, '') : '';\n        const isCpf = docClean.length <= 11;\n\n        if (isCpf) {\n            const startOfMonth = new Date();\n            startOfMonth.setDate(1);\n            startOfMonth.setHours(0, 0, 0, 0);\n\n            const salesRes = await client.query(`\n                SELECT COALESCE(SUM(amount), 0) as total \n                FROM marketplace_orders \n                WHERE seller_id = $1 \n                AND created_at >= $2 \n                AND status != 'CANCELLED'\n            `, [sellerId, startOfMonth]);\n\n            const monthlyTotal = parseFloat(salesRes.rows[0].total);\n            const LIMIT_CPF = 2000.00;\n\n            if (monthlyTotal + orderAmount > LIMIT_CPF) {\n                throw new Error(`Limite mensal de R$ ${LIMIT_CPF} para CPF atingido. Atualize para CNPJ.`);\n            }\n        }\n    }\n\n    /**\n     * Processa a cria√ß√£o de um pedido no Marketplace\n     */\n    static async createOrder(client: PoolClient, params: CreateOrderParams) {\n        // 1. Buscar Listagens\n        const listingsRes = await client.query(\n            'SELECT * FROM marketplace_listings WHERE id = ANY($1) AND status = $2 FOR UPDATE',\n            [params.listingIds, 'ACTIVE']\n        );\n\n        if (listingsRes.rows.length === 0) {\n            throw new Error('Itens indispon√≠veis.');\n        }\n\n        const listings = listingsRes.rows;\n        const sellerId = listings[0].seller_id;\n\n        // 2. Valida√ß√µes de Neg√≥cio\n        await this.validateOpeningHours(client, sellerId);\n\n        // 3. C√°lculo de Pre√ßo\n        let baseAmount = 0;\n        for (const listing of listings) {\n            let price = parseFloat(listing.price);\n\n            // Validar variante se houver\n            if (params.selectedVariantId && listing.id === params.listingIds[0]) {\n                const variantRes = await client.query(\n                    'SELECT price, stock FROM marketplace_listing_variants WHERE id = $1 FOR UPDATE',\n                    [params.selectedVariantId]\n                );\n                if (variantRes.rows.length === 0) throw new Error('Varia√ß√£o n√£o encontrada.');\n                if (variantRes.rows[0].stock < params.quantity) throw new Error('Estoque insuficiente na varia√ß√£o.');\n                price = parseFloat(variantRes.rows[0].price);\n            } else if (listing.stock !== null && listing.stock < params.quantity) {\n                throw new Error(`Estoque insuficiente para ${listing.title}.`);\n            }\n\n            baseAmount += price * (listings.length === 1 ? params.quantity : 1);\n        }\n\n        const optionsTotal = params.selectedOptions?.reduce((acc, opt) => acc + (opt.price || 0), 0) || 0;\n        const totalPrice = baseAmount + optionsTotal;\n\n        // 4. Validar limites do vendedor\n        await this.validateSellerLimits(client, sellerId, totalPrice);\n\n        // 5. Reten√ß√£o de Taxas (Escrow)\n        const sellerRes = await client.query('SELECT is_verified_seller FROM users WHERE id = $1', [sellerId]);\n        const isVerified = !!sellerRes.rows[0].is_verified_seller;\n        const feeRate = isVerified ? MARKETPLACE_ESCROW_FEE_RATE : MARKETPLACE_NON_VERIFIED_FEE_RATE;\n\n        // 6. Benef√≠cio de Boas-Vindas\n        const welcomeRes = await client.query('SELECT welcome_benefit_uses FROM users WHERE id = $1', [params.userId]);\n        const welcomeUses = welcomeRes.rows[0]?.welcome_benefit_uses || 0;\n        const hasWelcomeDiscount = welcomeUses < 3;\n        const effectiveEscrowRate = hasWelcomeDiscount ? 0.05 : feeRate; // 5% se tiver benef√≠cio\n\n        const platformFee = totalPrice * effectiveEscrowRate;\n        const sellerNet = totalPrice - platformFee;\n\n        // 7. Saldo e Travas\n        const deliveryFee = params.deliveryType === 'COURIER_REQUEST' ? params.offeredDeliveryFee : 0;\n        const totalToCharge = totalPrice + deliveryFee;\n\n        const balanceCheck = await lockUserBalance(client, params.userId.toString(), totalToCharge, { skipLockCheck: true });\n        if (!balanceCheck.success) throw new Error(balanceCheck.error || 'Saldo insuficiente.');\n\n        await updateUserBalance(client, params.userId.toString(), totalToCharge, 'debit');\n\n        // 8. Criar Pedido\n        const pickupCode = Math.floor(100000 + Math.random() * 900000).toString();\n        const deliveryCode = Math.floor(100000 + Math.random() * 900000).toString();\n\n        const orderRes = await client.query(`\n            INSERT INTO marketplace_orders (\n                buyer_id, seller_id, amount, status, platform_fee, seller_net,\n                delivery_type, delivery_address, contact_phone, quantity,\n                pickup_code, delivery_confirmation_code, delivery_fee,\n                metadata, created_at, payment_method\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, NOW(), 'BALANCE')\n            RETURNING id\n        `, [\n            params.userId, sellerId, totalPrice, 'PAYMENT_CONFIRMED', platformFee, sellerNet,\n            params.deliveryType, params.deliveryAddress, params.contactPhone, params.quantity,\n            pickupCode, deliveryCode, deliveryFee,\n            JSON.stringify({\n                listingIds: params.listingIds,\n                selectedVariantId: params.selectedVariantId,\n                selectedOptions: params.selectedOptions,\n                invitedCourierId: params.invitedCourierId,\n                pickupAddress: params.pickupAddress,\n                welcomeBenefitApplied: hasWelcomeDiscount\n            })\n        ]);\n\n        const orderId = orderRes.rows[0].id;\n\n        // 9. Financeiro e Transa√ß√µes\n        await updateUserBalance(client, sellerId.toString(), sellerNet, 'credit');\n\n        await createTransaction(\n            client,\n            params.userId.toString(),\n            'MARKET_PURCHASE',\n            totalToCharge,\n            `Compra: ${listings[0].title}`,\n            'APPROVED',\n            { orderId, useBalance: true }\n        );\n\n        await createTransaction(\n            client,\n            sellerId.toString(),\n            'MARKET_SALE',\n            sellerNet,\n            `Venda: ${listings[0].title}`,\n            'APPROVED',\n            { orderId }\n        );\n\n        // 10. Atualizar Estoque\n        if (params.selectedVariantId) {\n            await client.query(\n                'UPDATE marketplace_listing_variants SET stock = GREATEST(0, stock - $1) WHERE id = $2',\n                [params.quantity, params.selectedVariantId]\n            );\n        }\n        for (const l of listings) {\n            await client.query(\n                'UPDATE marketplace_listings SET stock = GREATEST(0, stock - $1) WHERE id = $2',\n                [params.quantity, l.id]\n            );\n        }\n\n        // 11. B√¥nus e Notifica√ß√µes (Async)\n        if (hasWelcomeDiscount) {\n            await client.query('UPDATE users SET welcome_benefit_uses = welcome_benefit_uses + 1 WHERE id = $1', [params.userId]);\n        }\n\n        await updateScore(client, params.userId.toString(), (SCORE_REWARDS as any).MARKETPLACE_PURCHASE || 10, 'Compra no Marketplace');\n\n        return { orderId, totalPrice, platformFee, sellerNet, hasWelcomeDiscount };\n    }\n\n    /**\n     * Processa a cria√ß√£o de um pedido no Marketplace via Cr√©dito (Credi√°rio)\n     */\n    static async createOrderOnCredit(client: PoolClient, params: CreateOrderParams & { installments: number }) {\n        // 1. Validar Oferta de Cr√©dito\n        const listingsRes = await client.query(\n            'SELECT * FROM marketplace_listings WHERE id = ANY($1) AND status = $2 FOR UPDATE',\n            [params.listingIds, 'ACTIVE']\n        );\n        if (listingsRes.rows.length === 0) throw new Error('Itens indispon√≠veis.');\n\n        const listings = listingsRes.rows;\n        const sellerId = listings[0].seller_id;\n\n        // Valida√ß√µes\n        await this.validateOpeningHours(client, sellerId);\n\n        let baseAmount = 0;\n        for (const listing of listings) {\n            let price = parseFloat(listing.price);\n            if (params.selectedVariantId && listing.id === params.listingIds[0]) {\n                const variantRes = await client.query('SELECT price, stock FROM marketplace_listing_variants WHERE id = $1 FOR UPDATE', [params.selectedVariantId]);\n                if (variantRes.rows.length === 0) throw new Error('Varia√ß√£o n√£o encontrada.');\n                if (variantRes.rows[0].stock < params.quantity) throw new Error('Estoque insuficiente na varia√ß√£o.');\n                price = parseFloat(variantRes.rows[0].price);\n            }\n            baseAmount += price * (listings.length === 1 ? params.quantity : 1);\n        }\n\n        const optionsTotal = params.selectedOptions?.reduce((acc, opt) => acc + (opt.price || 0), 0) || 0;\n        const deliveryFee = params.deliveryType === 'COURIER_REQUEST' ? params.offeredDeliveryFee : 0;\n        const totalPrice = baseAmount + optionsTotal + deliveryFee;\n\n        // 2. Calcular Financiamento (An√°lise de Cr√©dito)\n        const offer = await calculateLoanOffer(client, params.userId.toString(), totalPrice, params.installments);\n        if (!offer.isEligible) throw new Error(offer.reason || 'Cr√©dito negado para esta compra.');\n\n        // 3. Criar Empr√©stimo associado\n        const loanRes = await client.query(`\n            INSERT INTO loans (\n                user_id, amount, interest_rate, total_repayment, status, \n                installments, metadata, created_at\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())\n            RETURNING id\n        `, [\n            params.userId, totalPrice, offer.monthlyInterestRate, offer.totalRepayment, 'APPROVED',\n            params.installments, JSON.stringify({ type: 'MARKETPLACE', listingIds: params.listingIds })\n        ]);\n\n        const loanId = loanRes.rows[0].id;\n\n        // 4. Benef√≠cio de Boas-Vindas (Marketplace Fee)\n        const welcomeRes = await client.query('SELECT welcome_benefit_uses FROM users WHERE id = $1', [params.userId]);\n        const hasWelcomeDiscount = (welcomeRes.rows[0]?.welcome_benefit_uses || 0) < 3;\n        const feeRate = hasWelcomeDiscount ? 0.05 : MARKETPLACE_ESCROW_FEE_RATE;\n\n        const platformFee = (totalPrice - deliveryFee) * feeRate;\n        const sellerNet = (totalPrice - deliveryFee) - platformFee;\n\n        // 5. Criar Pedido\n        const pickupCode = Math.floor(100000 + Math.random() * 900000).toString();\n        const deliveryCode = Math.floor(100000 + Math.random() * 900000).toString();\n\n        const orderRes = await client.query(`\n            INSERT INTO marketplace_orders (\n                buyer_id, seller_id, amount, status, platform_fee, seller_net,\n                delivery_type, delivery_address, contact_phone, quantity,\n                pickup_code, delivery_confirmation_code, delivery_fee,\n                metadata, created_at, payment_method\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, NOW(), 'CRED30_CREDIT')\n            RETURNING id\n        `, [\n            params.userId, sellerId, totalPrice, 'PAYMENT_CONFIRMED', platformFee, sellerNet,\n            params.deliveryType, params.deliveryAddress, params.contactPhone, params.quantity,\n            pickupCode, deliveryCode, deliveryFee,\n            JSON.stringify({ orderId: 'REPLACED_LATER', loanId })\n        ]);\n\n        const orderId = orderRes.rows[0].id;\n        await client.query(\"UPDATE loans SET metadata = metadata || $1 WHERE id = $2\", [JSON.stringify({ orderId }), loanId]);\n\n        // 6. Parcelamento\n        const standardInstallment = Math.floor((offer.totalRepayment / params.installments) * 100) / 100;\n        let remainingTotal = offer.totalRepayment;\n\n        for (let i = 1; i <= params.installments; i++) {\n            const dueDate = new Date();\n            dueDate.setMonth(dueDate.getMonth() + i);\n            const installmentAmount = (i === params.installments) ? Math.round(remainingTotal * 100) / 100 : standardInstallment;\n\n            await client.query(`\n                INSERT INTO loan_installments (loan_id, installment_number, amount, expected_amount, due_date, status)\n                VALUES ($1, $2, $3, $3, $4, 'PENDING')\n            `, [loanId, i, installmentAmount, dueDate]);\n\n            remainingTotal -= installmentAmount;\n        }\n\n        // 7. Financeiro\n        await updateUserBalance(client, sellerId.toString(), sellerNet, 'credit');\n        await createTransaction(client, sellerId.toString(), 'MARKET_SALE', sellerNet, `Venda (Cr√©dito): ${listings[0].title}`, 'APPROVED', { orderId, loanId });\n        await createTransaction(client, params.userId.toString(), 'MARKET_CREDIT_PURCHASE', totalPrice, `Compra Parcelada (${params.installments}x): ${listings[0].title}`, 'APPROVED', { orderId, loanId });\n\n        // 8. Estoque\n        for (const l of listings) {\n            await client.query('UPDATE marketplace_listings SET stock = GREATEST(0, stock - $1) WHERE id = $2', [params.quantity, l.id]);\n        }\n\n        if (hasWelcomeDiscount) {\n            await client.query('UPDATE users SET welcome_benefit_uses = welcome_benefit_uses + 1 WHERE id = $1', [params.userId]);\n        }\n\n        return { orderId, loanId, totalPrice, hasWelcomeDiscount };\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/domain/services/transaction.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LOAN_GFC_FEE_RATE' is defined but never used.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"LOAN_GFC_FEE_RATE"},"fix":{"range":[268,289],"text":""},"desc":"Remove unused variable \"LOAN_GFC_FEE_RATE\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[793,796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[793,796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1307,1310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1307,1310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":51,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":51,"endColumn":31},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":52,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":52,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5328,5331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5328,5331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9815,9818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9815,9818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14797,14800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14797,14800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":608,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":608,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23973,23976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23973,23976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":624,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":624,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24718,24721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24718,24721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":643,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":643,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25312,25315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25312,25315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":664,"column":11,"nodeType":"Literal","messageId":"unexpected","endLine":664,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":666,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":666,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26308,26311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26308,26311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":709,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":709,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27906,27909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27906,27909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":777,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":777,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31030,31033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31030,31033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\nimport {\n  QUOTA_PRICE,\n  QUOTA_SHARE_VALUE,\n  QUOTA_ADM_FEE,\n  PLATFORM_FEE_TAX_SHARE,\n  PLATFORM_FEE_OPERATIONAL_SHARE,\n  PLATFORM_FEE_OWNER_SHARE,\n  PLATFORM_FEE_INVESTMENT_SHARE,\n  PLATFORM_FEE_CORPORATE_SHARE,\n  ONE_MONTH_MS,\n  LOAN_GFC_FEE_RATE\n} from '../../shared/constants/business.constants';\nimport { calculateGatewayCost } from '../../shared/utils/financial.utils';\nimport { updateScore, SCORE_REWARDS } from '../../application/services/score.service';\nimport { logAudit } from '../../application/services/audit.service';\nimport { notificationService } from '../../application/services/notification.service';\nimport { calculateUserLoanLimit } from '../../application/services/credit-analysis.service';\n\nexport interface TransactionResult<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n/**\n * Executa uma opera√ß√£o dentro de uma transa√ß√£o database ACID\n */\nexport async function executeInTransaction<T>(\n  pool: Pool,\n  operation: (client: PoolClient) => Promise<T>\n): Promise<TransactionResult<T>> {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const result = await operation(client);\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      data: result\n    };\n  } catch (error: any) {\n    await client.query('ROLLBACK');\n\n    const logMessage = `\\n[${new Date().toISOString()}] Erro na transa√ß√£o:\\n${error.stack || error}\\n`;\n    try {\n      const fs = require('fs');\n      const path = require('path');\n      const logDir = path.join(process.cwd(), 'logs');\n      if (!fs.existsSync(logDir)) fs.mkdirSync(logDir);\n      fs.appendFileSync(path.join(logDir, 'sql-error.log'), logMessage);\n    } catch (logErr) {\n      console.error('Falha ao escrever log de erro SQL:', logErr);\n    }\n\n    console.error('Erro na transa√ß√£o:', error);\n\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro desconhecido na transa√ß√£o'\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Verifica e bloqueia saldo do usu√°rio para opera√ß√£o\n */\nexport async function lockUserBalance(\n  client: Pool | PoolClient,\n  userId: string,\n  amount: number,\n  options?: { skipLockCheck?: boolean }\n): Promise<{ success: boolean; currentBalance?: number; error?: string }> {\n  try {\n    const result = await client.query(\n      'SELECT balance, security_lock_until FROM users WHERE id = $1 FOR UPDATE',\n      [userId]\n    );\n\n    if (result.rows.length === 0) {\n      return { success: false, error: 'Usu√°rio n√£o encontrado' };\n    }\n\n    const userData = result.rows[0];\n    const currentBalance = parseFloat(userData.balance);\n    const lockUntil = userData.security_lock_until;\n\n    // Trava de Seguran√ßa Global (Anti-Gasto de Saldo Suspeito / Lavagem Interna)\n    if (lockUntil && new Date(lockUntil) > new Date()) {\n      // Se a op√ß√£o de pular a verifica√ß√£o de trava estiver ativa (ex: Compra de Cotas, Pagamento de Empr√©stimo)\n      if (options?.skipLockCheck) {\n        // Logar que a trava foi ignorada por ser uma opera√ß√£o permitida\n        // console.log(`[SECURITY_BYPASS] Opera√ß√£o permitida durante trava de seguran√ßa para user ${userId}`);\n      } else {\n        return {\n          success: false,\n          error: `Seu saldo est√° sob prote√ß√£o tempor√°ria e n√£o pode ser usado no momento. Liberado em: ${new Date(lockUntil).toLocaleString('pt-BR')}`\n        };\n      }\n    }\n\n    if (currentBalance < amount) {\n      return {\n        success: false,\n        currentBalance,\n        error: `Saldo insuficiente. Saldo atual: R$ ${currentBalance.toFixed(2)}`\n      };\n    }\n\n    return { success: true, currentBalance };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao verificar saldo'\n    };\n  }\n}\n\n/**\n * Bloqueia e retorna as configura√ß√µes globais do sistema para atualiza√ß√£o at√¥mica\n */\nexport async function lockSystemConfig(client: Pool | PoolClient) {\n  const result = await client.query('SELECT * FROM system_config FOR UPDATE');\n  return result.rows[0];\n}\n\n/**\n * Atualiza saldo do usu√°rio de forma segura\n */\nexport async function updateUserBalance(\n  client: Pool | PoolClient,\n  userId: string,\n  amount: number,\n  operation: 'debit' | 'credit' = 'debit'\n): Promise<{ success: boolean; newBalance?: number; error?: string }> {\n  try {\n    const query = operation === 'debit'\n      ? 'UPDATE users SET balance = balance - $1 WHERE id = $2 RETURNING balance'\n      : 'UPDATE users SET balance = balance + $1 WHERE id = $2 RETURNING balance';\n\n    const result = await client.query(query, [amount, userId]);\n\n    if (result.rows.length === 0) {\n      return { success: false, error: 'Usu√°rio n√£o encontrado' };\n    }\n\n    const newBalance = parseFloat(result.rows[0].balance);\n\n    if (newBalance < 0) {\n      throw new Error('Saldo negativo n√£o permitido');\n    }\n\n    return { success: true, newBalance };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao atualizar saldo'\n    };\n  }\n}\n\n/**\n * Cria registro de transa√ß√£o com valida√ß√£o\n */\nexport async function createTransaction(\n  client: Pool | PoolClient,\n  userId: string,\n  type: string,\n  amount: number,\n  description: string,\n  status: string = 'PENDING',\n  metadata?: any\n): Promise<{ success: boolean; transactionId?: number; error?: string }> {\n  try {\n    // SECURITY ENFORCEMENT: Carteira √önica (Single Entry/Exit)\n    // Bloquear tentativas de pagamento externo direto para opera√ß√µes internas.\n    // A √∫nica entrada de dinheiro permitida √© via DEPOST (Dep√≥sito).\n    const BALANCE_ONLY_TYPES = ['BUY_QUOTA', 'LOAN_PAYMENT', 'MARKET_PURCHASE', 'MARKET_BOOST', 'MEMBERSHIP_UPGRADE'];\n\n    if (BALANCE_ONLY_TYPES.includes(type)) {\n      // Se user n√£o enviou metadata ou useBalance n√£o √© true\n      if (!metadata || !metadata.useBalance) {\n        return {\n          success: false,\n          error: 'Opera√ß√£o permitida apenas com Saldo Interno via App. Por favor, realize um dep√≥sito primeiro.'\n        };\n      }\n    }\n\n    const result = await client.query(\n      `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n       VALUES ($1, $2, $3, $4, $5, $6)\n       RETURNING id`,\n      [userId, type, amount, description, status, metadata ? JSON.stringify(metadata) : null]\n    );\n\n    return {\n      success: true,\n      transactionId: result.rows[0].id\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao criar transa√ß√£o'\n    };\n  }\n}\n\n/**\n * Atualiza status de transa√ß√£o com valida√ß√£o de concorr√™ncia\n */\nexport async function updateTransactionStatus(\n  client: Pool | PoolClient,\n  transactionId: string | number,\n  currentStatus: string,\n  newStatus: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const result = await client.query(\n      'UPDATE transactions SET status = $1 WHERE id = $2 AND status = $3',\n      [newStatus, transactionId, currentStatus]\n    );\n\n    if (result.rowCount === 0) {\n      return {\n        success: false,\n        error: 'Transa√ß√£o n√£o encontrada ou j√° foi processada'\n      };\n    }\n\n    return { success: true };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao atualizar transa√ß√£o'\n    };\n  }\n}\n\n/**\n * Processa a aprova√ß√£o ou rejei√ß√£o de uma transa√ß√£o (BUY_QUOTA, WITHDRAWAL, etc)\n */\nexport const processTransactionApproval = async (client: PoolClient, id: string, action: 'APPROVE' | 'REJECT') => {\n  console.log(`[DEBUG] processTransactionApproval CHAMADO! ID: ${id}, Action: ${action}`);\n  // 1. Buscar transa√ß√£o com bloqueio (aceita PENDING ou PENDING_CONFIRMATION para saques)\n  const transactionResult = await client.query(\n    'SELECT * FROM transactions WHERE id = $1 AND status IN ($2, $3) FOR UPDATE',\n    [id, 'PENDING', 'PENDING_CONFIRMATION']\n  );\n\n  if (transactionResult.rows.length === 0) {\n    throw new Error('Transa√ß√£o n√£o encontrada ou j√° processada');\n  }\n\n  const transaction = transactionResult.rows[0];\n\n  if (action === 'REJECT') {\n    // Saques n√£o debitam saldo na solicita√ß√£o (usam limite de cr√©dito), \n    // portanto n√£o h√° saldo para devolver nem caixa operacional para ajustar na rejei√ß√£o.\n    if (transaction.type === 'WITHDRAWAL') {\n      // Devolver saldo ao usu√°rio caso o saque seja rejeitado\n      await updateUserBalance(client, transaction.user_id, Math.abs(parseFloat(transaction.amount)), 'credit');\n      console.log(`[REJECT_WITHDRAWAL] R$ ${transaction.amount} devolvidos ao usu√°rio ${transaction.user_id}`);\n    }\n\n    if (transaction.type === 'BUY_QUOTA') {\n      const metadata = transaction.metadata || {};\n      if (metadata.useBalance) {\n        await updateUserBalance(client, transaction.user_id, parseFloat(transaction.amount), 'credit');\n      }\n    }\n\n    if (transaction.type === 'LOAN_PAYMENT') {\n      const metadata = transaction.metadata || {};\n      if (metadata.useBalance && metadata.loanId) {\n        await updateUserBalance(client, transaction.user_id, parseFloat(transaction.amount), 'credit');\n        await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['APPROVED', metadata.loanId]);\n      }\n    }\n\n    await client.query(\n      'UPDATE transactions SET status = $1, processed_at = $2 WHERE id = $3',\n      ['REJECTED', new Date(), id]\n    );\n\n    // Audit Log\n    await logAudit(client, {\n      userId: transaction.user_id,\n      action: 'TRANSACTION_REJECTED',\n      entityType: 'transaction',\n      entityId: id,\n      oldValues: { status: 'PENDING' },\n      newValues: { status: 'REJECTED' }\n    });\n\n    return { success: true, status: 'REJECTED' };\n  }\n\n  // APROVA√á√ÉO\n  if (transaction.type === 'BUY_QUOTA') {\n    let metadata: any = transaction.metadata || {};\n    // Garantir que metadata seja objeto se for string\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    let qty = metadata.quantity || Math.floor(parseFloat(transaction.amount) / QUOTA_PRICE);\n    if (qty <= 0) qty = 1;\n\n    for (let i = 0; i < qty; i++) {\n      await client.query(\n        `INSERT INTO quotas (user_id, purchase_price, current_value, purchase_date, status)\n         VALUES ($1, $2, $3, $4, 'ACTIVE')`,\n        [transaction.user_id, QUOTA_PRICE, QUOTA_SHARE_VALUE, new Date()]\n      );\n    }\n\n    await updateScore(client, transaction.user_id, SCORE_REWARDS.QUOTA_PURCHASE * qty, `Compra de ${qty} cotas`);\n\n    // --- PAGAMENTO DE B√îNUS DE INDICA√á√ÉO (R$ 5,00) ---\n    // Apenas se for dinheiro novo (n√£o useBalance), ou conforme regra de neg√≥cio global.\n    // Como a transa√ß√£o foi aprovada e dinheiro entrou (ou saldo foi debitado), pagamos o b√¥nus.\n\n    // 1. Verificar se usu√°rio tem indicador\n    const userRes = await client.query('SELECT referred_by, name FROM users WHERE id = $1', [transaction.user_id]);\n    const buyer = userRes.rows[0];\n\n    if (buyer?.referred_by) {\n      const referrerRes = await client.query('SELECT id FROM users WHERE referral_code = $1', [buyer.referred_by]);\n\n      if (referrerRes.rows.length > 0) {\n        const referrerId = referrerRes.rows[0].id;\n        const bonusAmount = 5.00;\n        // --- PAGAMENTO DE B√îNUS DE INDICA√á√ÉO (R$ 5,00) ---\n        // REGRA: S√≥ libera se tiver gerado lucros (profit_pool)\n        const sysRes = await client.query('SELECT profit_pool FROM system_config LIMIT 1');\n        const profitPool = parseFloat(sysRes.rows[0].profit_pool);\n\n        if (profitPool >= bonusAmount) {\n          // Creditar B√¥nus\n          await updateUserBalance(client, referrerId, bonusAmount, 'credit');\n\n          // Deduzir do Pool de Lucros (B√¥nus √© pago com o lucro gerado)\n          await client.query(\n            'UPDATE system_config SET profit_pool = profit_pool - $1',\n            [bonusAmount]\n          );\n\n          // Registrar Transa√ß√£o do B√¥nus\n          await createTransaction(\n            client,\n            referrerId,\n            'REFERRAL_BONUS',\n            bonusAmount,\n            `B√¥nus por indica√ß√£o: ${buyer.name} comprou cota(s)`,\n            'APPROVED'\n          );\n        } else {\n          // Se n√£o houver lucro no momento, o b√¥nus fica registrado como PENDING (aguardando lucro)\n          await createTransaction(\n            client,\n            referrerId,\n            'REFERRAL_BONUS',\n            bonusAmount,\n            `B√¥nus por indica√ß√£o: ${buyer.name} comprou cota(s) (AGUARDANDO RESULTADOS DO SISTEMA)`,\n            'PENDING'\n          );\n        }\n      }\n    }\n\n    if (!metadata.useBalance) {\n      const paymentMethod = metadata.paymentMethod || 'pix';\n      // Extrair o valor base (o que o sistema realmente quer receber)\n      const serviceFee = metadata.serviceFee ? parseFloat(metadata.serviceFee) : 0;\n      const baseCost = metadata.baseCost ? parseFloat(metadata.baseCost) : (parseFloat(transaction.amount) - (metadata.userFee ? parseFloat(metadata.userFee) : 0) - serviceFee);\n\n      const gatewayCost = calculateGatewayCost(baseCost, paymentMethod);\n\n      await client.query(\n        'UPDATE transactions SET gateway_cost = $1 WHERE id = $2',\n        [gatewayCost, transaction.id]\n      );\n\n      // Atualizar caixa do sistema\n      // O gateway cost √© subtra√≠do conforme regra atual.\n\n      await client.query(\n        'UPDATE system_config SET system_balance = system_balance + $1 - $2, total_gateway_costs = total_gateway_costs + $2',\n        [parseFloat(transaction.amount), gatewayCost]\n      );\n\n      // Distribuir a Taxa de Servi√ßo e Principal\n      const totalAdmFee = qty * QUOTA_ADM_FEE;\n      const principalAmount = qty * QUOTA_SHARE_VALUE;\n\n      const taxAmount = totalAdmFee * PLATFORM_FEE_TAX_SHARE;\n      const operationalAmount = totalAdmFee * PLATFORM_FEE_OPERATIONAL_SHARE;\n      const ownerAmount = totalAdmFee * PLATFORM_FEE_OWNER_SHARE;\n      const growthAmount = totalAdmFee * PLATFORM_FEE_INVESTMENT_SHARE;\n      const corporateAmount = totalAdmFee * PLATFORM_FEE_CORPORATE_SHARE;\n\n      await client.query(\n        `UPDATE system_config SET \n          total_tax_reserve = total_tax_reserve + $1,\n          total_operational_reserve = total_operational_reserve + $2,\n          total_owner_profit = total_owner_profit + $3,\n          mutual_reserve = COALESCE(mutual_reserve, 0) + $4,\n          total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5,\n          investment_reserve = COALESCE(investment_reserve, 0) + $6,\n          system_balance = system_balance + $7`,\n        [taxAmount, operationalAmount, ownerAmount, growthAmount, corporateAmount, principalAmount, parseFloat(transaction.amount)]\n      );\n    }\n  }\n\n  if (transaction.type === 'LOAN_PAYMENT') {\n    let metadata: any = transaction.metadata || {};\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    if (metadata.loanId) {\n      const loanResult = await client.query('SELECT * FROM loans WHERE id = $1 FOR UPDATE', [metadata.loanId]);\n      if (loanResult.rows.length > 0) {\n        const loan = loanResult.rows[0];\n        let gatewayCost = 0;\n\n        if (!metadata.useBalance) {\n          const paymentMethod = metadata.paymentMethod || 'pix';\n          const baseAmount = metadata.baseAmount ? parseFloat(metadata.baseAmount) : parseFloat(transaction.amount);\n          gatewayCost = calculateGatewayCost(baseAmount, paymentMethod);\n\n          await client.query('UPDATE transactions SET gateway_cost = $1 WHERE id = $2', [gatewayCost, transaction.id]);\n          await client.query('UPDATE system_config SET total_gateway_costs = total_gateway_costs + $1', [gatewayCost]);\n        }\n\n        // Usamos o valor l√≠quido do pagamento (sem a taxa de gateway que o cliente pagou)\n        const userFee = metadata.userFee ? parseFloat(metadata.userFee) : 0;\n        const actualPaymentAmount = metadata.baseAmount ? parseFloat(metadata.baseAmount) : (parseFloat(transaction.amount) - userFee);\n        const loanPrincipal = parseFloat(loan.amount);\n        const loanTotal = parseFloat(loan.total_repayment);\n\n        const principalPortion = actualPaymentAmount * (loanPrincipal / loanTotal);\n        const interestPortion = actualPaymentAmount - principalPortion;\n\n        // CORRE√á√ÉO CR√çTICA (Fluxo de Caixa Cont√°bil):\n        // 1. O PRINCIPAL recebido deve voltar para a investment_reserve (de onde o empr√©stimo saiu).\n        // 2. O JUROS recebido √© LUCRO. Ele deve ser dividido:\n        //    - 80% vai para o profit_pool (Para os usu√°rios/dividendos).\n        //    - 20% √© retido como Taxa de Administra√ß√£o sobre o lucro (Para o sistema).\n\n        const interestUserShare = interestPortion * 0.80; // 80% dos juros para usu√°rios\n        const interestSystemFee = interestPortion * 0.20; // 20% dos juros para o sistema\n\n        // A. Se pagamento externo (PIX): O dinheiro entra agora no caixa\n        if (!metadata.useBalance) {\n          await client.query(\n            'UPDATE system_config SET system_balance = system_balance + $1',\n            [actualPaymentAmount]\n          );\n        }\n\n        // B. Reabastecer a Reserva de Investimento com o Principal recuperado (Contabilidade)\n        // Isso garante que o fundo de empr√©stimos seja \"girat√≥rio\" e sustent√°vel\n        await client.query(\n          'UPDATE system_config SET investment_reserve = investment_reserve + $1',\n          [principalPortion]\n        );\n\n        // C. Distribuir os Juros (Lucro)\n        // C1. Parte dos Usu√°rios\n        await client.query(\n          'UPDATE system_config SET profit_pool = profit_pool + $1',\n          [interestUserShare]\n        );\n\n        // C2. Parte do Sistema (Taxa sobre o lucro do empr√©stimo)\n        // Distribu√≠da conforme regra 25/25/25/25\n        if (interestSystemFee > 0) {\n          await client.query(\n            `UPDATE system_config SET \n              total_tax_reserve = total_tax_reserve + $1,\n              total_operational_reserve = total_operational_reserve + $2,\n              total_owner_profit = total_owner_profit + $3,\n              investment_reserve = investment_reserve + $4,\n              total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5`,\n            [\n              interestSystemFee * PLATFORM_FEE_TAX_SHARE,\n              interestSystemFee * PLATFORM_FEE_OPERATIONAL_SHARE,\n              interestSystemFee * PLATFORM_FEE_OWNER_SHARE,\n              interestSystemFee * PLATFORM_FEE_INVESTMENT_SHARE,\n              interestSystemFee * PLATFORM_FEE_CORPORATE_SHARE\n            ]\n          );\n        }\n\n        console.log(`[LOAN_PAYMENT_DISTRIBUTION]\n          Total Recebido: ${actualPaymentAmount.toFixed(2)}\n          Principal Recuperado (InvestReserve): ${principalPortion.toFixed(2)}\n          Lucro Total (Juros): ${interestPortion.toFixed(2)}\n          -> Usu√°rios (80%): ${interestUserShare.toFixed(2)}\n          -> Taxa Adm (20%): ${interestSystemFee.toFixed(2)}`\n        );\n\n        const isInstallment = metadata.paymentType === 'installment' || metadata.isInstallment === true;\n        const isFullPayment = metadata.paymentType === 'full_payment' || (!isInstallment && loan.status === 'PAYMENT_PENDING');\n\n        if (isFullPayment) {\n          // Registrar ou Atualizar a parcela no cronograma\n          if (metadata.installmentId) {\n            await client.query(\n              'UPDATE loan_installments SET amount = $1, status = $2, use_balance = $3, paid_at = NOW() WHERE id = $4',\n              [actualPaymentAmount, 'PAID', metadata.useBalance || false, metadata.installmentId]\n            );\n          } else {\n            await client.query(\n              'INSERT INTO loan_installments (loan_id, amount, use_balance, created_at, status, paid_at) VALUES ($1, $2, $3, $4, $5, NOW())',\n              [metadata.loanId, actualPaymentAmount, metadata.useBalance || false, new Date(), 'PAID']\n            );\n          }\n          await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['PAID', metadata.loanId]);\n          console.log(`[LOAN_PAYMENT] Empr√©stimo ${metadata.loanId} quitado integralmente. Registro de pagamento criado.`);\n        } else if (isInstallment) {\n          if (metadata.installmentId) {\n            await client.query(\n              'UPDATE loan_installments SET amount = $1, status = $2, use_balance = $3, paid_at = NOW() WHERE id = $4',\n              [actualPaymentAmount, 'PAID', metadata.useBalance || false, metadata.installmentId]\n            );\n          } else {\n            await client.query(\n              'INSERT INTO loan_installments (loan_id, amount, use_balance, created_at, status, paid_at) VALUES ($1, $2, $3, $4, $5, NOW())',\n              [metadata.loanId, actualPaymentAmount, metadata.useBalance || false, new Date(), 'PAID']\n            );\n          }\n\n          // Amortiza√ß√£o Real: Diminuir o saldo devedor total e o principal\n          await client.query(\n            'UPDATE loans SET total_repayment = total_repayment - $1, amount = amount - $2 WHERE id = $3',\n            [actualPaymentAmount, principalPortion, metadata.loanId]\n          );\n\n          // Verificar se completou o pagamento\n          const paidInstallmentsResult = await client.query(\n            'SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) as paid_amount FROM loan_installments WHERE loan_id = $1',\n            [metadata.loanId]\n          );\n          const totalPaid = parseFloat(paidInstallmentsResult.rows[0].paid_amount);\n\n          if (totalPaid >= loanTotal - 0.01) { // Margem para erro de arredondamento\n            await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['PAID', metadata.loanId]);\n            console.log(`[LOAN_PAYMENT] Empr√©stimo ${metadata.loanId} quitado via parcelas.`);\n          } else {\n            // Garantir que o status volte para APPROVED se estava PENDING\n            await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['APPROVED', metadata.loanId]);\n            console.log(`[LOAN_PAYMENT] Parcela de R$ ${actualPaymentAmount} registrada para Empr√©stimo ${metadata.loanId}.`);\n          }\n        }\n\n        await updateScore(client, transaction.user_id, SCORE_REWARDS.LOAN_PAYMENT_ON_TIME, 'Pagamento de empr√©stimo');\n      }\n    }\n  }\n\n  // UPGRADE PRO\n  if (transaction.type === 'MEMBERSHIP_UPGRADE') {\n    // 1. Ativar Plano PRO para o usu√°rio\n    await client.query('UPDATE users SET membership_type = $1 WHERE id = $2', ['PRO', transaction.user_id]);\n\n    // 2. Distribuir o valor (regra 25/25/25/25)\n    const upgradeFee = Math.abs(parseFloat(transaction.amount));\n\n    await client.query(\n      `UPDATE system_config SET \n        total_tax_reserve = total_tax_reserve + $1,\n        total_operational_reserve = total_operational_reserve + $2,\n        total_owner_profit = total_owner_profit + $3,\n        investment_reserve = investment_reserve + $4,\n        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5`,\n      [\n        upgradeFee * PLATFORM_FEE_TAX_SHARE,\n        upgradeFee * PLATFORM_FEE_OPERATIONAL_SHARE,\n        upgradeFee * PLATFORM_FEE_OWNER_SHARE,\n        upgradeFee * PLATFORM_FEE_INVESTMENT_SHARE,\n        upgradeFee * PLATFORM_FEE_CORPORATE_SHARE\n      ]\n    );\n\n    // S√≥ aumenta o saldo do sistema se houver entrada real de dinheiro (n√£o useBalance)\n    if (transaction.metadata && !(typeof transaction.metadata === 'object' ? transaction.metadata : JSON.parse(transaction.metadata)).useBalance) {\n      await client.query('UPDATE system_config SET system_balance = system_balance + $1', [upgradeFee]);\n    }\n\n    // 3. B√¥nus de Score por se tornar PRO\n    await updateScore(client, transaction.user_id, 100, 'Upgrade para Plano Cred30 PRO');\n\n    console.log(`[UPGRADE_PRO] Usu√°rio ${transaction.user_id} agora √© PRO via transa√ß√£o ${id}`);\n  }\n\n  // COMPRA NO MARKETPLACE\n  if (transaction.type === 'MARKET_PURCHASE') {\n    let metadata: any = transaction.metadata || {};\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    if (metadata.orderId) {\n      // 1. Atualizar status do pedido para 'Aguardando Envio'\n      await client.query(\n        \"UPDATE marketplace_orders SET status = 'WAITING_SHIPPING', updated_at = NOW() WHERE id = $1\",\n        [metadata.orderId]\n      );\n\n      // 2. Se houver taxa de gateway externa (PIX/Cart√£o), contabilizar\n      if (metadata.externalReference || metadata.gatewayId) {\n        const paymentMethod = metadata.paymentMethod || 'pix';\n        const baseAmount = parseFloat(transaction.amount);\n        const gatewayCost = calculateGatewayCost(baseAmount, paymentMethod as any);\n\n        await client.query(\n          'UPDATE transactions SET gateway_cost = $1 WHERE id = $2',\n          [gatewayCost, transaction.id]\n        );\n\n        await client.query(\n          'UPDATE system_config SET system_balance = system_balance + $1 - $2, total_gateway_costs = total_gateway_costs + $2',\n          [parseFloat(transaction.amount), gatewayCost]\n        );\n      }\n\n      console.log(`[MARKET_PURCHASE] Pedido ${metadata.orderId} aprovado via transa√ß√£o ${id}`);\n    }\n  }\n\n  // IMPULSIONAMENTO NO MARKETPLACE\n  if (transaction.type === 'MARKET_BOOST') {\n    let metadata: any = transaction.metadata || {};\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    if (metadata.listingId) {\n      // 1. Ativar o Boost no an√∫ncio\n      const expiresAt = new Date();\n      expiresAt.setDate(expiresAt.getDate() + 7);\n\n      await client.query(\n        'UPDATE marketplace_listings SET is_boosted = TRUE, boost_expires_at = $1 WHERE id = $2',\n        [expiresAt, metadata.listingId]\n      );\n\n      // 2. Distribuir a taxa (85% para cotistas / 15% Operacional)\n      // Se for pagamento externo, considerar o gateway fee\n      const boostFee = Math.abs(parseFloat(transaction.amount));\n      let gatewayCost = 0;\n\n      // Gateway externo removido - processamento interno apenas\n      if (false) { // Bloco desativado - era: metadata.asaas_id || metadata.external_reference\n        const paymentMethod = metadata.paymentMethod || 'pix';\n        gatewayCost = calculateGatewayCost(boostFee, paymentMethod as any);\n\n        await client.query(\n          'UPDATE transactions SET gateway_cost = $1 WHERE id = $2',\n          [gatewayCost, transaction.id]\n        );\n\n        await client.query(\n          'UPDATE system_config SET total_gateway_costs = total_gateway_costs + $1',\n          [gatewayCost]\n        );\n      }\n\n      // Valor l√≠quido para distribui√ß√£o (depois do gateway cost)\n      const netBoostFee = boostFee - gatewayCost;\n\n      await client.query(\n        `UPDATE system_config SET \n          total_tax_reserve = total_tax_reserve + $1,\n          total_operational_reserve = total_operational_reserve + $2,\n          total_owner_profit = total_owner_profit + $3,\n          investment_reserve = investment_reserve + $4,\n          total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5`,\n        [\n          netBoostFee * PLATFORM_FEE_TAX_SHARE,\n          netBoostFee * PLATFORM_FEE_OPERATIONAL_SHARE,\n          netBoostFee * PLATFORM_FEE_OWNER_SHARE,\n          netBoostFee * PLATFORM_FEE_INVESTMENT_SHARE,\n          netBoostFee * PLATFORM_FEE_CORPORATE_SHARE\n        ]\n      );\n\n      // Aumentar saldo do sistema apenas pelo valor bruto que entrou via gateway\n      if (metadata.asaas_id || metadata.external_reference) {\n        await client.query('UPDATE system_config SET system_balance = system_balance + $1', [boostFee]);\n      }\n\n      console.log(`[MARKET_BOOST] An√∫ncio ${metadata.listingId} impulsionado via transa√ß√£o ${id}`);\n    }\n  }\n\n  // SAQUE (Dedu√ß√£o real do caixa operacional)\n  if (transaction.type === 'WITHDRAWAL') {\n    let metadata: any = transaction.metadata || {};\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    const netAmount = parseFloat(metadata.netAmount || transaction.amount);\n    const feeAmount = parseFloat(metadata.feeAmount || '0');\n\n    // --- RE-VALIDA√á√ÉO DE LIQUIDEZ REAL (Somente Warning) ---\n    // N√£o vamos bloquear a aprova√ß√£o t√©cnica da transa√ß√£o aqui, pois o usu√°rio j√° teve o saldo debitado na solicita√ß√£o.\n    // Se n√£o houver liquidez no caixa do banco (Asaas), o Admin ver√° isso na fila de pagamentos \"PENDING_PAYMENT\" e n√£o conseguir√° pagar.\n    // Bloquear aqui causaria um estado inconsistente onde o usu√°rio v√™ \"Erro 500\" mas o dinheiro j√° saiu da conta dele (Pending).\n\n    const configRes = await client.query(\"SELECT system_balance, total_tax_reserve, total_operational_reserve, total_owner_profit FROM system_config LIMIT 1\");\n    const config = configRes.rows[0] || {};\n\n    const totalReserves = (parseFloat(config.total_tax_reserve || '0')) +\n      (parseFloat(config.total_operational_reserve || '0')) +\n      (parseFloat(config.total_owner_profit || '0'));\n\n    const realLiquidity = (parseFloat(config.system_balance || '0')) - totalReserves;\n\n    // Apenas logar aviso se liquidez estiver baixa, mas prosseguir para criar o registro de pagamento pendente\n    if (netAmount > realLiquidity) {\n      console.warn(`[WARNING] Saque aprovado com liquidez apertada. Dispon√≠vel: ${realLiquidity}, Solicitado: ${netAmount}`);\n    }\n\n    // 1. Subtrair o valor enviado (l√≠quido) do saldo real do sistema\n    // PIX Manual - sem custo de gateway externo\n    const totalDeduction = netAmount;\n\n    await client.query(\n      'UPDATE system_config SET system_balance = system_balance - $1',\n      [totalDeduction]\n    );\n\n    // 2. Se houver taxa cobrada do usu√°rio (ex: R$ 2,00), aplicar a regra de divis√£o: 25/25/25/25\n    if (feeAmount > 0) {\n      await client.query(\n        `UPDATE system_config SET \n          total_tax_reserve = total_tax_reserve + $1,\n          total_operational_reserve = total_operational_reserve + $2,\n          total_owner_profit = total_owner_profit + $3,\n          investment_reserve = investment_reserve + $4,\n          total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5`,\n        [\n          feeAmount * PLATFORM_FEE_TAX_SHARE,\n          feeAmount * PLATFORM_FEE_OPERATIONAL_SHARE,\n          feeAmount * PLATFORM_FEE_OWNER_SHARE,\n          feeAmount * PLATFORM_FEE_INVESTMENT_SHARE,\n          feeAmount * PLATFORM_FEE_CORPORATE_SHARE\n        ]\n      );\n    }\n\n    // CORRE√á√ÉO: O system_balance foi debitado pelo netAmount acima. \n    // A taxa (feeAmount) nunca saiu do caixa, ent√£o n√£o precisamos adicion√°-la de volta.\n    // Ela j√° est√° no system_balance remanescente.\n    console.log('DEBUG - Saque processado contabilmente (PIX Manual):', {\n      netAmount,\n      feeAmount,\n      totalDeduction\n    });\n  }\n\n  // DEP√ìSITO (Cr√©dito real no saldo do usu√°rio)\n  if (transaction.type === 'DEPOSIT') {\n    const depositAmount = parseFloat(transaction.amount);\n    let metadata: any = transaction.metadata || {};\n    if (typeof metadata === 'string') {\n      try { metadata = JSON.parse(metadata); } catch { metadata = {}; }\n    }\n\n    // 1. Creditar saldo no usu√°rio\n    await updateUserBalance(client, transaction.user_id, depositAmount, 'credit');\n\n    // 2. Atualizar data do √∫ltimo dep√≥sito para controle de car√™ncia anti-fraude (72h)\n    // A coluna last_deposit_at n√£o existe no banco, verifica√ß√£o de seguran√ßa baseada em transactions aprovadas deve ser implementada no futuro.\n    // await client.query('UPDATE users SET last_deposit_at = NOW() WHERE id = $1', [transaction.user_id]);\n\n    // 3. Verifica√ß√£o de Diverg√™ncia de Nome (Anti-Lavagem Interna)\n    const userRes = await client.query('SELECT name FROM users WHERE id = $1', [transaction.user_id]);\n    const userName = userRes.rows[0]?.name;\n    const senderName = metadata.senderName;\n\n    if (senderName && userName) {\n      const normalizedSender = senderName.trim().toLowerCase();\n      const normalizedOwner = userName.trim().toLowerCase();\n\n      // Se o nome for diferente, aplicamos uma trava de gasto de 24h por seguran√ßa\n      if (normalizedSender !== normalizedOwner) {\n        const lockUntil = new Date();\n        lockUntil.setHours(lockUntil.getHours() + 24);\n\n        await client.query('UPDATE users SET security_lock_until = $1 WHERE id = $2', [lockUntil, transaction.user_id]);\n        console.log(`[SECURITY] Diverg√™ncia de nome detectada (${senderName} vs ${userName}). Saldo travado por 24h para o usu√°rio ${transaction.user_id}`);\n\n        await client.query(\n          \"UPDATE transactions SET metadata = metadata || $1::jsonb, description = description || ' [‚ö†Ô∏è NOME DIVERGENTE - TRAVA 24H APLICADA]' WHERE id = $2\",\n          [JSON.stringify({ name_mismatch: true, lock_applied: true }), transaction.id]\n        );\n      }\n    }\n\n    // 4. Adicionar ao saldo real do sistema\n    await client.query(\n      'UPDATE system_config SET system_balance = system_balance + $1',\n      [depositAmount]\n    );\n\n    console.log(`[DEPOSIT_APPROVED] R$ ${depositAmount} creditados ao usu√°rio ${transaction.user_id}`);\n  }\n\n  console.log(`[DEBUG] Finalizando aprova√ß√£o da transa√ß√£o ${id}. Atualizando status...`);\n\n  await client.query(\n    'UPDATE transactions SET status = $1, processed_at = $2, payout_status = $3 WHERE id = $4',\n    ['APPROVED', new Date(), transaction.type === 'WITHDRAWAL' ? 'PENDING_PAYMENT' : 'NONE', id]\n  );\n\n  console.log(`[DEBUG] Status atualizado no banco para APPROVED (ID: ${id})`);\n\n  // Audit Log\n  await logAudit(client, {\n    userId: transaction.user_id,\n    action: 'TRANSACTION_APPROVED',\n    entityType: 'transaction',\n    entityId: id,\n    oldValues: { status: 'PENDING' },\n    newValues: { status: 'APPROVED', type: transaction.type }\n  });\n\n  // Notificar usu√°rio em tempo real\n  notificationService.notifyUser(transaction.user_id, 'Status da Transa√ß√£o', `Sua transa√ß√£o de ${transaction.type} foi APROVADA!`);\n\n  console.log(`[DEBUG] Transa√ß√£o ${id} aprovada com sucesso. Retornando.`);\n  return { success: true, status: 'APPROVED' };\n};\n\n/**\n * Processa a aprova√ß√£o ou rejei√ß√£o de um empr√©stimo (LOAN)\n */\nexport const processLoanApproval = async (client: PoolClient, id: string, action: 'APPROVE' | 'REJECT') => {\n  const loanResult = await client.query(\n    'SELECT * FROM loans WHERE id = $1 AND status = $2 FOR UPDATE',\n    [id, 'PENDING']\n  );\n\n  if (loanResult.rows.length === 0) {\n    throw new Error('Empr√©stimo n√£o encontrado ou j√° processado');\n  }\n\n  const loan = loanResult.rows[0];\n\n  if (action === 'REJECT') {\n    await client.query('UPDATE loans SET status = $1, approved_at = $2 WHERE id = $3', ['REJECTED', new Date(), id]);\n\n    // Audit Log\n    await logAudit(client, {\n      userId: loan.user_id,\n      action: 'LOAN_REJECTED',\n      entityType: 'loan',\n      entityId: id,\n      oldValues: { status: 'PENDING' },\n      newValues: { status: 'REJECTED' }\n    });\n\n    return { success: true, status: 'REJECTED' };\n  }\n\n  // --- RE-VALIDA√á√ÉO DE SEGURAN√áA NA APROVA√á√ÉO ---\n  // Recalcular limite e caixa dispon√≠vel NO MOMENTO da aprova√ß√£o\n  const availableLimit = await calculateUserLoanLimit(client, loan.user_id);\n\n  // Buscar d√≠vidas ativas atuais (caso ele tenha pedido outro empr√©stimo nesse meio tempo)\n  const activeLoansResult = await client.query(\n    `SELECT COALESCE(SUM(amount), 0) as total FROM loans \n     WHERE user_id = $1 AND status IN ('APPROVED', 'PAYMENT_PENDING') AND id != $2`,\n    [loan.user_id, id]\n  );\n  const currentDebt = parseFloat(activeLoansResult.rows[0].total);\n  const realAvailable = availableLimit - currentDebt;\n\n  const metadata = loan.metadata || {};\n  const guarantorId = metadata.guarantorId;\n\n  // Se N√ÉO tiver fiador, respeita o limite individual. \n  // Se TIVER fiador, o limite √© expandido (assumindo que o fiador cobre o risco).\n  if (!guarantorId && parseFloat(loan.amount) > realAvailable) {\n    throw new Error(`Aprova√ß√£o bloqueada: Limite insuficiente no momento (Dispon√≠vel: R$ ${realAvailable.toFixed(2)}).`);\n  }\n\n  // === CORRE√á√ÉO: USAR DADOS PR√â-CALCULADOS DO METADATA ===\n  // metadata j√° foi declarado acima para verifica√ß√£o do fiador\n\n  const netAmount = parseFloat(metadata.disbursedAmount || loan.amount); // Valor l√≠quido a cair na conta\n  const grossAmount = parseFloat(loan.amount);\n  const originationFee = parseFloat(metadata.originationFee || 0);\n\n  // === CORRE√á√ÉO: VERIFICAR LIQUIDEZ REAL DO SISTEMA ===\n  // O dinheiro SAI do caixa real no momento da aprova√ß√£o.\n  const configRes = await client.query('SELECT system_balance, total_tax_reserve, total_operational_reserve, total_owner_profit FROM system_config LIMIT 1 FOR UPDATE');\n  const config = configRes.rows[0];\n\n  const totalReserves = parseFloat(config.total_tax_reserve || '0') +\n    parseFloat(config.total_operational_reserve || '0') +\n    parseFloat(config.total_owner_profit || '0');\n\n  const systemBalance = parseFloat(config.system_balance || '0');\n  const availableLiquidity = systemBalance - totalReserves;\n\n  if (netAmount > availableLiquidity) {\n    throw new Error(`Liquidez insuficiente no sistema. Dispon√≠vel: R$ ${availableLiquidity.toFixed(2)}, Solicitado: R$ ${netAmount.toFixed(2)}`);\n  }\n\n  // === D√âBITO REAL DO CAIXA (O dinheiro SAI agora) ===\n  // O netAmount √© o que o usu√°rio vai receber. A originationFee j√° foi distribu√≠da no requestLoan.\n  // IMPORTANTE: N√ÉO subtrair da investment_reserve, pois a cota ainda \"vale\" esse dinheiro (receb√≠vel).\n  await client.query(\n    'UPDATE system_config SET system_balance = system_balance - $1',\n    [netAmount]\n  );\n\n  // === CAPITALIZA√á√ÉO DO FGC (Fundo de Garantia de Cr√©dito) ===\n  // Creditamos o fundo com a taxa calculada no momento da solicita√ß√£o (salva no metadata)\n  const gfcFee = parseFloat(metadata.gfcFee || '0');\n  if (gfcFee > 0) {\n    await client.query(\n      'UPDATE system_config SET credit_guarantee_fund = COALESCE(credit_guarantee_fund, 0) + $1',\n      [gfcFee]\n    );\n    console.log(`[FGC] Fundo de Garantia de Cr√©dito capitalizado com R$ ${gfcFee.toFixed(2)} para o empr√©stimo ${id}`);\n  }\n\n  // Creditar no saldo do usu√°rio\n  await updateUserBalance(client, loan.user_id, netAmount, 'credit');\n\n  // Audit e Transa√ß√£o\n  await client.query('UPDATE loans SET status = $1, approved_at = $2, payout_status = $3 WHERE id = $4', ['APPROVED', new Date(), 'NONE', id]);\n\n  // === GERA√á√ÉO DO CRONOGRAMA DE PARCELAS ===\n  const loanTotalRepayment = parseFloat(loan.total_repayment);\n  const numInstallments = loan.installments;\n  const standardInstallment = Math.floor((loanTotalRepayment / numInstallments) * 100) / 100;\n  let remainingTotal = loanTotalRepayment;\n\n  for (let i = 1; i <= numInstallments; i++) {\n    const dueDate = new Date();\n    dueDate.setTime(dueDate.getTime() + (i * ONE_MONTH_MS));\n\n    const currentInstallmentAmount = (i === numInstallments)\n      ? Math.round(remainingTotal * 100) / 100\n      : standardInstallment;\n\n    await client.query(\n      `INSERT INTO loan_installments (loan_id, installment_number, amount, expected_amount, due_date, status, created_at)\n       VALUES ($1, $2, $3, $3, $4, 'PENDING', NOW())`,\n      [id, i, currentInstallmentAmount, dueDate]\n    );\n\n    remainingTotal -= currentInstallmentAmount;\n  }\n  console.log(`[LOAN_APPROVED] ${numInstallments} parcelas geradas para o empr√©stimo ${id} (Soma total garantida: R$ ${loanTotalRepayment.toFixed(2)})`);\n\n  await createTransaction(\n    client,\n    loan.user_id,\n    'LOAN_APPROVED',\n    netAmount,\n    `Apoio M√∫tuo Aprovado - Valor L√≠quido Creditado`,\n    'APPROVED',\n    {\n      loanId: id,\n      grossAmount,\n      originationFee,\n      netAmount,\n      totalRepayment: parseFloat(loan.total_repayment),\n      installments: loan.installments,\n      creditedToBalance: true\n    }\n  );\n\n  // Audit Log\n  await logAudit(client, {\n    userId: loan.user_id,\n    action: 'LOAN_APPROVED',\n    entityType: 'loan',\n    entityId: id,\n    oldValues: { status: 'PENDING' },\n    newValues: { status: 'APPROVED', amount: loan.amount }\n  });\n\n  // Notificar usu√°rio\n  notificationService.notifyUser(loan.user_id, 'Empr√©stimo Aprovado', `Seu empr√©stimo de R$ ${parseFloat(loan.amount).toFixed(2)} foi aprovado e creditado!`);\n\n  return { success: true, status: 'APPROVED' };\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5155,5158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5155,5158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5724,5727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5724,5727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'serverInstance' is assigned a value but never used.","line":197,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":197,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7929,7932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7929,7932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8376,8379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8376,8379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8694,8697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8694,8697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import packageJson from '../package.json';\nimport 'dotenv/config';\nimport dns from 'node:dns';\ndns.setDefaultResultOrder('ipv4first');\n\nimport { validateEnv } from './shared/schemas/env.schema';\nimport { validateJwtSecret } from './shared/utils/jwt-validation.utils';\n\n// Validar vari√°veis de ambiente e seguran√ßa JWT antes de qualquer outra coisa\nconsole.log(`--- [INDEX] NODE_ENV: ${process.env.NODE_ENV} ---`);\nvalidateEnv();\nvalidateJwtSecret();\n\n\n// Force restart: Logistics Fee Fix at 2026-01-29 Audit\nimport { serve } from '@hono/node-server';\nimport { Hono, Context } from 'hono';\nimport { cors } from 'hono/cors';\nimport { compress } from 'hono/compress';\nimport { etag } from 'hono/etag';\nimport { logger } from 'hono/logger';\nimport { secureHeaders } from 'hono/secure-headers';\nimport { timing } from 'hono/timing';\n\n/**\n * üöÄ INST√ÇNCIA DO APP\n * Deve ser definida ANTES da importa√ß√£o das rotas para evitar problemas de depend√™ncia circular\n */\nexport const app = new Hono();\n\n// Importa√ß√£o das Rotas\nimport { authRoutes } from './presentation/http/routes/auth.routes';\nimport { userRoutes } from './presentation/http/routes/users.routes';\nimport { quotaRoutes } from './presentation/http/routes/quotas.routes';\nimport { loanRoutes } from './presentation/http/routes/loans.routes';\nimport { transactionRoutes } from './presentation/http/routes/transactions.routes';\nimport { adminRoutes } from './presentation/http/routes/admin.routes';\nimport { withdrawalRoutes } from './presentation/http/routes/withdrawals.routes';\nimport { productsRoutes } from './presentation/http/routes/products.routes';\nimport { webhookRoutes } from './presentation/http/routes/webhooks.routes';\nimport { notificationRoutes } from './presentation/http/routes/notifications.routes';\nimport { marketplaceRoutes } from './presentation/http/routes/marketplace.routes';\nimport { educationRoutes } from './presentation/http/routes/education.routes';\nimport { votingRoutes } from './presentation/http/routes/voting.routes';\nimport { monetizationRoutes } from './presentation/http/routes/monetization.routes';\nimport { promoVideosRoutes } from './presentation/http/routes/promo-videos.routes';\nimport { bugReportsRoutes } from './presentation/http/routes/bug-reports.routes';\nimport { earnRoutes } from './presentation/http/routes/earn.routes';\nimport { sellerRoutes } from './presentation/http/routes/seller.routes';\nimport { tutorRoutes } from './presentation/http/routes/tutors.routes';\nimport { logisticsRoutes } from './presentation/http/routes/logistics.routes';\nimport { consortiumRoutes } from './presentation/http/routes/consortium.routes';\nimport { pdvRoutes } from './presentation/http/routes/pdv.routes';\nimport { kycRoutes } from './presentation/http/routes/kyc.routes';\nimport { termsRoutes } from './presentation/http/routes/terms.routes';\nimport { claimsRoutes } from './presentation/http/routes/claims.routes';\n\n// Infraestrutura\nimport { initializeScheduler } from './scheduler';\nimport { initializeFirebaseAdmin } from './infrastructure/firebase/admin-config';\nimport { initializeDatabase, pool } from './infrastructure/database/postgresql/connection/pool';\n\n// Middlewares Globais\napp.use('*', cors({\n  origin: (origin: string | undefined) => {\n    const allowed = [\n      'https://cred30.site',\n      'https://www.cred30.site',\n      'https://cred30-prod-app-2025.web.app',\n      'https://cred30-prod-app-2025.firebaseapp.com',\n      'http://localhost:3000',\n      'http://localhost:3003',\n      'http://localhost:5173'\n    ];\n    // Em produ√ß√£o, restringimos mais. No desenvolvimento, permitimos localhost.\n    if (!origin) return allowed[0]; // Permite apps mobile/ferramentas de teste\n    if (allowed.includes(origin)) return origin;\n\n    console.warn(`[SECURITY] Origem bloqueada pelo CORS: ${origin}`);\n    return allowed[0]; // Fallback para a primeira origem\n  },\n  credentials: true,\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],\n  allowHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],\n  exposeHeaders: ['Content-Length', 'X-Kuma-Revision'],\n}));\n\napp.use('*', compress());\napp.use('*', etag());\napp.use('*', logger());\napp.use('*', secureHeaders({\n  contentSecurityPolicy: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://www.gstatic.com\", \"https://*.firebaseapp.com\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\n    imgSrc: [\"'self'\", \"data:\", \"https://*\"],\n    fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n    frameSrc: [\"'self'\", \"https://*.firebaseapp.com\"],\n    connectSrc: [\"'self'\", \"https://*.googleapis.com\", \"https://*.firebaseio.com\", \"https://*.adsterra.com\"]\n  },\n  strictTransportSecurity: 'max-age=63072000; includeSubDomains; preload', // HSTS Ativado (2 anos)\n  xXssProtection: '1; mode=block',\n  xContentTypeOptions: 'nosniff',\n  referrerPolicy: 'no-referrer',\n  xFrameOptions: 'DENY' // Impede Clickjacking\n}));\napp.use('*', timing());\n\n// üõ°Ô∏è Rate Limiting Simples (Blindagem contra DoS)\nconst rateLimitMap = new Map<string, { count: number, resetAt: number }>();\napp.use('*', async (c: Context, next: any) => {\n  const ip = c.req.header('x-forwarded-for') || 'local';\n  const now = Date.now();\n  const limit = 100; // 100 requisi√ß√µes\n  const windowMs = 60 * 1000; // 1 minuto\n\n  let record = rateLimitMap.get(ip);\n  if (!record || now > record.resetAt) {\n    record = { count: 0, resetAt: now + windowMs };\n  }\n\n  record.count++;\n  rateLimitMap.set(ip, record);\n\n  if (record.count > limit) {\n    return c.json({ success: false, message: 'Muitas requisi√ß√µes. Tente novamente em 1 minuto.' }, 429);\n  }\n\n  await next();\n});\n\n// üõ°Ô∏è Global Error Handler\napp.onError((err: any, c: Context) => {\n  console.error(`[SERVER ERROR] ${c.req.method} ${c.req.url}:`, err);\n\n  const status = err.status || 500;\n  const message = err.message || 'Erro interno no servidor';\n\n  return c.json({\n    success: false,\n    message,\n    error: process.env.NODE_ENV === 'development' ? err.stack : undefined\n  }, status);\n});\n\n// üöÄ Registro de Rotas (Dispon√≠veis para App e Testes)\napp.route('/api/auth', authRoutes);\napp.route('/api/users', userRoutes);\napp.route('/api/quotas', quotaRoutes);\napp.route('/api/loans', loanRoutes);\napp.route('/api/transactions', transactionRoutes);\napp.route('/api/admin', adminRoutes);\napp.route('/api/withdrawals', withdrawalRoutes);\napp.route('/api/products', productsRoutes);\napp.route('/api/webhooks', webhookRoutes);\napp.route('/api/notifications', notificationRoutes);\napp.route('/api/marketplace', marketplaceRoutes);\napp.route('/api/monetization', monetizationRoutes);\napp.route('/api/education', educationRoutes);\napp.route('/api/voting', votingRoutes);\napp.route('/api/promo-videos', promoVideosRoutes);\napp.route('/api/bugs', bugReportsRoutes);\napp.route('/api/earn', earnRoutes);\napp.route('/api/seller', sellerRoutes);\napp.route('/api/logistics', logisticsRoutes);\napp.route('/api/tutors', tutorRoutes);\napp.route('/api/consortium', consortiumRoutes);\napp.route('/api/pdv', pdvRoutes);\napp.route('/api/terms', termsRoutes);\napp.route('/api/claims', claimsRoutes);\napp.route('/api/kyc', kycRoutes);\n\n// Rotas Base e Health Check\napp.get('/', (c: Context) => c.json({\n  message: 'Cred30 API Online',\n  version: packageJson.version\n}));\n\napp.get('/api/health', (c: Context) => {\n  return c.json({\n    status: 'ok',\n    version: packageJson.version,\n    db: pool ? 'connected' : 'connecting',\n    timestamp: new Date().toISOString()\n  });\n});\n\nasync function startServer() {\n  const port = process.env.PORT || 3001;\n\n  try {\n    console.log('--- [BOOT] Iniciando Cred30 Backend ---');\n    console.log(`--- [BOOT] Node version: ${process.version} ---`);\n    console.log(`--- [BOOT] Porta configurada: ${port} ---`);\n\n    // 1. Inicializar o Servidor HTTP\n    const serverInstance = serve({\n      fetch: app.fetch,\n      port: Number(port),\n    }, (info: any) => {\n      console.log(`üöÄ [SERVER] Servidor rodando em http://localhost:${info.port}`);\n    });\n\n    console.log('--- [BOOT] Servidor HTTP iniciado, procedendo com infraestrutura... ---');\n\n    // 3. Inicializa√ß√£o Pesada (async)\n    // Se isso der erro, o servidor j√° est√° rodando e podemos logar o erro sem sumir\n    console.log('--- [DB] Conectando ao Banco de Dados... ---');\n    try {\n      await initializeDatabase();\n    } catch (err: any) {\n      console.error('--- [DB] Falha ao conectar/migrar Banco de Dados:', err.message);\n    }\n\n    console.log('--- [INFRA] Inicializando Firebase e Scheduler... ---');\n    initializeFirebaseAdmin();\n    initializeScheduler(pool);\n\n    console.log('‚úÖ [BOOT] Sistema totalmente operacional!');\n\n  } catch (error: any) {\n    console.error('‚ùå [FATAL] Erro catastr√≥fico no boot do servidor:', error);\n    // No Render, se falhar, queremos que o processo morra para ele tentar de novo\n    setTimeout(() => process.exit(1), 1000);\n  }\n}\n\napp.notFound((c: Context) => {\n  // Ignorar favicon no log se for barulhento\n  if (c.req.path.includes('favicon')) return c.json({}, 404);\n  console.log(`‚ö†Ô∏è [404] Not Found: ${c.req.method} ${c.req.url}`);\n  return c.json({ success: false, message: 'Rota n√£o encontrada' }, 404);\n});\n\nif (process.env.NODE_ENV !== 'test') {\n  startServer();\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/cache/memory-cache.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[153,156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[153,156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2182,2185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2182,2185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2298,2301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2298,2301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2449,2452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2449,2452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2588,2591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2588,2591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2837,2840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2837,2840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4106,4109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4106,4109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4124,4127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4124,4127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4230,4233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4230,4233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4904,4907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4904,4907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface CacheEntry<T> {\n  data: T;\n  expiresAt: number;\n  createdAt: number;\n}\n\nclass SimpleMemoryCache {\n  private cache = new Map<string, CacheEntry<any>>();\n  private defaultTTL = 5 * 60 * 1000; // 5 minutos em milissegundos\n\n  set<T>(key: string, data: T, ttlMs?: number): void {\n    const expiresAt = Date.now() + (ttlMs || this.defaultTTL);\n    this.cache.set(key, {\n      data,\n      expiresAt,\n      createdAt: Date.now()\n    });\n  }\n\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.data;\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  // Limpa entradas expiradas\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now > entry.expiresAt) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  // Retorna estat√≠sticas do cache\n  getStats(): {\n    size: number;\n    hitRate?: number;\n    memoryUsage: number;\n  } {\n    return {\n      size: this.cache.size,\n      memoryUsage: this.estimateMemoryUsage()\n    };\n  }\n\n  private estimateMemoryUsage(): number {\n    let totalSize = 0;\n    for (const [key, entry] of this.cache.entries()) {\n      totalSize += key.length * 2; // Estimativa de string\n      totalSize += JSON.stringify(entry.data).length * 2; // Estimativa de dados\n      totalSize += 64; // Overhead do objeto\n    }\n    return totalSize;\n  }\n}\n\n// Inst√¢ncia global do cache\nconst cache = new SimpleMemoryCache();\n\n// Limpar cache expirado a cada minuto\nsetInterval(() => {\n  cache.cleanup();\n}, 60 * 1000);\n\nexport class CacheService {\n  static set<T>(key: string, data: T, ttlMs?: number): void {\n    cache.set(key, data, ttlMs);\n  }\n\n  static get<T>(key: string): T | null {\n    return cache.get<T>(key);\n  }\n\n  static delete(key: string): boolean {\n    return cache.delete(key);\n  }\n\n  static clear(): void {\n    cache.clear();\n  }\n\n  // Cache para configura√ß√µes do sistema (TTL mais longo)\n  static setSystemConfig(config: any): void {\n    cache.set('system_config', config, 30 * 60 * 1000); // 30 minutos\n  }\n\n  static getSystemConfig(): any | null {\n    return cache.get('system_config');\n  }\n\n  // Cache para dados de usu√°rio (TTL m√©dio)\n  static setUserProfile(userId: number, profile: any): void {\n    cache.set(`user_profile_${userId}`, profile, 10 * 60 * 1000); // 10 minutos\n  }\n\n  static getUserProfile(userId: number): any | null {\n    return cache.get(`user_profile_${userId}`);\n  }\n\n  static invalidateUser(userId: number): void {\n    cache.delete(`user_profile_${userId}`);\n  }\n\n  // Cache para dashboard administrativo (TTL curto)\n  static setAdminDashboard(data: any): void {\n    cache.set('admin_dashboard', data, 2 * 60 * 1000); // 2 minutos\n  }\n\n  static getAdminDashboard(): any | null {\n    return cache.get('admin_dashboard');\n  }\n\n  static invalidateAdminDashboard(): void {\n    cache.delete('admin_dashboard');\n  }\n\n  // Cache para contagens (TTL muito curto)\n  static setCounts(key: string, count: number): void {\n    cache.set(`count_${key}`, count, 30 * 1000); // 30 segundos\n  }\n\n  static getCounts(key: string): number | null {\n    return cache.get(`count_${key}`);\n  }\n\n  static invalidateCounts(key: string): void {\n    cache.delete(`count_${key}`);\n  }\n\n  // Utilit√°rios para invalida√ß√£o em lote\n  static invalidateUserRelated(userId: number): void {\n    cache.delete(`user_profile_${userId}`);\n    cache.delete(`user_quotas_${userId}`);\n    cache.delete(`user_loans_${userId}`);\n    cache.delete(`user_transactions_${userId}`);\n  }\n\n  static invalidateAdminRelated(): void {\n    cache.delete('admin_dashboard');\n    cache.delete('system_config');\n    cache.delete('count_users');\n    cache.delete('count_quotas');\n    cache.delete('count_loans');\n  }\n\n  // Estat√≠sticas do cache\n  static getStats() {\n    return cache.getStats();\n  }\n}\n\n// Decorator para cache de fun√ß√µes\nexport function cached<T extends (...args: any[]) => Promise<any>>(\n  keyGenerator: (...args: Parameters<T>) => string,\n  ttlMs?: number\n) {\n  return function(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value;\n\n    descriptor.value = async function(...args: Parameters<T>) {\n      const key = keyGenerator(...args);\n      \n      // Tentar obter do cache\n      const cached = CacheService.get(key);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Executar m√©todo original\n      const result = await method.apply(this, args);\n      \n      // Armazenar no cache\n      CacheService.set(key, result, ttlMs);\n      \n      return result;\n    };\n\n    return descriptor;\n  };\n}\n\n// Middleware para adicionar headers de cache √†s respostas\nexport function addCacheHeaders(c: any, hit: boolean, ttl?: number): void {\n  c.header('X-Cache', hit ? 'HIT' : 'MISS');\n  if (ttl) {\n    c.header('X-Cache-TTL', ttl.toString());\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/database/postgresql/connection/pool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[434,437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[434,437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'client' is defined but never used. Allowed unused args must match /^_/u.","line":34,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2069,2072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2069,2072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2356,2359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2356,2359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2372,2375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2372,2375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2527,2530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2527,2530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dbPool' is assigned a value but never used.","line":75,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3046,3049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3046,3049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3282,3285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3282,3285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3532,3535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3532,3535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3543,3546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3543,3546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3556,3559],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3556,3559],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":96,"column":3,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":105,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3666,3669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3666,3669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3674,3677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3674,3677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3920,3923],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3920,3923],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool } from 'pg';\n// Importa√ß√µes comentadas para evitar depend√™ncia circular\n// import { initializeAuditTable } from '../../../logging/audit.middleware';\n// import { initializeRateLimitTable } from '../../../presentation/http/middleware/rate-limit.middleware';\n// import { createIndexes } from '../../../../utils/indexes';\n\n// Configura√ß√£o do pool de conex√µes PostgreSQL balanceada para performance e custo\nconst poolConfig: any = {\n  max: 15, // M√°ximo de conex√µes simult√¢neas (ideal para inst√¢ncias Neon/Supabase free/base)\n  min: 2,  // Manter pelo menos 2 conex√µes abertas para warm start\n  idleTimeoutMillis: 30000,      // Tempo para fechar conex√µes ociosas\n  connectionTimeoutMillis: 5000,  // Timeout para tentar conectar\n  maxUses: 7500, // Prevenir memory leaks do driver pg reciclagem peri√≥dica\n  keepAlive: true, // <-- IMPORTANTE: Mant√©m conex√£o ativa com Neon\n  keepAliveInitialDelayMillis: 10000, // Ping a cada 10 segundos\n};\n\nif (process.env.DATABASE_URL) {\n  poolConfig.connectionString = process.env.DATABASE_URL;\n  poolConfig.ssl = { rejectUnauthorized: false };\n} else {\n  // Configura√ß√£o local de fallback\n  poolConfig.host = process.env.DB_HOST || 'localhost';\n  poolConfig.port = parseInt(process.env.DB_PORT || '5432');\n  poolConfig.user = process.env.DB_USER || 'admin';\n  poolConfig.password = process.env.DB_PASSWORD || 'password';\n  poolConfig.database = process.env.DB_DATABASE || 'cred30_local';\n}\n\n// Criar o pool de conex√µes\nexport const pool = new Pool(poolConfig);\n\n// üõ°Ô∏è BLINDAGEM: Handler de erro para evitar crash do servidor\npool.on('error', (err, client) => {\n  console.error('[POOL ERROR] Conex√£o perdida com o banco de dados:', err.message);\n  // N√£o faz nada aqui, o pg-pool reconecta automaticamente\n});\n\npool.on('connect', () => {\n  console.log('[POOL] Nova conex√£o estabelecida com o banco');\n});\n\n/**\n * Helper para queries SQL usando Tagged Template Literals.\n * Permite escrever sql`SELECT * FROM users WHERE id = ${id}` de forma segura.\n */\nexport const sql = async (strings: TemplateStringsArray, ...values: any[]) => {\n  const text = strings.reduce((acc, str, i) => acc + str + (i < values.length ? `$${i + 1}` : ''), '');\n  const result = await pool.query(text, values);\n  return result.rows;\n};\n\n// Adicionar m√©todo 'begin' para transa√ß√µes simples no helper\nsql.begin = async (callback: (tx: any) => Promise<any>) => {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    const tx = async (strings: TemplateStringsArray, ...values: any[]) => {\n      const text = strings.reduce((acc, str, i) => acc + str + (i < values.length ? `$${i + 1}` : ''), '');\n      const res = await client.query(text, values);\n      return res.rows;\n    };\n    const result = await callback(tx);\n    await client.query('COMMIT');\n    return result;\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n};\n\n// Vari√°vel global para armazenar o pool de conex√µes\nlet dbPool: Pool | null = null;\n\nexport const getDbPool = (c?: any): Pool => {\n  // Se o pool j√° foi injetado no contexto pelo Hono, use-o\n  if (c && c.get && c.get('dbPool')) {\n    return c.get('dbPool');\n  }\n\n  // Usar global para garantir singleton em ambiente de teste/vitest\n  const globalAny: any = globalThis;\n  if (!globalAny.__DB_POOL__) {\n    globalAny.__DB_POOL__ = pool;\n  }\n\n  return globalAny.__DB_POOL__;\n};\n\n// Monitoramento de performance e log de queries lentas\nconst originalQuery = pool.query;\npool.query = async function (this: any, text: any, params: any) {\n  const start = Date.now();\n  try {\n    const res = await (originalQuery.apply(this, [text, params] as any) as any);\n    const duration = Date.now() - start;\n    if (duration > 1000) {\n      console.warn(`[SLOW DATABASE QUERY] ${duration}ms - ${typeof text === 'string' ? text : text.text}`);\n    }\n    return res;\n  } catch (err) {\n    throw err;\n  }\n} as any;\n\nexport const setDbPool = (pool: Pool) => {\n  dbPool = pool;\n};\n\n// Fun√ß√£o para gerar IDs √∫nicos (UUID via PostgreSQL)\nexport const generateId = () => {\n  // Gera um UUID v4 formatado como string\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n};\n\n// Fun√ß√£o para gerar c√≥digo de indica√ß√£o\nexport const generateReferralCode = () => Math.random().toString(36).substring(2, 8).toUpperCase();\n\n// Fun√ß√£o para inicializar o banco de dados (criar tabelas se n√£o existirem)\nexport const initializeDatabase = async () => {\n  const client = await pool.connect();\n  try {\n    console.log('Conectado ao PostgreSQL com sucesso!');\n\n    // Criar extens√£o UUID se n√£o existir\n    await client.query('CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"');\n\n    // Verificar se a tabela users existe e recriar se necess√°rio (mudan√ßa de schema password -> password_hash)\n    const tableExists = await client.query(`\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables\n        WHERE table_schema = 'public'\n        AND table_name = 'users'\n      );\n    `);\n\n    if (tableExists.rows[0].exists) {\n      // Verificar se tem a coluna password (schema antigo)\n      const oldColumnExists = await client.query(`\n        SELECT column_name FROM information_schema.columns\n        WHERE table_schema = 'public'\n        AND table_name = 'users'\n        AND column_name = 'password'\n      `);\n\n      if (oldColumnExists.rows.length > 0) {\n        console.log('Detectado schema antigo (coluna password). Recriando tabela users...');\n        // Drop cascade para remover refer√™ncias de outras tabelas\n        await client.query('DROP TABLE users CASCADE');\n        // Tamb√©m dropar tabelas dependentes que podem ter ficado inconsistentes\n        await client.query('DROP TABLE IF EXISTS quotas CASCADE');\n        await client.query('DROP TABLE IF EXISTS loans CASCADE');\n        await client.query('DROP TABLE IF EXISTS transactions CASCADE');\n      } else {\n        // Se a tabela existe, verificar se tem as colunas necess√°rias\n        // Verificar individualmente as colunas cr√≠ticas e adicionar se faltarem (mais seguro que DROP TABLE)\n        const scoreColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'score'\n        `);\n\n        if (scoreColumn.rows.length === 0) {\n          console.log('Adicionando coluna score √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN score INTEGER DEFAULT 0');\n        }\n\n        const verifiedColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'is_email_verified'\n        `);\n\n        if (verifiedColumn.rows.length === 0) {\n          console.log('Adicionando colunas de verifica√ß√£o de email...');\n          await client.query('ALTER TABLE users ADD COLUMN is_email_verified BOOLEAN DEFAULT FALSE');\n          await client.query('ALTER TABLE users ADD COLUMN verification_code VARCHAR(10)');\n          await client.query('ALTER TABLE users ADD COLUMN reset_password_token VARCHAR(255)');\n        }\n\n        const tfaColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'two_factor_secret'\n        `);\n\n        if (tfaColumn.rows.length === 0) {\n          console.log('Adicionando colunas de 2FA √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN two_factor_secret TEXT');\n          await client.query('ALTER TABLE users ADD COLUMN two_factor_enabled BOOLEAN DEFAULT FALSE');\n        }\n\n        const termsColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'accepted_terms_at'\n        `);\n\n        if (termsColumn.rows.length === 0) {\n          console.log('Adicionando coluna accepted_terms_at √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN accepted_terms_at TIMESTAMP');\n        }\n\n        const titleColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'title_downloaded'\n        `);\n\n        if (titleColumn.rows.length === 0) {\n          console.log('Adicionando colunas de t√≠tulo √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN title_downloaded BOOLEAN DEFAULT FALSE');\n          await client.query('ALTER TABLE users ADD COLUMN title_downloaded_at TIMESTAMP');\n        }\n\n        const roleColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'role'\n        `);\n\n        if (roleColumn.rows.length === 0) {\n          console.log('Adicionando coluna role e status √† tabela users...');\n          await client.query(\"ALTER TABLE users ADD COLUMN role VARCHAR(20) DEFAULT 'MEMBER'\");\n          await client.query(\"ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'ACTIVE'\");\n        }\n\n        const checkinColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'last_checkin_at'\n        `);\n\n        if (checkinColumn.rows.length === 0) {\n          console.log('Adicionando coluna last_checkin_at √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN last_checkin_at TIMESTAMP');\n        }\n\n        const cpfColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'cpf'\n        `);\n\n        if (cpfColumn.rows.length === 0) {\n          console.log('Adicionando coluna cpf √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN cpf VARCHAR(14)');\n        }\n\n        const lastIpColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'last_ip'\n        `);\n\n        if (lastIpColumn.rows.length === 0) {\n          console.log('Adicionando coluna last_ip √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN last_ip VARCHAR(45)');\n        }\n\n        const lastLoginColumn = await client.query(`\n          SELECT column_name FROM information_schema.columns\n          WHERE table_schema = 'public' AND table_name = 'users' AND column_name = 'last_login_at'\n        `);\n\n        if (lastLoginColumn.rows.length === 0) {\n          console.log('Adicionando coluna last_login_at √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN last_login_at TIMESTAMP');\n        }\n\n        const videoRewardColumn = await client.query(`\n          SELECT 1 FROM information_schema.columns \n          WHERE table_name = 'users' AND column_name = 'last_video_reward_at'\n        `);\n        if (videoRewardColumn.rows.length === 0) {\n          console.log('Adicionando coluna last_video_reward_at √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN last_video_reward_at TIMESTAMP');\n        }\n\n        const pendingBalanceColumn = await client.query(`\n          SELECT 1 FROM information_schema.columns \n          WHERE table_name = 'users' AND column_name = 'pending_balance'\n        `);\n        if (pendingBalanceColumn.rows.length === 0) {\n          console.log('Adicionando coluna pending_balance √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN pending_balance DECIMAL(10,2) DEFAULT 0');\n        }\n\n        const avatarUrlColumn = await client.query(`\n          SELECT 1 FROM information_schema.columns \n          WHERE table_name = 'users' AND column_name = 'avatar_url'\n        `);\n        if (avatarUrlColumn.rows.length === 0) {\n          console.log('Adicionando coluna avatar_url √† tabela users...');\n          await client.query('ALTER TABLE users ADD COLUMN avatar_url TEXT');\n        }\n\n        console.log('Tabela users verificada e atualizada com sucesso');\n      }\n    }\n\n    // Criar tabela de usu√°rios (usando SERIAL para auto-incremento)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        email VARCHAR(255) UNIQUE NOT NULL,\n        password_hash VARCHAR(255) NOT NULL,\n        secret_phrase VARCHAR(255),\n        pix_key VARCHAR(255),\n        balance DECIMAL(10,2) DEFAULT 0,\n        pending_balance DECIMAL(10,2) DEFAULT 0,\n        avatar_url TEXT,\n        referral_code VARCHAR(10) UNIQUE,\n        referred_by VARCHAR(10),\n        is_admin BOOLEAN DEFAULT FALSE,\n        score INTEGER DEFAULT 0,\n        is_email_verified BOOLEAN DEFAULT FALSE,\n        verification_code VARCHAR(10),\n        reset_password_token VARCHAR(255),\n        two_factor_secret TEXT,\n        two_factor_enabled BOOLEAN DEFAULT FALSE,\n        accepted_terms_at TIMESTAMP,\n        title_downloaded BOOLEAN DEFAULT FALSE,\n        title_downloaded_at TIMESTAMP,\n        role VARCHAR(20) DEFAULT 'MEMBER',\n        status VARCHAR(20) DEFAULT 'ACTIVE',\n        address TEXT,\n        phone VARCHAR(20),\n        is_seller BOOLEAN DEFAULT FALSE,\n        seller_status VARCHAR(20) DEFAULT 'none',\n        asaas_account_id VARCHAR(255),\n        asaas_wallet_id VARCHAR(255),\n        seller_company_name VARCHAR(255),\n        seller_cpf_cnpj VARCHAR(255),\n        seller_phone VARCHAR(255),\n        seller_address_street VARCHAR(255),\n        seller_address_number VARCHAR(255),\n        seller_address_neighborhood VARCHAR(255),\n        seller_address_city VARCHAR(255),\n        seller_address_state VARCHAR(255),\n        seller_address_postal_code VARCHAR(255),\n        seller_created_at TIMESTAMP,\n        last_ip VARCHAR(45),\n        last_login_at TIMESTAMP,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n\n    // Garantir que todas as colunas de vendedor existam na tabela users\n    await client.query(`\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_seller BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_status VARCHAR(20) DEFAULT 'none';\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS asaas_account_id VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS asaas_wallet_id VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_company_name VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_cpf_cnpj VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_phone VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_street VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_number VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_neighborhood VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_city VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_state VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_postal_code VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_address_cep VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_created_at TIMESTAMP;\n      \n      -- Garantir que colunas cr√≠ticas aceitem NULL para Google Auth\n      ALTER TABLE users ALTER COLUMN secret_phrase DROP NOT NULL;\n      ALTER TABLE users ALTER COLUMN pix_key DROP NOT NULL;\n      \n      -- Coluna de timestamp de atualiza√ß√£o\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n      \n      -- DELIVERY PREMIUM: Pausa manual da loja\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_paused BOOLEAN DEFAULT FALSE;\n\n      -- LOG√çSTICA & ENTREGADORES\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_courier BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_status VARCHAR(20) DEFAULT 'none';\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_vehicle VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_phone VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_cpf VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_city VARCHAR(100);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_state VARCHAR(50);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_price_per_km DECIMAL(10,2) DEFAULT 2.00;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_id_photo TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_vehicle_photo TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_doc_photo TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_created_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_penalty_until TIMESTAMP;\n\n      -- KYC & PERFIL\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS membership_type VARCHAR(20) DEFAULT 'FREE';\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_status VARCHAR(20) DEFAULT 'NONE';\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_document_path TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_notes TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS safe_contact_phone VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_protected BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS protection_expires_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS panic_phrase VARCHAR(255);\n\n      -- FINAN√áAS & RECOMPENSAS\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS total_dividends_earned DECIMAL(15,2) DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS security_lock_until TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS ad_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS pending_ad_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS total_ad_points INTEGER DEFAULT 0;\n    `);\n\n    // Verificar o tipo da coluna id da tabela users para garantir integridade das chaves estrangeiras\n    const userIdTypeResult = await client.query(`\n      SELECT data_type \n      FROM information_schema.columns \n      WHERE table_name = 'users' AND column_name = 'id'\n    `);\n\n    let userIdType = 'INTEGER'; // Default para SERIAL\n    if (userIdTypeResult.rows.length > 0) {\n      const type = userIdTypeResult.rows[0].data_type;\n      console.log(`Tipo de dado detectado para users.id: ${type}`);\n      if (type === 'uuid') {\n        userIdType = 'UUID';\n      }\n    }\n\n    // Criar tabela de cotas (usando SERIAL para consist√™ncia)\n    // Atualizado: Removida coluna quantity, unit_price e total_amount pois agora √© 1 linha por cota\n    // Atualizado: Usa o tipo correto para user_id (UUID ou INTEGER)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS quotas (\n        id SERIAL PRIMARY KEY,\n        user_id ${userIdType} REFERENCES users(id),\n        purchase_price DECIMAL(10,2) NOT NULL,\n        current_value DECIMAL(10,2) NOT NULL,\n        purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        status VARCHAR(20) DEFAULT 'ACTIVE',\n        yield_rate DECIMAL(5,2) DEFAULT 0.5\n      );\n    `);\n\n    // Garantir colunas novas na tabela quotas\n    await client.query(`\n      ALTER TABLE quotas ADD COLUMN IF NOT EXISTS yield_rate DECIMAL(5,2) DEFAULT 0.5;\n    `);\n\n    // Verificar se a tabela quotas tem a estrutura antiga\n    const quotasTableInfo = await client.query(`\n      SELECT column_name \n      FROM information_schema.columns \n      WHERE table_name = 'quotas' AND column_name = 'quantity'\n    `);\n\n    if (quotasTableInfo.rows.length > 0) {\n      console.log('Detectado schema antigo na tabela quotas (com coluna quantity). Recriando tabela...');\n      await client.query('DROP TABLE quotas CASCADE');\n      await client.query(`\n        CREATE TABLE IF NOT EXISTS quotas (\n          id SERIAL PRIMARY KEY,\n          user_id ${userIdType} REFERENCES users(id),\n          purchase_price DECIMAL(10,2) NOT NULL,\n          current_value DECIMAL(10,2) NOT NULL,\n          purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n          status VARCHAR(20) DEFAULT 'ACTIVE'\n        );\n      `);\n      console.log('Tabela quotas recriada com novo schema.');\n    }\n\n    // Verificar se a tabela loans existe\n    const loansTableExists = await client.query(`\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables\n        WHERE table_schema = 'public'\n        AND table_name = 'loans'\n      );\n    `);\n\n    if (loansTableExists.rows[0].exists) {\n      // Verificar se a coluna installments existe na tabela loans\n      const installmentsColumnExists = await client.query(`\n        SELECT EXISTS (\n          SELECT FROM information_schema.columns\n          WHERE table_schema = 'public'\n          AND table_name = 'loans'\n          AND column_name = 'installments'\n        );\n      `);\n\n      // Se a coluna installments n√£o existir, adicion√°-la\n      if (!installmentsColumnExists.rows[0].exists) {\n        await client.query('ALTER TABLE loans ADD COLUMN installments INTEGER DEFAULT 1');\n        console.log('Coluna installments adicionada √† tabela loans');\n      }\n\n      // Verificar se a coluna pix_key_to_receive existe na tabela loans\n      const pixKeyColumnExists = await client.query(`\n        SELECT EXISTS (\n          SELECT 1\n          FROM information_schema.columns\n          WHERE table_schema = 'public'\n          AND table_name = 'loans'\n          AND column_name = 'pix_key_to_receive'\n        );\n      `);\n\n      if (!pixKeyColumnExists.rows[0].exists) {\n        await client.query('ALTER TABLE loans ADD COLUMN pix_key_to_receive VARCHAR(255)');\n        console.log('Coluna pix_key_to_receive adicionada √† tabela loans');\n      }\n\n      // Verificar se a coluna penalty_rate existe na tabela loans\n      const penaltyRateColumnExists = await client.query(`\n        SELECT EXISTS (\n          SELECT 1\n          FROM information_schema.columns\n          WHERE table_schema = 'public'\n          AND table_name = 'loans'\n          AND column_name = 'penalty_rate'\n        );\n      `);\n\n      if (!penaltyRateColumnExists.rows[0].exists) {\n        // Adicionar penalty_rate como nullable inicialmente para evitar erro, depois update com default\n        await client.query('ALTER TABLE loans ADD COLUMN penalty_rate DECIMAL(5,2) DEFAULT 0.4');\n        console.log('Coluna penalty_rate adicionada √† tabela loans');\n      }\n\n      // Verificar se a coluna term_days existe na tabela loans\n      const termDaysColumnExists = await client.query(`\n        SELECT EXISTS (\n          SELECT 1\n          FROM information_schema.columns\n          WHERE table_schema = 'public'\n          AND table_name = 'loans'\n          AND column_name = 'term_days'\n        );\n      `);\n\n      if (!termDaysColumnExists.rows[0].exists) {\n        await client.query('ALTER TABLE loans ADD COLUMN term_days INTEGER DEFAULT 30');\n        console.log('Coluna term_days adicionada √† tabela loans');\n      }\n    }\n\n    // Criar tabela de empr√©stimos (usando SERIAL para consist√™ncia)\n    // Atualizado para incluir todas as colunas\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS loans (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        amount DECIMAL(10,2) NOT NULL,\n        interest_rate DECIMAL(5,2) NOT NULL,\n        penalty_rate DECIMAL(5,2) DEFAULT 0.4,\n        total_repayment DECIMAL(10,2) NOT NULL,\n        installments INTEGER DEFAULT 1,\n        term_days INTEGER DEFAULT 30,\n        status VARCHAR(20) DEFAULT 'PENDING',\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        approved_at TIMESTAMP,\n        due_date TIMESTAMP,\n        payout_status VARCHAR(20) DEFAULT 'NONE',\n        pix_key_to_receive VARCHAR(255)\n      );\n    `);\n\n    // Garantir que as colunas novas existam em bancos j√° criados\n    await client.query(`\n      ALTER TABLE loans ADD COLUMN IF NOT EXISTS payout_status VARCHAR(20) DEFAULT 'NONE';\n      ALTER TABLE loans ADD COLUMN IF NOT EXISTS metadata JSONB;\n    `);\n\n    // Verificar se a tabela loan_installments existe\n    const loanInstallmentsTableExists = await client.query(`\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables\n        WHERE table_schema = 'public'\n        AND table_name = 'loan_installments'\n      );\n    `);\n\n    if (!loanInstallmentsTableExists.rows[0].exists) {\n      // Criar tabela de parcelas de empr√©stimos (usando SERIAL para consist√™ncia)\n      await client.query(`\n        CREATE TABLE loan_installments (\n          id SERIAL PRIMARY KEY,\n          loan_id INTEGER REFERENCES loans(id) ON DELETE CASCADE,\n          installment_number INTEGER,\n          amount DECIMAL(10,2),\n          expected_amount DECIMAL(10,2),\n          due_date TIMESTAMP,\n          status VARCHAR(20) DEFAULT 'PENDING',\n          paid_at TIMESTAMP,\n          use_balance BOOLEAN DEFAULT FALSE,\n          metadata JSONB,\n          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        );\n      `);\n      console.log('Tabela loan_installments criada com sucesso!');\n    } else {\n      // Garantir que todas as colunas existam em bancos j√° criados\n      await client.query(`\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS installment_number INTEGER;\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS expected_amount DECIMAL(10,2);\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS due_date TIMESTAMP;\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'PENDING';\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS paid_at TIMESTAMP;\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS use_balance BOOLEAN DEFAULT FALSE;\n        ALTER TABLE loan_installments ADD COLUMN IF NOT EXISTS metadata JSONB;\n      `);\n      console.log('Colunas da tabela loan_installments verificadas/atualizadas');\n    }\n\n    // Verificar se a tabela transactions existe\n    const transactionsTableExists = await client.query(`\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables\n        WHERE table_schema = 'public'\n        AND table_name = 'transactions'\n      );\n    `);\n\n    if (transactionsTableExists.rows[0].exists) {\n      // Verificar se a coluna metadata existe na tabela transactions\n      const metadataColumnExists = await client.query(`\n        SELECT EXISTS (\n          SELECT FROM information_schema.columns\n          WHERE table_schema = 'public'\n          AND table_name = 'transactions'\n          AND column_name = 'metadata'\n        );\n      `);\n\n      // Se a coluna metadata n√£o existir, adicion√°-la\n      if (!metadataColumnExists.rows[0].exists) {\n        await client.query('ALTER TABLE transactions ADD COLUMN metadata JSONB');\n        console.log('Coluna metadata adicionada √† tabela transactions');\n      }\n    }\n\n    // Criar tabela de transa√ß√µes (usando SERIAL para consist√™ncia)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS transactions (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        type VARCHAR(20) NOT NULL,\n        amount DECIMAL(10,2) NOT NULL,\n        gateway_cost DECIMAL(10,2) DEFAULT 0,\n        description TEXT,\n        status VARCHAR(20) DEFAULT 'PENDING',\n        metadata JSONB,\n        payout_status VARCHAR(20) DEFAULT 'NONE',\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        processed_at TIMESTAMP\n      );\n    `);\n\n    // Garantir que as colunas novas existam em bancos j√° criados\n    await client.query(`\n      ALTER TABLE transactions ADD COLUMN IF NOT EXISTS payout_status VARCHAR(20) DEFAULT 'NONE';\n    `);\n\n    // Verificar se a coluna gateway_cost existe na tabela transactions\n    const gatewayCostColumnExists = await client.query(`\n      SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_name = 'transactions' AND column_name = 'gateway_cost'\n      );\n    `);\n\n    if (!gatewayCostColumnExists.rows[0].exists) {\n      await client.query('ALTER TABLE transactions ADD COLUMN gateway_cost DECIMAL(10,2) DEFAULT 0');\n      console.log('Coluna gateway_cost adicionada √† tabela transactions');\n    }\n\n    // Criar tabela de configura√ß√£o do sistema\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS system_config (\n        id SERIAL PRIMARY KEY,\n        system_balance DECIMAL(20,2) DEFAULT 0,\n        profit_pool DECIMAL(20,2) DEFAULT 0,\n        investment_reserve DECIMAL(20,2) DEFAULT 0,\n        total_gateway_costs DECIMAL(20,2) DEFAULT 0,\n        total_tax_reserve DECIMAL(20,2) DEFAULT 0,\n        total_operational_reserve DECIMAL(20,2) DEFAULT 0,\n        total_owner_profit DECIMAL(20,2) DEFAULT 0,\n        quota_price DECIMAL(10,2) DEFAULT 100,\n        loan_interest_rate DECIMAL(5,2) DEFAULT 0.2,\n        penalty_rate DECIMAL(5,2) DEFAULT 0.4,\n        vesting_period_ms BIGINT DEFAULT 31536000000,\n        total_manual_costs DECIMAL(20,2) DEFAULT 0,\n        courier_price_per_km DECIMAL(10,2) DEFAULT 2.50,\n        total_corporate_investment_reserve DECIMAL(20,2) DEFAULT 0,\n        credit_guarantee_fund DECIMAL(20,2) DEFAULT 0,\n        mutual_reserve DECIMAL(20,2) DEFAULT 0,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n\n    // Garantir que as colunas novas existam em bancos j√° criados\n    await client.query(`\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS total_tax_reserve DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS total_operational_reserve DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS total_owner_profit DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS investment_reserve DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS courier_price_per_km DECIMAL(10,2) DEFAULT 2.50;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS mutual_protection_fund DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS mutual_reserve DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS total_corporate_investment_reserve DECIMAL(20,2) DEFAULT 0;\n      ALTER TABLE system_config ADD COLUMN IF NOT EXISTS credit_guarantee_fund DECIMAL(20,2) DEFAULT 0;\n    `);\n\n    // Migra√ß√£o de saldo (separada para garantir que as colunas existam)\n    await client.query(`\n      UPDATE system_config SET \n        mutual_reserve = mutual_reserve + mutual_protection_fund,\n        mutual_protection_fund = 0\n      WHERE mutual_protection_fund > 0;\n    `);\n\n    // Verificar se a coluna total_gateway_costs existe na tabela system_config\n    const totalGatewayCostsColumnExists = await client.query(`\n      SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_name = 'system_config' AND column_name = 'total_gateway_costs'\n      );\n    `);\n\n    console.log('--- [DB] Initializing Core Tables ---');\n    // Criar tabela de c√≥digos de indica√ß√£o (Sistema Admin)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS referral_codes (\n        id SERIAL PRIMARY KEY,\n        code VARCHAR(20) UNIQUE NOT NULL,\n        created_by ${userIdType} REFERENCES users(id),\n        max_uses INTEGER,\n        current_uses INTEGER DEFAULT 0,\n        is_active BOOLEAN DEFAULT TRUE,\n        is_verified BOOLEAN DEFAULT FALSE,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n\n    // Garantir coluna is_verified para bancos existentes\n    await client.query('ALTER TABLE users ADD COLUMN IF NOT EXISTS is_verified BOOLEAN DEFAULT FALSE');\n\n    if (!totalGatewayCostsColumnExists.rows[0].exists) {\n      await client.query('ALTER TABLE system_config ADD COLUMN total_gateway_costs DECIMAL(15,2) DEFAULT 0');\n      console.log('Coluna total_gateway_costs adicionada √† tabela system_config');\n    }\n\n    // Verificar se a coluna total_manual_costs existe na tabela system_config\n    const totalManualCostsColumnExists = await client.query(`\n      SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_name = 'system_config' AND column_name = 'total_manual_costs'\n      );\n    `);\n\n    if (!totalManualCostsColumnExists.rows[0].exists) {\n      await client.query('ALTER TABLE system_config ADD COLUMN total_manual_costs DECIMAL(15,2) DEFAULT 0');\n      console.log('Coluna total_manual_costs adicionada √† tabela system_config');\n    }\n\n    // Verificar se a coluna updated_at existe na tabela system_config\n    const updatedAtColumnExists = await client.query(`\n      SELECT EXISTS (\n        SELECT FROM information_schema.columns\n        WHERE table_schema = 'public'\n        AND table_name = 'system_config'\n        AND column_name = 'updated_at'\n      );\n    `);\n\n    // Se a coluna updated_at n√£o existir, adicion√°-la\n    if (!updatedAtColumnExists.rows[0].exists) {\n      await client.query('ALTER TABLE system_config ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP');\n      console.log('Coluna updated_at adicionada √† tabela system_config');\n    }\n\n    // Criar tabela de auditoria (audit_logs - Fintech Compliance) - Unificada abaixo no bloco de auditoria\n\n    // Criar tabela de auditoria administrativa (admin_logs)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS admin_logs (\n        id SERIAL PRIMARY KEY,\n        admin_id INTEGER REFERENCES users(id),\n        action VARCHAR(50) NOT NULL,\n        entity_type VARCHAR(20) NOT NULL,\n        entity_id VARCHAR(50),\n        old_values JSONB,\n        new_values JSONB,\n        ip_address TEXT,\n        user_agent TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Criar tabela de rate limiting (rate_limit_logs)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS rate_limit_logs (\n        id SERIAL PRIMARY KEY,\n        identifier VARCHAR(100) NOT NULL,\n        user_id INTEGER REFERENCES users(id),\n        count INTEGER NOT NULL,\n        ip_address TEXT,\n        user_agent TEXT,\n        endpoint VARCHAR(200),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Criar tabela de produtos (Loja de Afiliados - Deprecated em favor do Marketplace P2P)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS products (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        title VARCHAR(255) NOT NULL,\n        description TEXT,\n        image_url TEXT,\n        affiliate_url TEXT NOT NULL,\n        price DECIMAL(10, 2),\n        category VARCHAR(50) DEFAULT 'geral',\n        active BOOLEAN DEFAULT true,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // --- NOVO MERCADO CRED30 (P2P MARKETPLACE) ---\n\n    // Tabela de An√∫ncios (OLX STYLE) com suporte a impulsionamento\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS marketplace_listings (\n        id SERIAL PRIMARY KEY,\n        seller_id INTEGER REFERENCES users(id),\n        quota_id INTEGER REFERENCES quotas(id), -- Refer√™ncia para cota √† venda no mercado secund√°rio\n        title VARCHAR(255) NOT NULL,\n        description TEXT,\n        price DECIMAL(10, 2) NOT NULL,\n        category VARCHAR(50) DEFAULT 'OUTROS',\n        image_url TEXT,\n        status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE, SOLD, PAUSED, DELETED\n        is_boosted BOOLEAN DEFAULT FALSE,\n        boost_expires_at TIMESTAMP,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Garantir que as colunas de impulsionamento e quota_id existem (para bancos legados)\n    await client.query(`\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS is_boosted BOOLEAN DEFAULT FALSE;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS boost_expires_at TIMESTAMP;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS quota_id INTEGER REFERENCES quotas(id);\n      \n      -- Suporte a itens digitais e log√≠stica\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS item_type VARCHAR(20) DEFAULT 'PHYSICAL'; -- PHYSICAL, DIGITAL\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS digital_content TEXT; -- Link/c√≥digo/conte√∫do digital\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS required_vehicle VARCHAR(20) DEFAULT 'MOTO';\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS stock INTEGER DEFAULT 1;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS pickup_address TEXT;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS pickup_postal_code VARCHAR(20);\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS weight_grams INTEGER DEFAULT 1000;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS free_shipping BOOLEAN DEFAULT FALSE;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS shipping_price DECIMAL(10,2) DEFAULT 0;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS delivery_fee_final DECIMAL(10,2) DEFAULT 0; -- Cache do frete calculado\n      \n      -- DELIVERY PREMIUM: Opcionais de Card√°pio\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS food_options JSONB DEFAULT '[]';\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS seller_phone VARCHAR(20);\n    `);\n\n    // Tabela de Pedidos / Escrow (Garantia Cred30)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS marketplace_orders (\n        id SERIAL PRIMARY KEY,\n        listing_id INTEGER REFERENCES marketplace_listings(id),\n        buyer_id INTEGER REFERENCES users(id),\n        seller_id INTEGER REFERENCES users(id),\n        amount DECIMAL(10, 2) NOT NULL,\n        fee_amount DECIMAL(10, 2) NOT NULL, -- Taxa de 5-10% da Cred30 pela garantia\n        seller_amount DECIMAL(10, 2) NOT NULL, -- Valor que o vendedor receber√° (amount - fee)\n        status VARCHAR(30) DEFAULT 'WAITING_PAYMENT', -- WAITING_PAYMENT, WAITING_SHIPPING, IN_TRANSIT, DELIVERED, COMPLETED, CANCELLED, DISPUTE\n        payment_method VARCHAR(20), -- BALANCE, PIX, etc\n        delivery_address TEXT,\n        contact_phone VARCHAR(20),\n        dispute_reason TEXT,\n        disputed_at TIMESTAMP,\n        buyer_rating INTEGER, -- -5 a 5\n        seller_rating INTEGER, -- -5 a 5\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        tracking_code VARCHAR(100),\n        offline_token VARCHAR(50),\n        listing_ids INTEGER[],\n        is_lote BOOLEAN DEFAULT FALSE,\n        quantity INTEGER DEFAULT 1,\n        variant_id INTEGER,\n        item_title VARCHAR(255),\n        pickup_lat NUMERIC,\n        pickup_lng NUMERIC,\n        delivery_lat NUMERIC,\n        delivery_lng NUMERIC,\n        pickup_code VARCHAR(10),\n        delivery_confirmation_code VARCHAR(10),\n        invited_courier_id INTEGER\n      )\n    `);\n\n    // Garantir que a coluna de token offline existe\n    await client.query(`\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS offline_token VARCHAR(50);\n    `);\n\n    // Garantir colunas novas\n    await client.query(`\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS dispute_reason TEXT;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS disputed_at TIMESTAMP;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS buyer_rating INTEGER;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS seller_rating INTEGER;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_address TEXT;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_status VARCHAR(30) DEFAULT 'NONE';\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_fee DECIMAL(10, 2) DEFAULT 0;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS courier_id INTEGER REFERENCES users(id);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_code VARCHAR(10);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS contact_phone VARCHAR(20);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS quantity INTEGER DEFAULT 1;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS variant_id INTEGER;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS item_title VARCHAR(255);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_lat NUMERIC;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_lng NUMERIC;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_lat NUMERIC;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_lng NUMERIC;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_confirmation_code VARCHAR(10);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS invited_courier_id INTEGER;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS previous_couriers INTEGER[];\n    `);\n\n    // --- VARIANTES E IMAGENS (PHASE 3) ---\n\n    // Tabela de Variantes de An√∫ncios (Cor, Tamanho, Estoque individual)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS marketplace_listing_variants (\n        id SERIAL PRIMARY KEY,\n        listing_id INTEGER REFERENCES marketplace_listings(id) ON DELETE CASCADE,\n        name VARCHAR(100), -- Ex: \"Azul / M\"\n        color VARCHAR(50),\n        size VARCHAR(50),\n        stock INTEGER DEFAULT 0,\n        price DECIMAL(10, 2), -- Opcional, se variar por modelo\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Tabela de Imagens Adicionais (Galeria)\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS marketplace_listing_images (\n        id SERIAL PRIMARY KEY,\n        listing_id INTEGER REFERENCES marketplace_listings(id) ON DELETE CASCADE,\n        image_url TEXT NOT NULL,\n        display_order INTEGER DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n    await client.query(`\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS picked_up_at TIMESTAMP;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivered_at TIMESTAMP;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_lat DECIMAL(10, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS pickup_lng DECIMAL(11, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_lat DECIMAL(10, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS delivery_lng DECIMAL(11, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS courier_lat DECIMAL(10, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS courier_lng DECIMAL(11, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS variant_id INTEGER REFERENCES marketplace_listing_variants(id);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS invited_courier_id UUID;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS previous_couriers INTEGER[];\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS address TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS phone VARCHAR(20);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS listing_ids INTEGER[];\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS is_lote BOOLEAN DEFAULT FALSE;\n      \n      -- DELIVERY PREMIUM: Opcionais selecionados e Rastreio GPS\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS selected_options JSONB DEFAULT '[]';\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS courier_lat DECIMAL(10, 8);\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS courier_lng DECIMAL(11, 8);\n    `);\n\n    // --- SISTEMA DE PROMO√á√ÉO DE V√çDEOS (VIEW-TO-EARN) ---\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS promo_videos(\n      id SERIAL PRIMARY KEY,\n      user_id ${userIdType} NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n      title VARCHAR(200) NOT NULL,\n      description TEXT,\n      video_url TEXT NOT NULL,\n      thumbnail_url TEXT,\n      platform VARCHAR(50) DEFAULT 'YOUTUBE',\n      duration_seconds INTEGER DEFAULT 60,\n      price_per_view DECIMAL(10, 2) NOT NULL DEFAULT 0.05,\n      min_watch_seconds INTEGER NOT NULL DEFAULT 30,\n      budget DECIMAL(10, 2) NOT NULL DEFAULT 0,\n      spent DECIMAL(10, 2) NOT NULL DEFAULT 0,\n      max_views INTEGER,\n      target_views INTEGER DEFAULT 1000,\n      daily_limit INTEGER DEFAULT 100,\n      status VARCHAR(20) DEFAULT 'PENDING',\n      is_active BOOLEAN DEFAULT FALSE,\n      total_views INTEGER DEFAULT 0,\n      unique_viewers INTEGER DEFAULT 0,\n      total_watch_time INTEGER DEFAULT 0,\n      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n      approved_at TIMESTAMP WITH TIME ZONE,\n      completed_at TIMESTAMP WITH TIME ZONE,\n      expires_at TIMESTAMP WITH TIME ZONE,\n      is_approved BOOLEAN DEFAULT FALSE,\n      approved_by INTEGER REFERENCES users(id),\n      rejection_reason TEXT,\n      tag VARCHAR(30) DEFAULT 'OUTROS',\n      budget_gross DECIMAL(10, 2) DEFAULT 0\n    );\n\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS budget_gross DECIMAL(10, 2) DEFAULT 0;\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS tag VARCHAR(30) DEFAULT 'OUTROS';\n\n      CREATE TABLE IF NOT EXISTS promo_video_views(\n      id SERIAL PRIMARY KEY,\n      video_id INTEGER NOT NULL REFERENCES promo_videos(id) ON DELETE CASCADE,\n      viewer_id ${userIdType} NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n      watch_time_seconds INTEGER NOT NULL DEFAULT 0,\n      completed BOOLEAN DEFAULT FALSE,\n      earned DECIMAL(10, 2) DEFAULT 0,\n      paid_at TIMESTAMP WITH TIME ZONE,\n      ip_address VARCHAR(45),\n      user_agent TEXT,\n      device_fingerprint VARCHAR(100),\n      started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n      finished_at TIMESTAMP WITH TIME ZONE,\n      UNIQUE(video_id, viewer_id)\n    );\n\n    --SISTEMA DE SESS√ïES DE ESTUDO(ACADEMY)\n      CREATE TABLE IF NOT EXISTS education_sessions(\n      id SERIAL PRIMARY KEY,\n      user_id ${userIdType} NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n      video_id VARCHAR(50) NOT NULL,\n      started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n      last_ping_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n      total_seconds INTEGER DEFAULT 0,\n      is_active BOOLEAN DEFAULT TRUE,\n      ip_address VARCHAR(45),\n      user_agent TEXT\n    );\n      CREATE INDEX IF NOT EXISTS idx_edu_sessions_user ON education_sessions(user_id);\n\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS budget_gross DECIMAL(10, 2) DEFAULT 0;\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS tag VARCHAR(30) DEFAULT 'OUTROS';\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS payment_id VARCHAR(255);\n\n      CREATE INDEX IF NOT EXISTS idx_promo_videos_user_v2 ON promo_videos(user_id);\n      CREATE INDEX IF NOT EXISTS idx_promo_videos_status_v2 ON promo_videos(status, is_active);\n    `);\n\n    // --- SISTEMA DE SUPORTE VIA CHAT (IA + HUMANO) ---\n    console.log('Verificando tabelas de suporte...');\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS support_chats(\n      id SERIAL PRIMARY KEY,\n      user_id ${userIdType} REFERENCES users(id),\n      status VARCHAR(20) DEFAULT 'AI_ONLY', --AI_ONLY, PENDING_HUMAN, ACTIVE_HUMAN, CLOSED\n        rating INTEGER,\n      feedback_comment TEXT,\n      last_message_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    );\n\n    --Garantir colunas de feedback para bancos existentes\n      ALTER TABLE support_chats ADD COLUMN IF NOT EXISTS rating INTEGER;\n      ALTER TABLE support_chats ADD COLUMN IF NOT EXISTS feedback_comment TEXT;\n\n      CREATE TABLE IF NOT EXISTS support_messages(\n      id SERIAL PRIMARY KEY,\n      chat_id INTEGER REFERENCES support_chats(id) ON DELETE CASCADE,\n      sender_id ${userIdType} REFERENCES users(id), --NULL se for IA\n        role VARCHAR(20) NOT NULL, --user, assistant, admin\n        content TEXT NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_support_chats_user ON support_chats(user_id);\n      CREATE INDEX IF NOT EXISTS idx_support_chats_status ON support_chats(status);\n      CREATE INDEX IF NOT EXISTS idx_support_messages_chat ON support_messages(chat_id);\n`);\n\n    console.log('Tabelas de suporte criadas/verificadas com sucesso!');\n\n    // --- SISTEMA DE SEGURO DE ENTREGAS ---\n    console.log('Criando tabelas do sistema de seguro de entregas...');\n    await client.query(`\n      -- Fundo de Seguro: Reserva de cada entrega para cobrir incidentes\n      CREATE TABLE IF NOT EXISTS delivery_insurance_fund (\n        id SERIAL PRIMARY KEY,\n        order_id INTEGER REFERENCES marketplace_orders(id) ON DELETE CASCADE,\n        courier_contribution DECIMAL(10,2) NOT NULL DEFAULT 0,\n        platform_contribution DECIMAL(10,2) NOT NULL DEFAULT 0,\n        total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,\n        status VARCHAR(20) DEFAULT 'RESERVED',\n        released_at TIMESTAMP,\n        used_for_claim_id INTEGER,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n\n      -- Claims: Registro de incidentes reportados\n      CREATE TABLE IF NOT EXISTS delivery_claims (\n        id SERIAL PRIMARY KEY,\n        order_id INTEGER REFERENCES marketplace_orders(id) ON DELETE SET NULL,\n        courier_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\n        reported_by INTEGER REFERENCES users(id) ON DELETE SET NULL,\n        claim_type VARCHAR(30) NOT NULL,\n        description TEXT,\n        evidence_urls TEXT[],\n        seller_refund DECIMAL(10,2) DEFAULT 0,\n        buyer_refund DECIMAL(10,2) DEFAULT 0,\n        courier_penalty DECIMAL(10,2) DEFAULT 0,\n        status VARCHAR(20) DEFAULT 'PENDING',\n        admin_notes TEXT,\n        resolved_by INTEGER REFERENCES users(id),\n        resolved_at TIMESTAMP,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n\n      -- Colunas de aceite de termos e saldo de seguro do entregador\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS seller_terms_accepted_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_terms_accepted_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS courier_insurance_balance DECIMAL(10,2) DEFAULT 0;\n\n      -- √çndices para performance\n      CREATE INDEX IF NOT EXISTS idx_insurance_fund_order ON delivery_insurance_fund(order_id);\n      CREATE INDEX IF NOT EXISTS idx_insurance_fund_status ON delivery_insurance_fund(status);\n      CREATE INDEX IF NOT EXISTS idx_claims_status ON delivery_claims(status);\n      CREATE INDEX IF NOT EXISTS idx_claims_courier ON delivery_claims(courier_id);\n    `);\n    console.log('Tabelas de seguro de entregas criadas/verificadas com sucesso!');\n\n\n    console.log('Tabelas criadas/verificadas com sucesso!');\n\n    // Criar √≠ndices de performance\n    console.log('Criando √≠ndices de performance...');\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\n      CREATE INDEX IF NOT EXISTS idx_users_referral_code ON users(referral_code);\n      CREATE INDEX IF NOT EXISTS idx_users_is_admin ON users(is_admin);\n      CREATE INDEX IF NOT EXISTS idx_quotas_user_id ON quotas(user_id);\n      CREATE INDEX IF NOT EXISTS idx_quotas_status ON quotas(status);\n      CREATE INDEX IF NOT EXISTS idx_loans_user_id ON loans(user_id);\n      CREATE INDEX IF NOT EXISTS idx_loans_status ON loans(status);\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id);\n      CREATE INDEX IF NOT EXISTS idx_transactions_status ON transactions(status);\n      CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at);\n\n--Novos √≠ndices para otimiza√ß√£o batch e admin\n      CREATE INDEX IF NOT EXISTS idx_transactions_payout_pending ON transactions(payout_status) WHERE payout_status = 'PENDING_PAYMENT';\n      CREATE INDEX IF NOT EXISTS idx_loans_payout_pending ON loans(payout_status) WHERE payout_status = 'PENDING_PAYMENT';\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_type_idx ON transactions(user_id, type);\n      CREATE INDEX IF NOT EXISTS idx_loans_user_status_active ON loans(user_id, status) WHERE status IN('APPROVED', 'PAYMENT_PENDING');\n      CREATE INDEX IF NOT EXISTS idx_users_score_desc ON users(score DESC);\n\n--Novas Otimiza√ß√µes de √çndices Compostos\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_created_desc ON transactions(user_id, created_at DESC);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_active_created_desc ON marketplace_listings(status, created_at DESC) WHERE status = 'ACTIVE';\n`);\n\n    // Otimiza√ß√£o de precis√£o decimal e estat√≠sticas\n    await client.query(`\n      ALTER TABLE system_config ALTER COLUMN system_balance TYPE DECIMAL(20, 2);\n      ALTER TABLE system_config ALTER COLUMN profit_pool TYPE DECIMAL(20, 2);\n      ALTER TABLE system_config ALTER COLUMN total_tax_reserve TYPE DECIMAL(20, 2);\n      ALTER TABLE system_config ALTER COLUMN total_operational_reserve TYPE DECIMAL(20, 2);\n      ALTER TABLE system_config ALTER COLUMN total_owner_profit TYPE DECIMAL(20, 2);\n      ALTER TABLE system_config ALTER COLUMN total_gateway_costs TYPE DECIMAL(20, 2);\n      \n      ANALYZE users;\n      ANALYZE transactions;\n      ANALYZE loans;\n      ANALYZE quotas;\n      ANALYZE marketplace_listings;\n      ANALYZE marketplace_orders;\n\n--Otimiza√ß√£o para HOT Updates(Heaps Only Tuples) na tabela users\n--Ajuda a reduzir o v√°cuo e a fragmenta√ß√£o em tabelas com muitos updates\n      ALTER TABLE users SET(fillfactor = 85);\n`);\n\n\n    // Adicionar campos de monetiza√ß√£o na tabela de usu√°rios\n    await client.query(`\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS membership_type VARCHAR(20) DEFAULT 'FREE'; --FREE, PRO\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS last_reward_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS total_dividends_earned DECIMAL(12, 2) DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS security_lock_until TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS last_ip VARCHAR(45);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS last_login_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS panic_phrase VARCHAR(255);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_under_duress BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS safe_contact_phone VARCHAR(20);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS welcome_benefit_uses INTEGER DEFAULT 0; --Contador de usos do benef√≠cio de boas - vindas\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS video_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS ad_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS pending_ad_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS total_ad_points INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_protected BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS protection_expires_at TIMESTAMP;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS is_verified BOOLEAN DEFAULT FALSE;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS daily_chests_opened INTEGER DEFAULT 0;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS last_chest_date VARCHAR(10);\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_status VARCHAR(20) DEFAULT 'NONE'; --NONE, PENDING, APPROVED, REJECTED\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_document_path TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS kyc_notes TEXT;\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS cpf VARCHAR(14);\n`);\n\n    // Criar tabelas de auditoria e webhooks\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS audit_logs(\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id),\n  action_type VARCHAR(100),\n  entity_type VARCHAR(50),\n  entity_id VARCHAR(100),\n  old_values JSONB,\n  new_values JSONB,\n  ip_address VARCHAR(45),\n  user_agent TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n      -- Garantir que colunas existam em tabelas legadas\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS action_type VARCHAR(100);\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS entity_type VARCHAR(50);\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS entity_id VARCHAR(100);\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS old_values JSONB;\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS new_values JSONB;\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS user_agent TEXT;\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS metadata JSONB;\n\n      CREATE TABLE IF NOT EXISTS webhook_logs(\n  id SERIAL PRIMARY KEY,\n  provider VARCHAR(50) NOT NULL,\n  payload JSONB NOT NULL,\n  status VARCHAR(20) DEFAULT 'PENDING',\n  error_message TEXT,\n  processed_at TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n      CREATE INDEX IF NOT EXISTS idx_audit_user_id ON audit_logs(user_id);\n      CREATE INDEX IF NOT EXISTS idx_audit_action_type ON audit_logs(action_type);\n      CREATE INDEX IF NOT EXISTS idx_webhook_status ON webhook_logs(status);\n`);\n\n    // --- SISTEMA DE GOVERNAN√áA (VOTA√á√ÉO V2) ---\n    console.log('Verificando tabelas de governan√ßa...');\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS governance_proposals(\n  id SERIAL PRIMARY KEY,\n  title VARCHAR(255) NOT NULL,\n  description TEXT NOT NULL,\n  creator_id INTEGER REFERENCES users(id),\n  category VARCHAR(50) DEFAULT 'general',\n  status VARCHAR(20) DEFAULT 'active', --active, passed, rejected, closed\n        yes_votes_power DECIMAL(15, 2) DEFAULT 0,\n  no_votes_power DECIMAL(15, 2) DEFAULT 0,\n  expires_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n      CREATE TABLE IF NOT EXISTS governance_votes(\n  id SERIAL PRIMARY KEY,\n  proposal_id INTEGER REFERENCES governance_proposals(id) ON DELETE CASCADE,\n  user_id ${userIdType} REFERENCES users(id),\n  choice VARCHAR(10) NOT NULL, --yes, no\n        voting_power DECIMAL(15, 2) DEFAULT 1,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  UNIQUE(proposal_id, user_id)\n);\n\n      CREATE INDEX IF NOT EXISTS idx_gov_votes_proposal ON governance_votes(proposal_id);\n      CREATE INDEX IF NOT EXISTS idx_gov_votes_user ON governance_votes(user_id);\n`);\n    // Garantir que todas as tabelas tenham as colunas de data necess√°rias para os √≠ndices\n    await client.query(`\n      ALTER TABLE loans ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n      ALTER TABLE marketplace_listings ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n      ALTER TABLE marketplace_orders ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n      ALTER TABLE admin_logs ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n      ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP;\n      ALTER TABLE quotas ADD COLUMN IF NOT EXISTS purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n`);\n\n    // --- √çNDICES DE PERFORMANCE (OTIMIZA√á√ÉO) ---\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_marketplace_status ON marketplace_listings(status);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_seller ON marketplace_listings(seller_id);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_listing ON marketplace_orders(listing_id);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_buyer_seller ON marketplace_orders(buyer_id, seller_id);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_status ON marketplace_orders(status);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_offline_token ON marketplace_orders(offline_token) WHERE offline_token IS NOT NULL;\n      CREATE INDEX IF NOT EXISTS idx_loans_created_at ON loans(created_at);\n      CREATE INDEX IF NOT EXISTS idx_quotas_purchase_date ON quotas(purchase_date);\n      CREATE INDEX IF NOT EXISTS idx_admin_logs_created_at ON admin_logs(created_at);\n      CREATE INDEX IF NOT EXISTS idx_admin_logs_finance_actions ON admin_logs(created_at DESC) \n        WHERE action IN('MANUAL_PROFIT_ADD', 'PAY_COST', 'ADD_COST', 'DELETE_COST', 'MANUAL_ADD_QUOTA');\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);\n      CREATE INDEX IF NOT EXISTS idx_loans_user_status ON loans(user_id, status);\n      CREATE INDEX IF NOT EXISTS idx_loan_installments_loan ON loan_installments(loan_id);\n      CREATE INDEX IF NOT EXISTS idx_products_active ON products(active);\n`);\n    console.log('√çndices de performance verificados!');\n\n    console.log('--- [DB] Initializing Audit and Logs ---');\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS system_costs(\n  id SERIAL PRIMARY KEY,\n  description VARCHAR(255) NOT NULL,\n  amount DECIMAL(10, 2) NOT NULL,\n  is_recurring BOOLEAN DEFAULT TRUE,\n  category VARCHAR(20) DEFAULT 'MIXED',\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n--Tabela de avalia√ß√µes de transa√ß√µes(saques, etc.)\n      CREATE TABLE IF NOT EXISTS transaction_reviews(\n  id SERIAL PRIMARY KEY,\n  transaction_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,\n  user_id ${userIdType} NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  rating INTEGER NOT NULL CHECK(rating >= 1 AND rating <= 5),\n  comment TEXT,\n  is_public BOOLEAN DEFAULT FALSE,\n  is_approved BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  UNIQUE(transaction_id)\n);\n\n      CREATE INDEX IF NOT EXISTS idx_reviews_user ON transaction_reviews(user_id);\n      CREATE INDEX IF NOT EXISTS idx_reviews_approved ON transaction_reviews(is_approved, is_public);\n\n--Tabela de Reportes de Bug\n--Tabela de Reportes de Bug\n      CREATE TABLE IF NOT EXISTS bug_reports(\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\n  user_email VARCHAR(255),\n  user_name VARCHAR(255),\n  title VARCHAR(255) NOT NULL,\n  description TEXT NOT NULL,\n  category VARCHAR(50) DEFAULT 'general',\n  severity VARCHAR(20) DEFAULT 'low',\n  status VARCHAR(20) DEFAULT 'open',\n  screenshot_url TEXT,\n  device_info TEXT,\n  admin_notes TEXT,\n  resolved_by INTEGER REFERENCES users(id) ON DELETE SET NULL,\n  resolved_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n      -- Garantir que colunas cr√≠ticas existam antes de criar √≠ndices\n      ALTER TABLE bug_reports ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'open';\n      ALTER TABLE notifications ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'UNREAD';\n      ALTER TABLE transaction_reviews ADD COLUMN IF NOT EXISTS is_approved BOOLEAN DEFAULT FALSE;\n\n      CREATE INDEX IF NOT EXISTS idx_bug_reports_user_id ON bug_reports(user_id);\n      CREATE INDEX IF NOT EXISTS idx_bug_reports_status ON bug_reports(status);\n      CREATE INDEX IF NOT EXISTS idx_bug_reports_severity ON bug_reports(severity);\n      CREATE INDEX IF NOT EXISTS idx_bug_reports_created_at ON bug_reports(created_at DESC);\n\n--Tabela de Notifica√ß√µes Persistentes\n      CREATE TABLE IF NOT EXISTS notifications(\n  id SERIAL PRIMARY KEY,\n  user_id ${userIdType} REFERENCES users(id) ON DELETE CASCADE,\n  title VARCHAR(255) NOT NULL,\n  message TEXT NOT NULL,\n  type VARCHAR(50),\n  status VARCHAR(20) DEFAULT 'UNREAD',\n  metadata JSONB,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n      CREATE INDEX IF NOT EXISTS idx_notifications_user_status ON notifications(user_id, status);\n      CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at DESC);\n`);\n\n    // Tabela de Investimentos\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS investments(\n  id SERIAL PRIMARY KEY,\n  asset_name VARCHAR(100) NOT NULL,\n  asset_type VARCHAR(50) NOT NULL,\n  quantity DECIMAL(15, 6) DEFAULT 0,\n  unit_price DECIMAL(15, 2) NOT NULL,\n  total_invested DECIMAL(15, 2) NOT NULL,\n  current_value DECIMAL(15, 2) DEFAULT 0,\n  dividends_received DECIMAL(15, 2) DEFAULT 0,\n  broker VARCHAR(100),\n  notes TEXT,\n  status VARCHAR(20) DEFAULT 'ACTIVE',\n  sale_value DECIMAL(15, 2),\n  invested_at TIMESTAMP DEFAULT NOW(),\n  sold_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n      ALTER TABLE investments ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'ACTIVE';\n      ALTER TABLE investments ADD COLUMN IF NOT EXISTS sale_value DECIMAL(15, 2);\n      ALTER TABLE investments ADD COLUMN IF NOT EXISTS sold_at TIMESTAMP;\n\n      CREATE INDEX IF NOT EXISTS idx_investments_asset_type ON investments(asset_type);\n      CREATE INDEX IF NOT EXISTS idx_investments_status ON investments(status);\n      CREATE INDEX IF NOT EXISTS idx_investments_invested_at ON investments(invested_at);\n`);\n\n    // Adicionar coluna tag na tabela promo_videos e √≠ndices\n    await client.query(`\n      ALTER TABLE promo_videos ADD COLUMN IF NOT EXISTS tag VARCHAR(30) DEFAULT 'OUTROS';\n      CREATE INDEX IF NOT EXISTS idx_promo_videos_tag ON promo_videos(tag);\n      CREATE INDEX IF NOT EXISTS idx_promo_videos_active ON promo_videos(is_active, status);\n      CREATE INDEX IF NOT EXISTS idx_promo_videos_views ON promo_videos(total_views DESC);\n\n--Otimiza√ß√£o para o Feed de V√≠deos\n      CREATE INDEX IF NOT EXISTS idx_promo_video_views_viewer_video ON promo_video_views(viewer_id, video_id, completed);\n      CREATE INDEX IF NOT EXISTS idx_promo_video_views_video_completed ON promo_video_views(video_id) WHERE completed = TRUE;\n\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_type ON transactions(user_id, type);\n      CREATE INDEX IF NOT EXISTS idx_users_balance ON users(balance DESC);\n      \n      -- Log√≠stica / Marketplace Indexes\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_delivery_status ON marketplace_orders(delivery_status);\n      CREATE INDEX IF NOT EXISTS idx_marketplace_orders_status ON marketplace_orders(status);\n\n      -- Blindagem de Custos\n      ALTER TABLE system_costs ADD COLUMN IF NOT EXISTS category VARCHAR(20) DEFAULT 'MIXED';\n`);\n    console.log('√çndices de otimiza√ß√£o aplicados!');\n\n    console.log('Audit logs and performance indexes updated successfully!');\n\n    // Inicializar tabelas de auditoria e rate limiting\n    // Comentado para evitar depend√™ncia circular\n    // await initializeAuditTable(pool);\n    // await initializeRateLimitTable(pool);\n\n    // Criar √≠ndices de performance\n    // Comentado para evitar depend√™ncia circular\n    // await createIndexes(pool);\n\n    // --- CONSORTIUM UPDATES (LATEST) ---\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS consortium_groups (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        admin_id INTEGER REFERENCES users(id),\n        status VARCHAR(20) DEFAULT 'ACTIVE',\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n\n      CREATE TABLE IF NOT EXISTS consortium_members (\n        id SERIAL PRIMARY KEY,\n        group_id INTEGER REFERENCES consortium_groups(id),\n        user_id INTEGER REFERENCES users(id),\n        status VARCHAR(20) DEFAULT 'ACTIVE',\n        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n    await client.query(`\n      ALTER TABLE consortium_members ADD COLUMN IF NOT EXISTS invoice_url TEXT;\n      ALTER TABLE consortium_members ADD COLUMN IF NOT EXISTS credit_limit_released DECIMAL(15, 2);\n      ALTER TABLE consortium_groups ADD COLUMN IF NOT EXISTS reserve_pool DECIMAL(20, 2) DEFAULT 0;\n    `);\n\n  } catch (error) {\n    console.error('Erro ao inicializar o banco de dados:', error);\n    throw error;\n  } finally {\n    client.release();\n  }\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/database/postgresql/repositories/marketplace.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\n\nexport class MarketplaceRepository {\n    constructor(private pool: Pool) { }\n\n    async findOrderById(orderId: string | number) {\n        const result = await this.pool.query(\n            'SELECT * FROM marketplace_orders WHERE id = $1',\n            [orderId]\n        );\n        return result.rows[0];\n    }\n\n    async updateOrderMetadata(client: PoolClient, orderId: string | number, metadata: any) {\n        await client.query(\n            'UPDATE marketplace_orders SET metadata = $1 WHERE id = $2',\n            [metadata, orderId]\n        );\n    }\n\n    async updateSellerAmount(client: PoolClient, orderId: string | number, amount: number) {\n        await client.query(\n            'UPDATE marketplace_orders SET seller_amount = $1 WHERE id = $2',\n            [amount, orderId]\n        );\n    }\n\n    async updateCourierFee(client: PoolClient, orderId: string | number, fee: number) {\n        await client.query(\n            'UPDATE marketplace_orders SET courier_fee = $1 WHERE id = $2',\n            [fee, orderId]\n        );\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/firebase/admin-config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1483,1486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1483,1486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as admin from 'firebase-admin';\n\n/**\n * Inicializa o Firebase Admin SDK\n * √â necess√°rio o arquivo de credenciais (Service Account JSON) ou vari√°veis de ambiente.\n */\nexport const initializeFirebaseAdmin = () => {\n    if (admin.apps.length > 0) return;\n\n    try {\n        // Se houver as credenciais no .env, inicializa\n        if (process.env.FIREBASE_SERVICE_ACCOUNT) {\n            console.log('[Firebase] Detectado FIREBASE_SERVICE_ACCOUNT no ambiente.');\n            let serviceAccountData = process.env.FIREBASE_SERVICE_ACCOUNT;\n            // Remover aspas simples extras se existirem (comum em alguns ambientes)\n            if (typeof serviceAccountData === 'string' && serviceAccountData.startsWith(\"'\") && serviceAccountData.endsWith(\"'\")) {\n                serviceAccountData = serviceAccountData.slice(1, -1);\n            }\n\n            try {\n                const serviceAccount = JSON.parse(serviceAccountData);\n\n                // CORRE√á√ÉO CR√çTICA: Substituir literais de quebra de linha por quebras reais no private_key\n                if (serviceAccount.private_key) {\n                    serviceAccount.private_key = serviceAccount.private_key.replace(/\\\\n/g, '\\n');\n                }\n                admin.initializeApp({\n                    credential: admin.credential.cert(serviceAccount)\n                });\n                console.log('Firebase Admin inicializado com sucesso para o projeto:', serviceAccount.project_id);\n            } catch (jsonErr: any) {\n                console.error('[Firebase] Erro ao processar JSON da Service Account:', jsonErr.message);\n                console.error('[Firebase] In√≠cio da string (primeiros 50 chars):', serviceAccountData.substring(0, 50));\n            }\n        } else {\n            // Tenta inicializar com credenciais padr√£o (√∫til em ambientes como Google Cloud)\n            admin.initializeApp();\n            console.log('Firebase Admin inicializado com Application Default Credentials');\n        }\n    } catch (error) {\n        console.error('Erro ao inicializar Firebase Admin:', error);\n    }\n};\n\nexport const firebaseAdmin = admin;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/gateways/email.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/gateways/youtube.service.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\&.","line":29,"column":67,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":29,"endColumn":68,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1102,1103],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1102,1102],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\&.","line":29,"column":76,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":29,"endColumn":77,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1111,1112],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1111,1111],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\?.","line":29,"column":78,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":29,"endColumn":79,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1113,1114],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1113,1113],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Servi√ßo para auditar m√©tricas p√∫blicas do YouTube.\n */\nexport async function getYouTubeFullStats(videoUrl: string): Promise<{ likes: number; views: number; comments: number; subscribers: number } | null> {\n    try {\n        const videoId = extractVideoId(videoUrl);\n        if (!videoId) return null;\n\n        // Simula√ß√£o de resposta completa para auditoria\n        // Na vida real, aqui seriam chamadas √† API do YouTube v3\n        // likes: video.statistics.likeCount\n        // comments: video.statistics.commentCount\n        // subscribers: channel.statistics.subscriberCount\n\n        return {\n            likes: Math.floor(Math.random() * 500) + 100,\n            views: Math.floor(Math.random() * 5000) + 200,\n            comments: Math.floor(Math.random() * 50) + 5,\n            subscribers: Math.floor(Math.random() * 10000) + 500\n        };\n    } catch (error) {\n        console.error('[YOUTUBE-SERVICE] Erro ao buscar stats:', error);\n        return null;\n    }\n}\n\nfunction extractVideoId(url: string): string | null {\n    const regExp = /^.*(youtu\\.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=)([^#\\&\\?]*).*/;\n    const match = url.match(regExp);\n    return (match && match[2].length === 11) ? match[2] : null;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/logging/audit.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[281,284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[281,284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[300,303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[300,303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1408,1411],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1408,1411],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2165,2168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2165,2168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2228,2231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2228,2231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MiddlewareHandler } from 'hono';\nimport { getDbPool } from '../database/postgresql/connection/pool';\n\ninterface AuditLog {\n  adminId: string; // Corrigido: era number, agora string (UUID)\n  action: string;\n  entityType: string;\n  entityId?: string | number;\n  oldValues?: any;\n  newValues?: any;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n/**\n * Middleware para auditoria de a√ß√µes administrativas\n */\nexport const auditMiddleware = (action: string, entityType: string): MiddlewareHandler => {\n  return async (c, next) => {\n    const user = c.get('user');\n    const body = await c.req.json().catch(() => ({}));\n    \n    // Capturar informa√ß√µes da requisi√ß√£o\n    const auditData: AuditLog = {\n      adminId: user.id, // Agora √© UUID (string)\n      action,\n      entityType,\n      entityId: body.id,\n      newValues: body,\n      ipAddress: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || '127.0.0.1',\n      userAgent: c.req.header('user-agent') || 'unknown'\n    };\n    \n    // Executar a a√ß√£o principal\n    await next();\n    \n    // Registrar auditoria de forma ass√≠ncrona para n√£o impactar performance\n    logAuditAction(auditData).catch(error => {\n      console.error('Erro ao registrar auditoria:', error);\n    });\n  };\n};\n\n/**\n * Registra a√ß√£o de auditoria no banco de dados\n */\nasync function logAuditAction(auditData: AuditLog): Promise<void> {\n  const pool = getDbPool({} as any);\n  \n  try {\n    await pool.query(\n      `INSERT INTO admin_logs (admin_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,\n      [\n        auditData.adminId, // UUID como string\n        auditData.action,\n        auditData.entityType,\n        auditData.entityId,\n        auditData.oldValues ? JSON.stringify(auditData.oldValues) : null,\n        auditData.newValues ? JSON.stringify(auditData.newValues) : null,\n        auditData.ipAddress,\n        auditData.userAgent\n      ]\n    );\n  } catch (error) {\n    console.error('Falha ao registrar auditoria:', error);\n  }\n}\n\n/**\n * Cria tabela de auditoria se n√£o existir\n */\nexport async function initializeAuditTable(pool?: any): Promise<void> {\n  const dbPool = pool || getDbPool({} as any);\n  \n  try {\n    await dbPool.query(`\n      CREATE TABLE IF NOT EXISTS admin_logs (\n        id SERIAL PRIMARY KEY,\n        admin_id UUID REFERENCES users(id), -- Corrigido: era INTEGER, agora UUID\n        action VARCHAR(50) NOT NULL,\n        entity_type VARCHAR(20) NOT NULL,\n        entity_id VARCHAR(50),\n        old_values JSONB,\n        new_values JSONB,\n        ip_address TEXT,\n        user_agent TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n    \n    // Criar √≠ndices para performance\n    await dbPool.query(`\n      CREATE INDEX IF NOT EXISTS idx_admin_logs_admin_id ON admin_logs(admin_id);\n      CREATE INDEX IF NOT EXISTS idx_admin_logs_created_at ON admin_logs(created_at);\n      CREATE INDEX IF NOT EXISTS idx_admin_logs_entity ON admin_logs(entity_type, entity_id);\n    `);\n    \n    console.log('Tabela de auditoria inicializada com sucesso');\n  } catch (error) {\n    console.error('Erro ao inicializar tabela de auditoria:', error);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/infrastructure/logging/winston.logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[312,315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[312,315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[330,333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[330,333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[2146,2181],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[2238,2273],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2457,2460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2457,2460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2473,2476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2473,2476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2676,2679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2676,2679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2865,2868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2865,2868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3055,3058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3055,3058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3261,3264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3261,3264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3501,3504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3501,3504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO',\n  DEBUG = 'DEBUG'\n}\n\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  userId?: number;\n  ip?: string;\n  endpoint?: string;\n  method?: string;\n  statusCode?: number;\n  duration?: number;\n  error?: any;\n  metadata?: any;\n}\n\nclass Logger {\n  private static instance: Logger;\n  private logLevel: LogLevel = LogLevel.INFO;\n\n  private constructor() {}\n\n  public static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  public setLogLevel(level: LogLevel): void {\n    this.logLevel = level;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];\n    const currentLevelIndex = levels.indexOf(this.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    return messageLevelIndex <= currentLevelIndex;\n  }\n\n  private formatLog(entry: LogEntry): string {\n    const logObject = {\n      timestamp: entry.timestamp,\n      level: entry.level,\n      message: entry.message,\n      ...(entry.userId && { userId: entry.userId }),\n      ...(entry.ip && { ip: entry.ip }),\n      ...(entry.endpoint && { endpoint: entry.endpoint }),\n      ...(entry.method && { method: entry.method }),\n      ...(entry.statusCode && { statusCode: entry.statusCode }),\n      ...(entry.duration && { duration: entry.duration }),\n      ...(entry.error && { error: entry.error }),\n      ...(entry.metadata && { metadata: entry.metadata })\n    };\n\n    return JSON.stringify(logObject);\n  }\n\n  private writeLog(entry: LogEntry): void {\n    if (!this.shouldLog(entry.level)) {\n      return;\n    }\n\n    const formattedLog = this.formatLog(entry);\n    \n    // Em desenvolvimento, usar console com cores\n    if (process.env.NODE_ENV === 'development') {\n      switch (entry.level) {\n        case LogLevel.ERROR:\n          console.error(`üî¥ ${formattedLog}`);\n          break;\n        case LogLevel.WARN:\n          console.warn(`üü° ${formattedLog}`);\n          break;\n        case LogLevel.INFO:\n          console.info(`üîµ ${formattedLog}`);\n          break;\n        case LogLevel.DEBUG:\n          console.debug(`‚ö™ ${formattedLog}`);\n          break;\n      }\n    } else {\n      // Em produ√ß√£o, enviar para sistema de logs ou arquivo\n      console.log(formattedLog);\n    }\n  }\n\n  public error(message: string, error?: any, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.ERROR,\n      message,\n      error,\n      metadata\n    });\n  }\n\n  public warn(message: string, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.WARN,\n      message,\n      metadata\n    });\n  }\n\n  public info(message: string, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.INFO,\n      message,\n      metadata\n    });\n  }\n\n  public debug(message: string, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.DEBUG,\n      message,\n      metadata\n    });\n  }\n\n  public audit(action: string, userId: number, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.INFO,\n      message: `AUDIT: ${action}`,\n      userId,\n      metadata\n    });\n  }\n\n  public security(message: string, ip?: string, metadata?: any): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.WARN,\n      message: `SECURITY: ${message}`,\n      ip,\n      metadata\n    });\n  }\n\n  public performance(endpoint: string, method: string, duration: number, statusCode?: number): void {\n    this.writeLog({\n      timestamp: new Date().toISOString(),\n      level: LogLevel.DEBUG,\n      message: 'Performance metric',\n      endpoint,\n      method,\n      duration,\n      statusCode\n    });\n  }\n}\n\n// Exportar inst√¢ncia √∫nica\nexport const logger = Logger.getInstance();\n\n// Configurar n√≠vel de log baseado em vari√°vel de ambiente\nif (process.env.LOG_LEVEL) {\n  logger.setLogLevel(process.env.LOG_LEVEL as LogLevel);\n} else {\n  logger.setLogLevel(process.env.NODE_ENV === 'production' ? LogLevel.INFO : LogLevel.DEBUG);\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.approval.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createTransaction' is defined but never used.","line":4,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":77,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"createTransaction"},"fix":{"range":[203,222],"text":""},"desc":"Remove unused variable \"createTransaction\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11683,11686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11683,11686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12888,12891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12888,12891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15013,15016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15013,15016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":421,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":421,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16415,16418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16415,16418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18145,18148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18145,18148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":539,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21552,21555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21552,21555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":557,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":557,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22171,22174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22171,22174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, processTransactionApproval, createTransaction, updateUserBalance, updateTransactionStatus } from '../../../domain/services/transaction.service';\nimport { runAutoLiquidation } from '../../../application/services/auto-liquidation.service';\n\n// Schemas\nexport const actionSchema = z.object({\n    id: z.union([z.string(), z.number()]).transform((val) => {\n        if (typeof val === 'string') {\n            return val;\n        }\n        return val.toString();\n    }).refine((val) => typeof val === 'string', {\n        message: \"ID deve ser uma string (UUID) v√°lida\"\n    }),\n    type: z.enum(['TRANSACTION', 'LOAN']),\n    action: z.enum(['APPROVE', 'REJECT']),\n});\n\nexport const payoutActionSchema = z.object({\n    id: z.union([z.string(), z.number()]).transform(val => val.toString()),\n    type: z.enum(['TRANSACTION', 'LOAN']),\n});\n\nexport class AdminApprovalController {\n\n    /**\n     * Processar a√ß√£o administrativa (aprovar/rejeitar Transa√ß√£o ou Empr√©stimo)\n     */\n    static async processAction(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { id, type, action } = actionSchema.parse(body);\n\n            const pool = getDbPool(c);\n\n            // Executar dentro de transa√ß√£o para garantir consist√™ncia\n            const result = await executeInTransaction(pool, async (client) => {\n                if (type === 'TRANSACTION') {\n                    console.log(`[DEBUG_CTRL] Chamando processTransactionApproval para ID: ${id}`);\n                    return await processTransactionApproval(client, id, action);\n                } else if (type === 'LOAN') {\n                    // Importamos a fun√ß√£o de processamento de loan\n                    const { processLoanApproval } = await import('../../../domain/services/transaction.service');\n                    return await processLoanApproval(client, id, action);\n                }\n                throw new Error('Tipo de a√ß√£o n√£o reconhecido');\n            });\n\n            if (!result.success) {\n                return c.json({\n                    success: false,\n                    message: result.error\n                }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `${action === 'APPROVE' ? 'Aprovado' : 'Rejeitado'} com sucesso! [SERVER_ID: ${Date.now()}]`,\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n\n            return c.json({\n                success: false,\n                message: error instanceof Error ? error.message : 'Erro interno do servidor'\n            }, 500);\n        }\n    }\n\n    /**\n     * Listar Fila de Pagamentos (Payout Queue)\n     */\n    static async getPayoutQueue(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            // Buscar transa√ß√µes (saques) aguardando pagamento\n            const transactionsResult = await pool.query(\n                `SELECT t.*, u.name as user_name, u.email as user_email, u.pix_key as user_pix, u.score as user_score,\n                (SELECT COUNT(*) FROM quotas q WHERE q.user_id = t.user_id AND q.status = 'ACTIVE') as user_quotas\n         FROM transactions t\n         LEFT JOIN users u ON t.user_id = u.id\n         WHERE t.payout_status = 'PENDING_PAYMENT'\n         ORDER BY user_quotas DESC, user_score DESC, t.created_at ASC`\n            );\n\n            return c.json({\n                success: true,\n                data: {\n                    transactions: transactionsResult.rows,\n                    loans: [] // Retornar vazio para compatibilidade\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao buscar fila de pagamentos:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Listar Transa√ß√µes Pendentes (Aprova√ß√µes Iniciais)\n     */\n    static async getPendingTransactions(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            // Buscar transa√ß√µes que dependem de a√ß√£o humana (Status PENDING)\n            const result = await pool.query(\n                `SELECT t.*, u.name as user_name, u.email as user_email, u.pix_key as user_pix, u.phone as user_phone\n         FROM transactions t\n         LEFT JOIN users u ON t.user_id = u.id\n         WHERE t.status IN ('PENDING', 'PENDING_CONFIRMATION')\n           AND t.payout_status = 'NONE'\n         ORDER BY t.created_at ASC`\n            );\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (error) {\n            console.error('Erro ao buscar transa√ß√µes pendentes:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar Pagamento Efetuado (PIX Manual enviado pelo Admin)\n     */\n    static async confirmPayout(c: Context) {\n        console.log('[CONFIRM-PAYOUT] Iniciando confirma√ß√£o manual...');\n        try {\n            const body = await c.req.json();\n            const { id, type } = payoutActionSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const txResult = await executeInTransaction(pool, async (client) => {\n                if (type === 'TRANSACTION') {\n                    // Buscar dados da transa√ß√£o e do usu√°rio\n                    const txResult = await client.query(\n                        `SELECT t.user_id, t.amount, t.metadata, u.pix_key, u.name, u.email\n             FROM transactions t\n             JOIN users u ON t.user_id = u.id\n             WHERE t.id = $1`,\n                        [id]\n                    );\n\n                    if (txResult.rows.length === 0) {\n                        throw new Error('Transa√ß√£o n√£o encontrada');\n                    }\n\n                    const { user_id, amount, metadata, pix_key, name } = txResult.rows[0];\n                    const netAmount = metadata?.netAmount || parseFloat(amount);\n                    const pixKeyToUse = metadata?.pixKey || pix_key;\n\n                    if (!pixKeyToUse) {\n                        throw new Error('Usu√°rio n√£o possui chave PIX cadastrada');\n                    }\n\n                    // Atualizar status do pagamento para PAID\n                    await client.query(\n                        `UPDATE transactions \n             SET payout_status = $1, \n                 processed_at = $2, \n                 status = $3,\n                 metadata = metadata || $4::jsonb \n             WHERE id = $5`,\n                        [\n                            'PAID',\n                            new Date(),\n                            'APPROVED',\n                            JSON.stringify({\n                                payout_method: 'MANUAL_PIX',\n                                confirmed_by_admin: true,\n                                confirmed_at: new Date().toISOString()\n                            }),\n                            id\n                        ]\n                    );\n\n                    // Criar notifica√ß√£o\n                    await client.query(\n                        `INSERT INTO notifications (user_id, title, message, type, metadata, created_at)\n             VALUES ($1, $2, $3, $4, $5, $6)`,\n                        [\n                            user_id,\n                            'üí∏ Seu saque foi processado!',\n                            `O valor de R$ ${netAmount.toFixed(2)} foi enviado para sua chave PIX (${pixKeyToUse}). Confira sua conta!`,\n                            'PAYOUT_COMPLETED',\n                            JSON.stringify({\n                                transactionId: id,\n                                amount: netAmount,\n                                pixKey: pixKeyToUse\n                            }),\n                            new Date()\n                        ]\n                    );\n\n                    return { success: true, netAmount, userName: name?.split(' ')[0] };\n                } else {\n                    throw new Error('Tipo de confirma√ß√£o n√£o suportado');\n                }\n            });\n\n            if (!txResult.success) {\n                return c.json({ success: false, message: txResult.error || 'Erro ao processar pagamento' }, 500);\n            }\n\n            return c.json({\n                success: true,\n                message: `Pagamento de R$ ${txResult.data?.netAmount?.toFixed(2)} confirmado para ${txResult.data?.userName || 'usu√°rio'}!`\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            return c.json({ success: false, message: error instanceof Error ? error.message : 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar PIX de empr√©stimo (Fix)\n     */\n    static async fixLoanPix(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { loanId, pixKey } = body;\n\n            if (!loanId || !pixKey) {\n                return c.json({ success: false, message: 'loanId e pixKey s√£o obrigat√≥rios' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                'UPDATE loans SET pix_key_to_receive = $1 WHERE id = $2 RETURNING id, pix_key_to_receive',\n                [pixKey, loanId]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Empr√©stimo n√£o encontrado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: 'PIX atualizado com sucesso',\n                data: {\n                    loanId: result.rows[0].id,\n                    pixKey: result.rows[0].pix_key_to_receive\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao atualizar PIX do empr√©stimo:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Aprovar pagamentos de empr√©stimos pendentes\n     */\n    static async approvePayment(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId } = body;\n\n            if (!transactionId) {\n                return c.json({ success: false, message: 'transactionId √© obrigat√≥rio' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const transactionResult = await client.query(\n                    'SELECT * FROM transactions WHERE id = $1 AND status = $2 FOR UPDATE',\n                    [transactionId, 'PENDING']\n                );\n\n                if (transactionResult.rows.length === 0) {\n                    throw new Error('Transa√ß√£o n√£o encontrada ou j√° processada');\n                }\n\n                // Processar pagamento do empr√©stimo (l√≥gica completa de amortiza√ß√£o estaria aqui, simplificada para aprova√ß√£o)\n                await processTransactionApproval(client, transactionId, 'APPROVE');\n\n                return { success: true };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({ success: true, message: 'Pagamento aprovado com sucesso' });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Rejeitar Pagamento de Empr√©stimo\n     */\n    static async rejectPayment(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId } = body;\n\n            if (!transactionId) {\n                return c.json({ success: false, message: 'transactionId √© obrigat√≥rio' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const transactionResult = await client.query(\n                    'SELECT * FROM transactions WHERE id = $1 AND status = $2 FOR UPDATE',\n                    [transactionId, 'PENDING']\n                );\n\n                if (transactionResult.rows.length === 0) {\n                    throw new Error('Transa√ß√£o n√£o encontrada ou j√° processada');\n                }\n\n                const transaction = transactionResult.rows[0];\n\n                if (transaction.type !== 'LOAN_PAYMENT') {\n                    throw new Error('Transa√ß√£o n√£o √© um pagamento de empr√©stimo');\n                }\n\n                let metadata: any = {};\n                try {\n                    if (transaction.metadata && typeof transaction.metadata === 'object') {\n                        metadata = transaction.metadata;\n                    } else {\n                        const metadataStr = String(transaction.metadata || '{}').trim();\n                        if (metadataStr.startsWith('{') || metadataStr.startsWith('[')) {\n                            metadata = JSON.parse(metadataStr);\n                        }\n                    }\n                } catch (error) {\n                    console.error('Erro ao fazer parse do metadata (rejei√ß√£o):', error);\n                }\n\n                if (!metadata.loanId) {\n                    console.warn('Metadata n√£o cont√©m loanId, prosseguindo apenas com estorno da transa√ß√£o');\n                }\n\n                // Reembolsar o cliente se o pagamento foi feito com saldo\n                if (metadata.useBalance) {\n                    await updateUserBalance(client, transaction.user_id, parseFloat(transaction.amount), 'credit');\n                }\n\n                // Reativar o empr√©stimo para permitir novo pagamento\n                if (metadata.loanId) {\n                    await client.query(\n                        'UPDATE loans SET status = $1 WHERE id = $2',\n                        ['APPROVED', metadata.loanId]\n                    );\n                }\n\n                // Atualizar status da transa√ß√£o para REJEITADO\n                await updateTransactionStatus(client, transactionId, 'PENDING', 'REJECTED');\n\n                return {\n                    success: true,\n                    loanId: metadata.loanId,\n                    amountRefunded: metadata.useBalance ? parseFloat(transaction.amount) : 0\n                };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: 'Pagamento rejeitado! Empr√©stimo reativado para novo pagamento.',\n                data: result.data\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Aprovar Saque\n     */\n    static async approveWithdrawal(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId } = body;\n\n            if (!transactionId) return c.json({ success: false, message: 'transactionId √© obrigat√≥rio' }, 400);\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const transactionResult = await client.query(\n                    'SELECT * FROM transactions WHERE id = $1 AND status = $2 FOR UPDATE',\n                    [transactionId, 'PENDING']\n                );\n\n                if (transactionResult.rows.length === 0) throw new Error('Transa√ß√£o n√£o encontrada ou j√° processada');\n\n                // Reutiliza a l√≥gica centralizada de aprova√ß√£o (que j√° trata taxas, split, etc)\n                await processTransactionApproval(client, transactionId, 'APPROVE');\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Saque aprovado com sucesso! Valor l√≠quido deduzido e taxas distribu√≠das.',\n            });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Rejeitar Saque\n     */\n    static async rejectWithdrawal(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId } = body;\n\n            if (!transactionId) return c.json({ success: false, message: 'transactionId √© obrigat√≥rio' }, 400);\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const transactionResult = await client.query(\n                    'SELECT * FROM transactions WHERE id = $1 AND status = $2 FOR UPDATE',\n                    [transactionId, 'PENDING']\n                );\n\n                if (transactionResult.rows.length === 0) throw new Error('Transa√ß√£o n√£o encontrada ou j√° processada');\n\n                const transaction = transactionResult.rows[0];\n                if (transaction.type !== 'WITHDRAWAL') throw new Error('Transa√ß√£o n√£o √© um saque');\n\n                // Reembolsar saldo\n                await updateUserBalance(client, transaction.user_id, parseFloat(transaction.amount), 'credit');\n\n                // Rejeitar transa√ß√£o\n                await updateTransactionStatus(client, transactionId, 'PENDING', 'REJECTED');\n\n                return { success: true, amountRefunded: parseFloat(transaction.amount) };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Saque rejeitado! Valor reembolsado na conta do cliente.',\n                data: result.data\n            });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Liquidar empr√©stimo usando as cotas do usu√°rio como garantia (Exercer Garantia)\n     */\n    static async liquidateLoan(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { loanId } = body;\n\n            if (!loanId) {\n                return c.json({ success: false, message: 'ID do empr√©stimo √© obrigat√≥rio' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                // 1. Buscar empr√©stimo\n                const loanRes = await client.query('SELECT * FROM loans WHERE id = $1 FOR UPDATE', [loanId]);\n                if (loanRes.rows.length === 0) throw new Error('Empr√©stimo n√£o encontrado');\n                const loan = loanRes.rows[0];\n\n                if (loan.status === 'PAID') throw new Error('Empr√©stimo j√° est√° quitado');\n\n                // 2. Calcular quanto o usu√°rio deve (Total - j√° pago)\n                const paidRes = await client.query('SELECT COALESCE(SUM(amount), 0) as total FROM loan_installments WHERE loan_id = $1', [loanId]);\n                const debtAmount = parseFloat(loan.total_repayment) - parseFloat(paidRes.rows[0].total);\n\n                // 3. Buscar cotas ativas do usu√°rio para liquidar\n                const quotasRes = await client.query('SELECT id, current_value FROM quotas WHERE user_id = $1 AND status = $2 FOR UPDATE', [loan.user_id, 'ACTIVE']);\n                const userQuotas = quotasRes.rows;\n\n                let liquidatedValue = 0;\n                const quotasToLiquidate = [];\n\n                for (const q of userQuotas) {\n                    if (liquidatedValue < debtAmount) {\n                        liquidatedValue += parseFloat(q.current_value);\n                        quotasToLiquidate.push(q.id);\n                    }\n                }\n\n                if (liquidatedValue === 0) throw new Error('Usu√°rio n√£o possui cotas ativas para garantir a d√≠vida');\n\n                // 4. Executar a liquida√ß√£o\n                if (quotasToLiquidate.length > 0) {\n                    await client.query('DELETE FROM quotas WHERE id = ANY($1)', [quotasToLiquidate]);\n                }\n\n                await client.query('UPDATE system_config SET system_balance = system_balance + $1', [liquidatedValue]);\n\n                const newStatus = liquidatedValue >= debtAmount ? 'PAID' : loan.status;\n                await client.query('UPDATE loans SET status = $1 WHERE id = $2', [newStatus, loanId]);\n\n                const admin = c.get('user');\n                await client.query(\n                    `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                     VALUES ($1, 'SYSTEM_LIQUIDATION', $2, $3, 'APPROVED', $4)`,\n                    [\n                        loan.user_id,\n                        liquidatedValue,\n                        `Liquida√ß√£o for√ßada de ${quotasToLiquidate.length} cota(s) para quitar empr√©stimo ${loanId}`,\n                        JSON.stringify({ adminId: admin.id, loanId, quotasCount: quotasToLiquidate.length })\n                    ]\n                );\n\n                return { success: true, liquidatedValue, isFullyPaid: newStatus === 'PAID' };\n            });\n\n            return c.json(result);\n        } catch (error: any) {\n            console.error('Erro ao liquidar empr√©stimo:', error);\n            return c.json({ success: false, message: error.message || 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * For√ßar Liquida√ß√£o Autom√°tica\n     */\n    static async runLiquidation(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await runAutoLiquidation(pool);\n            return c.json({\n                success: true,\n                message: `Varredura conclu√≠da. ${result.liquidatedCount} garantias executadas.`,\n                data: result\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.audit.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1207,1210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1207,1210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3031,3034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3031,3034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport class AdminAuditController {\n    /**\n     * Listar todos os logs de auditoria\n     */\n    static async getLogs(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n\n            // Verifica√ß√£o S√™nior: Apenas admins podem ver logs\n            if (!user.isAdmin) {\n                return c.json({ success: false, message: 'Acesso negado.' }, 403);\n            }\n\n            const pool = getDbPool(c);\n\n            // Buscar logs vinculando com o nome do usu√°rio para facilitar a leitura\n            const result = await pool.query(`\n                SELECT \n                    al.*, \n                    u.name as user_name,\n                    u.email as user_email\n                FROM audit_logs al\n                LEFT JOIN users u ON al.user_id::integer = u.id\n                ORDER BY al.created_at DESC\n                LIMIT 100\n            `);\n\n            return c.json({\n                success: true,\n                logs: result.rows\n            });\n        } catch (error: any) {\n            console.error('Erro ao buscar logs de auditoria:', error);\n            return c.json({\n                success: false,\n                message: 'Erro interno ao carregar auditoria.'\n            }, 500);\n        }\n    }\n\n    /**\n     * Exportar logs de auditoria para CSV\n     */\n    static async exportLogs(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            const pool = getDbPool(c);\n            const result = await pool.query(`\n                SELECT \n                    al.created_at, u.name as user_name, al.action, al.entity_type, al.entity_id, al.ip_address, al.new_values\n                FROM audit_logs al\n                LEFT JOIN users u ON al.user_id::integer = u.id\n                ORDER BY al.created_at DESC\n                LIMIT 1000\n            `);\n\n            // Gerar CSV manual (Leve e R√°pido)\n            let csv = 'Data/Hora,Usuario,Acao,Entidade,ID,IP,Dados\\n';\n            for (const row of result.rows) {\n                const date = new Date(row.created_at).toLocaleString('pt-BR');\n                const userName = row.user_name || 'Sistema';\n                const action = row.action;\n                const entity = row.entity_type || '';\n                const id = row.entity_id || '';\n                const ip = row.ip_address || '';\n                const data = JSON.stringify(row.new_values).replace(/\"/g, '\"\"');\n\n                csv += `\"${date}\",\"${userName}\",\"${action}\",\"${entity}\",\"${id}\",\"${ip}\",\"${data}\"\\n`;\n            }\n\n            c.header('Content-Type', 'text/csv');\n            c.header('Content-Disposition', 'attachment; filename=auditoria_cred30.csv');\n\n            return c.body(csv);\n        } catch (error: any) {\n            console.error('Erro ao exportar logs:', error);\n            return c.json({ success: false, message: 'Erro ao gerar exporta√ß√£o.' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.compliance.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[736,739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[736,739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":55,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2190,2193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2190,2193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2842,2845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2842,2845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\nexport class AdminComplianceController {\n    /**\n     * Lista todos os aceites de termos (Audit Trail para fiscais)\n     */\n    static async listTermsAcceptances(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query(`\n                SELECT ta.*, u.name as user_name, u.email as user_email\n                FROM terms_acceptance ta\n                JOIN users u ON ta.user_id = u.id\n                ORDER BY ta.accepted_at DESC\n                LIMIT 100\n            `);\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('Erro ao listar aceites de termos:', error);\n            return c.json({ success: false, message: 'Erro ao buscar registros de compliance' }, 500);\n        }\n    }\n\n    /**\n     * Gera um resumo de sa√∫de jur√≠dica (Blindagem)\n     */\n    static async getComplianceStats(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            // Total de usu√°rios com termos aceitos na vers√£o atual\n            const currentTermsVersion = '2.0';\n            const stats = await pool.query(`\n                SELECT \n                    (SELECT COUNT(*) FROM users) as total_users,\n                    (SELECT COUNT(*) FROM terms_acceptance WHERE terms_version = $1) as users_with_current_terms\n                FROM dual -- Simplifica√ß√£o, pode variar conforme DB\n            `, [currentTermsVersion]).catch(async () => {\n                // Fallback para PostgreSQL sem dual\n                return pool.query(`\n                    SELECT \n                        (SELECT COUNT(*) FROM users) as total_users,\n                        (SELECT COUNT(*) FROM terms_acceptance WHERE terms_version = $1) as users_with_current_terms\n                `, [currentTermsVersion]);\n            });\n\n            return c.json({\n                success: true,\n                data: {\n                    termsVersion: currentTermsVersion,\n                    ...stats.rows[0]\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao gerar estat√≠sticas de compliance' }, 500);\n        }\n    }\n\n    /**\n     * Lista usu√°rios pendentes de KYC\n     */\n    static async listPendingKyc(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query(`\n                SELECT id, name, email, cpf, phone, kyc_status, kyc_document_path, created_at, kyc_notes\n                FROM users \n                WHERE kyc_status = 'PENDING'\n                ORDER BY created_at ASC\n            `);\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('Erro ao listar pend√™ncias KYC:', error);\n            return c.json({ success: false, message: 'Erro ao buscar pend√™ncias' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.finance.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'processTransactionApproval' is defined but never used.","line":6,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":58,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"processTransactionApproval"},"fix":{"range":[462,490],"text":""},"desc":"Remove unused variable \"processTransactionApproval\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PoolClient' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":20,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"PoolClient"},"fix":{"range":[702,735],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":10,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":15,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"fs"},"fix":{"range":[735,761],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":11,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":17,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"path"},"fix":{"range":[761,791],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1489,1492],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1489,1492],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2206,2209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2206,2209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2856,2859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2856,2859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7358,7361],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7358,7361],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8768,8771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8768,8771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refresh' is assigned a value but never used.","line":209,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":209,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cachedData' is assigned a value but never used.","line":216,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":216,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":533,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24447,24450],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24447,24450],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":568,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":568,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25874,25877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25874,25877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":586,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":586,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26537,26540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26537,26540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":758,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":758,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34790,34793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34790,34793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod'; // Import zod here as schemas will be moved or redefined\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { CacheService, addCacheHeaders } from '../../../infrastructure/cache/memory-cache.service';\nimport { QUOTA_PRICE, QUOTA_SHARE_VALUE, LOGISTICS_SUSTAINABILITY_FEE_RATE } from '../../../shared/constants/business.constants';\nimport { executeInTransaction, processTransactionApproval } from '../../../domain/services/transaction.service';\nimport { distributeProfits } from '../../../application/services/profit-distribution.service';\n// Removido: import mercadopago.service (gateway desativado)\nimport { PoolClient } from 'pg';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Schemas (Moved from router)\nexport const createCostSchema = z.object({\n    description: z.string().min(3),\n    amount: z.number().positive(),\n    isRecurring: z.boolean().default(true),\n    category: z.enum(['FISCAL', 'OPERATIONAL', 'MIXED']).default('MIXED'),\n});\n\n// Schema simulateMpSchema removido (gateway desativado)\n\nexport class AdminFinanceController {\n\n    /**\n     * Listar custos do sistema\n     */\n    static async listCosts(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query('SELECT * FROM system_costs ORDER BY created_at DESC');\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Adicionar custo do sistema\n     */\n    static async addCost(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { description, amount, isRecurring, category } = createCostSchema.parse(body);\n            const pool = getDbPool(c);\n\n            await pool.query(\n                'INSERT INTO system_costs (description, amount, is_recurring, category) VALUES ($1, $2, $3, $4)',\n                [description, amount, isRecurring, category]\n            );\n\n            return c.json({ success: true, message: 'Custo adicionado com sucesso' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Remover custo do sistema\n     */\n    static async deleteCost(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const result = await pool.query('DELETE FROM system_costs WHERE id = $1 RETURNING id', [id]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Custo n√£o encontrado' }, 404);\n            }\n\n            return c.json({ success: true, message: 'Custo removido com sucesso' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Pagar custo do sistema\n     */\n    static async payCost(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                // 1. Buscar o custo\n                const costRes = await client.query('SELECT description, amount, category FROM system_costs WHERE id = $1', [id]);\n                if (costRes.rows.length === 0) {\n                    throw new Error('Custo n√£o encontrado');\n                }\n                const cost = costRes.rows[0];\n                const amount = parseFloat(cost.amount);\n                const category = cost.category || 'MIXED';\n\n                // 2. Buscar configura√ß√µes e reservas\n                const configRes = await client.query('SELECT system_balance, total_tax_reserve, total_operational_reserve FROM system_config LIMIT 1');\n                const config = configRes.rows[0];\n                const currentBalance = parseFloat(config.system_balance);\n                const taxReserve = parseFloat(config.total_tax_reserve);\n                const operationalReserve = parseFloat(config.total_operational_reserve);\n\n                if (currentBalance < amount) {\n                    throw new Error('Saldo GLOBAL do sistema insuficiente para realizar este pagamento.');\n                }\n\n                // 3. Calcular a dedu√ß√£o por categoria e VALIDAR SALDO DO POTE\n                let taxShare = 0;\n                let operationalShare = 0;\n\n                if (category === 'FISCAL') {\n                    if (taxReserve < amount) {\n                        throw new Error(`SALDO INSUFICIENTE: O pote de IMPOSTOS (R$ ${taxReserve.toFixed(2)}) n√£o tem saldo para cobrir este custo de R$ ${amount.toFixed(2)}. Arrecade mais taxas antes de pagar.`);\n                    }\n                    taxShare = amount;\n                } else if (category === 'OPERATIONAL') {\n                    if (operationalReserve < amount) {\n                        throw new Error(`SALDO INSUFICIENTE: O pote OPERACIONAL (R$ ${operationalReserve.toFixed(2)}) n√£o tem saldo para cobrir este custo de R$ ${amount.toFixed(2)}. O sistema precisa gerar mais receita operacional.`);\n                    }\n                    operationalShare = amount;\n                } else {\n                    // MIXED (50/50)\n                    taxShare = amount * 0.50;\n                    operationalShare = amount - taxShare;\n\n                    if (taxReserve < taxShare || operationalReserve < operationalShare) {\n                        throw new Error(`SALDO INSUFICIENTE: Os potes (Fiscal: R$ ${taxReserve.toFixed(2)} | Operacional: R$ ${operationalReserve.toFixed(2)}) n√£o possuem saldo para a divis√£o 50/50 deste custo.`);\n                    }\n                }\n\n                // --- PROTE√á√ÉO DO CAPITAL SOCIAL (LASTRO) ---\n                const activeQuotasResult = await client.query(`SELECT COUNT(*) as count FROM quotas WHERE status = 'ACTIVE'`);\n                const activeQuotasCount = parseInt(activeQuotasResult.rows[0].count);\n                const capitalSocialExigivel = activeQuotasCount * QUOTA_SHARE_VALUE;\n\n                const saldoPosPagamento = currentBalance - amount;\n\n                if (saldoPosPagamento < capitalSocialExigivel) {\n                    throw new Error(`Risco de Insolv√™ncia. Saldo restante (R$ ${saldoPosPagamento.toFixed(2)}) seria menor que o Capital Social (R$ ${capitalSocialExigivel.toFixed(2)}).`);\n                }\n\n                // 4. Executar o desconto nos potes espec√≠ficos\n                await client.query(\n                    'UPDATE system_config SET system_balance = system_balance - $1, total_tax_reserve = total_tax_reserve - $2, total_operational_reserve = total_operational_reserve - $3',\n                    [amount, taxShare, operationalShare]\n                );\n\n                // 3. Remover o custo (como solicitado: \"as d√≠vidas somem\")\n                await client.query('DELETE FROM system_costs WHERE id = $1', [id]);\n\n                return { description: cost.description, amount: amount };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({ success: true, message: `Pagamento de \"${result.data?.description}\" realizado com sucesso!` });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Hist√≥rico Financeiro do Admin\n     */\n    static async getFinanceHistory(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { limit, offset } = c.req.query();\n            const limitNum = parseInt(limit || '50');\n            const offsetNum = parseInt(offset || '0');\n\n            const baseFilter = `WHERE action IN ('MANUAL_PROFIT_ADD', 'PAY_COST', 'ADD_COST', 'DELETE_COST', 'MANUAL_ADD_QUOTA')`;\n\n            // Buscar total\n            const totalResult = await pool.query(`SELECT COUNT(*) FROM admin_logs ${baseFilter}`);\n            const total = parseInt(totalResult.rows[0].count);\n\n            // Buscar logs paginados\n            const result = await pool.query(`\n        SELECT l.*, u.name as admin_name \n        FROM admin_logs l\n        LEFT JOIN users u ON l.admin_id = u.id\n        ${baseFilter}\n        ORDER BY l.created_at DESC\n        LIMIT $1 OFFSET $2\n      `, [limitNum, offsetNum]);\n\n            return c.json({\n                success: true,\n                data: result.rows,\n                pagination: {\n                    total,\n                    limit: limitNum,\n                    offset: offsetNum,\n                    hasMore: offsetNum + result.rows.length < total\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Painel Administrativo (Dashboard)\n     */\n    static async getDashboard(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const refresh = c.req.query('refresh') === 'true';\n\n            // FOR√áAR CACHE OFF (DEBUG)\n            console.error('üîß [DEBUG] Invalidando cache SEMPRE...');\n            CacheService.invalidateAdminDashboard();\n\n            // NUNCA usar cache (tempor√°rio)\n            const cachedData = null;\n\n            // Buscar configura√ß√µes do sistema\n            const configResult = await pool.query('SELECT * FROM system_config LIMIT 1');\n            let config = configResult.rows[0] || null;\n\n            if (!config) {\n                // Criar configura√ß√£o padr√£o se n√£o existir\n                await pool.query(`\n          INSERT INTO system_config (system_balance, profit_pool, quota_price, loan_interest_rate, penalty_rate, vesting_period_ms)\n          VALUES (0, 0, $1, 0.2, 0.4, $2)\n        `, [QUOTA_PRICE, 365 * 24 * 60 * 60 * 1000]);\n\n                const newConfigResult = await pool.query('SELECT * FROM system_config LIMIT 1');\n                config = newConfigResult.rows[0];\n            }\n\n            // Calcular caixa operacional\n            const activeQuotasResult = await pool.query(\n                `SELECT COUNT(*) as count FROM quotas WHERE status = 'ACTIVE'`\n            );\n            const quotasCountCache = parseInt(activeQuotasResult.rows[0].count);\n            const totalQuotasValue = quotasCountCache * QUOTA_PRICE;\n\n            const totalLoanedResult = await pool.query(\n                `SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) as total_loaned\n                 FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING', 'ACTIVE')`\n            );\n            const totalLoaned = parseFloat(totalLoanedResult.rows[0].total_loaned);\n            const operationalCash = totalQuotasValue - totalLoaned;\n\n            // Converter valores num√©ricos\n            config.system_balance = parseFloat(String(config.system_balance || 0));\n            config.profit_pool = parseFloat(String(config.profit_pool || 0));\n            config.quota_price = parseFloat(String(config.quota_price || 0));\n            config.total_gateway_costs = parseFloat(String(config.total_gateway_costs || 0));\n            config.total_manual_costs = parseFloat(String(config.total_manual_costs || 0));\n            config.total_tax_reserve = parseFloat(String(config.total_tax_reserve || 0));\n            config.total_operational_reserve = parseFloat(String(config.total_operational_reserve || 0));\n            config.total_owner_profit = parseFloat(String(config.total_owner_profit || 0));\n            config.investment_reserve = parseFloat(String(config.investment_reserve || 0));\n            config.mutual_reserve = parseFloat(String(config.mutual_reserve || 0));\n            config.total_corporate_investment_reserve = parseFloat(String(config.total_corporate_investment_reserve || 0));\n            config.credit_guarantee_fund = parseFloat(String(config.credit_guarantee_fund || 0));\n            config.courier_price_per_km = parseFloat(String(config.courier_price_per_km || '2.50'));\n\n            const statsResult = await pool.query(`\n        SELECT \n          (SELECT COUNT(*) FROM users) as users_count,\n          (SELECT COALESCE(SUM(CAST(balance AS NUMERIC)), 0) FROM users) as total_user_balances,\n          (SELECT COUNT(*) FROM quotas WHERE status = 'ACTIVE') as quotas_count,\n          (SELECT COUNT(*) FROM loans WHERE status IN ('PENDING', 'APPROVED', 'PAYMENT_PENDING')) as active_loans_count,\n          (SELECT COALESCE(SUM(CAST(total_repayment AS NUMERIC)), 0) FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING')) as total_to_receive,\n          (SELECT COALESCE(SUM(amount), 0) FROM system_costs) as total_monthly_costs,\n          (SELECT COUNT(*) FROM governance_proposals WHERE status = 'active') as active_proposals_count,\n          (SELECT COUNT(*) FROM users WHERE is_protected = TRUE) as protected_users_count\n      `);\n\n            const stats = statsResult.rows[0];\n            const usersCount = parseInt(stats.users_count);\n            const totalUserBalances = parseFloat(stats.total_user_balances);\n            const quotasCount = parseInt(stats.quotas_count);\n            const activeLoansCount = parseInt(stats.active_loans_count);\n            const totalToReceive = parseFloat(stats.total_to_receive);\n            const totalMonthlyCosts = parseFloat(stats.total_monthly_costs);\n            const activeProposalsCount = parseInt(stats.active_proposals_count || 0);\n\n            const totalInvestedRes = await pool.query(`SELECT COALESCE(SUM(total_invested), 0) as total FROM investments WHERE status = 'ACTIVE'`);\n            const totalInvestedValue = parseFloat(totalInvestedRes.rows[0].total);\n\n            // F√ìRMULA FINAL JOSIAS: Liquidez Real = (Cotas √ó 42) - Empr√©stimos - Investimentos Ativos\n            const activeQuotasCount = Number(stats.quotas_count || 0);\n            const totalCapitalSocial = activeQuotasCount * QUOTA_SHARE_VALUE; // R$ 42 por cota\n            const totalEmprestimos = Number(totalLoaned || 0);\n\n            config.real_liquidity = totalCapitalSocial - totalEmprestimos - totalInvestedValue;\n\n            // LOG DE DEBUG\n            console.error('üîç [LIQUIDEZ] Cotas:', activeQuotasCount, '√ó R$ 42 = R$', totalCapitalSocial);\n            console.error('üîç [LIQUIDEZ] Empr√©stimos: R$', totalEmprestimos);\n            console.error('üîç [LIQUIDEZ] Investimentos Ativos: R$', totalInvestedValue);\n            console.error('üîç [LIQUIDEZ] RESULTADO FINAL:', config.real_liquidity);\n\n            // Manter total_reserves para compatibilidade\n            const calcTax = Number(config.total_tax_reserve || 0);\n            const calcOper = Number(config.total_operational_reserve || 0);\n            const calcProfit = Number(config.total_owner_profit || 0);\n            const calcMutual = Number(config.mutual_reserve || 0);\n            const calcInvest = Number(config.investment_reserve || 0);\n            const calcCorp = Number(config.total_corporate_investment_reserve || 0);\n            const calcGfc = Number(config.credit_guarantee_fund || 0);\n            const calcCosts = Number(totalMonthlyCosts || 0);\n            const calcUsers = Number(totalUserBalances || 0);\n            config.total_reserves = calcTax + calcOper + calcProfit + calcMutual + calcInvest + calcCorp + calcGfc + calcCosts + calcUsers;\n            config.total_user_balances = totalUserBalances;\n            config.theoretical_cash = operationalCash;\n            config.monthly_fixed_costs = totalMonthlyCosts;\n\n            const dashboardData = {\n                systemConfig: config,\n                stats: {\n                    usersCount,\n                    quotasCount,\n                    activeLoansCount,\n                    totalLoaned,\n                    totalToReceive,\n                    activeProposalsCount,\n                    protectedUsersCount: parseInt(stats.protected_users_count || 0)\n                },\n            };\n\n            // LOG GIGANTE PARA O JOSIAS VER\n            console.error('\\n\\n========================================');\n            console.error('üö®üö®üö® RETORNANDO LIQUIDEZ PARA O FRONTEND üö®üö®üö®');\n            console.error('========================================');\n            console.error('VALOR DA LIQUIDEZ:', config.real_liquidity);\n            console.error('========================================\\n\\n');\n\n            // Salvar no cache\n            CacheService.setAdminDashboard(dashboardData);\n            addCacheHeaders(c, false, 120000);\n\n            return c.json({\n                success: true,\n                data: dashboardData,\n            });\n        } catch (error) {\n            console.error('Erro ao carregar dashboard administrativo:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    static async getHealthMetrics(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const start = Date.now();\n\n            await pool.query('SELECT 1');\n            const dbLatency = Date.now() - start;\n\n            const statsResult = await pool.query(`\n        SELECT \n          (SELECT COUNT(*) FROM users) as total_users,\n          (SELECT COUNT(*) FROM transactions) as total_transactions,\n          (SELECT COUNT(*) FROM quotas) as total_quotas,\n          (SELECT COUNT(*) FROM loans) as total_loans,\n          (SELECT COUNT(*) FROM admin_logs) as total_admin_logs,\n          (SELECT COUNT(*) FROM system_costs) as total_system_costs,\n          (SELECT COUNT(*) FROM users WHERE created_at > NOW() - INTERVAL '24 hours') as new_users_24h,\n          (SELECT COUNT(*) FROM transactions WHERE created_at > NOW() - INTERVAL '24 hours') as trans_24h,\n          (SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE created_at > NOW() - INTERVAL '24 hours' AND status = 'APPROVED') as volume_24h,\n          (SELECT COUNT(*) FROM loans WHERE status = 'PENDING') as pending_loans_count,\n          (SELECT COALESCE(SUM(amount), 0) FROM loans WHERE status = 'PENDING') as pending_loans_volume\n      `);\n\n            const stats = statsResult.rows[0];\n            const memoryUsage = process.memoryUsage();\n            const uptime = process.uptime();\n\n            return c.json({\n                success: true,\n                data: {\n                    health: {\n                        status: 'HEALTHY',\n                        dbLatency: `${dbLatency}ms`,\n                        uptime: `${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m`,\n                        memory: {\n                            heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,\n                            heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,\n                            rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`\n                        }\n                    },\n                    database: {\n                        total_users: stats.total_users,\n                        total_transactions: stats.total_transactions,\n                        total_quotas: stats.total_quotas,\n                        total_loans: stats.total_loans,\n                        total_admin_logs: stats.total_admin_logs,\n                        total_system_costs: stats.total_system_costs\n                    },\n                    activity: {\n                        new_users_24h: stats.new_users_24h,\n                        trans_24h: stats.trans_24h,\n                        volume_24h: stats.volume_24h\n                    },\n                    queue: {\n                        pending_loans_count: stats.pending_loans_count,\n                        pending_loans_volume: stats.pending_loans_volume\n                    },\n                    timestamp: new Date().toISOString()\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao buscar m√©tricas de sa√∫de:', error);\n            return c.json({ success: false, message: 'Erro ao coletar m√©tricas' }, 500);\n        }\n    }\n\n    static async systemBalanceInfo(c: Context) {\n        return c.json({\n            success: false,\n            message: 'Caixa operacional agora √© calculado automaticamente baseado nas cotas ATIVAS e empr√©stimos ativos.',\n            info: 'Valor = (Total de cotas ATIVAS √ó R$ 50) - (Total emprestado)'\n        }, 400);\n    }\n\n    static async addProfitPool(c: Context) {\n        try {\n            const body = await c.req.json();\n            let amountToAdd: number | undefined = undefined;\n\n            if (body.amountToAdd !== undefined) {\n                amountToAdd = parseFloat(body.amountToAdd);\n            } else if (body.amount !== undefined) {\n                amountToAdd = parseFloat(body.amount);\n            }\n\n            const amountVal = amountToAdd as number;\n            if (amountVal === undefined || isNaN(amountVal)) {\n                return c.json({ success: false, message: 'Valor inv√°lido' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            await executeInTransaction(pool, async (client) => {\n                await client.query(\n                    'UPDATE system_config SET profit_pool = profit_pool + $1, system_balance = system_balance + $1',\n                    [amountVal]\n                );\n\n                const user = c.get('user');\n                await client.query(\n                    `INSERT INTO admin_logs (admin_id, action, entity_type, new_values, created_at)\n             VALUES ($1, 'MANUAL_PROFIT_ADD', 'SYSTEM_CONFIG', $2, $3)`,\n                    [\n                        user.id,\n                        JSON.stringify({ addedAmount: amountVal }),\n                        new Date()\n                    ]\n                );\n            });\n\n            // Limpar cache para atualiza√ß√£o imediata\n            CacheService.invalidateAdminDashboard();\n\n            return c.json({\n                success: true,\n                message: `R$ ${amountVal.toFixed(2)} adicionado ao acumulado e ao saldo do sistema!`,\n                data: { addedAmount: amountVal }\n            });\n        } catch (error) {\n            console.error('Erro ao adicionar lucro ao pool:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Distribuir dividendos\n     */\n    static async distributeDividends(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await distributeProfits(pool);\n\n            if (result.success) {\n                CacheService.invalidateAdminDashboard();\n            }\n\n            if (!result.success) {\n                return c.json(result, 400);\n            }\n\n            return c.json(result);\n        } catch (error) {\n            console.error('Erro ao distribuir dividendos:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    // Fun√ß√£o simulatePayment removida (gateway Mercado Pago desativado)\n\n    /**\n     * Registrar Custo Manual (Despesa)\n     */\n    static async addManualCost(c: Context) {\n        try {\n            const body = await c.req.json();\n            const amount = parseFloat(body.amount);\n\n            if (isNaN(amount) || amount <= 0) {\n                return c.json({ success: false, message: 'Valor inv√°lido' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            await executeInTransaction(pool, async (client) => {\n                await client.query(\n                    'UPDATE system_config SET system_balance = system_balance - $1, total_manual_costs = total_manual_costs + $1',\n                    [amount]\n                );\n\n                const user = c.get('user');\n                await client.query(\n                    `INSERT INTO admin_logs (admin_id, action, entity_type, new_values, created_at)\n                     VALUES ($1, 'MANUAL_COST_ADD', 'SYSTEM_CONFIG', $2, $3)`,\n                    [user.id, JSON.stringify({ addedCost: amount, description: body.description || 'Custo manual' }), new Date()]\n                );\n            });\n\n            // Limpar cache para atualiza√ß√£o imediata\n            CacheService.invalidateAdminDashboard();\n\n            return c.json({\n                success: true,\n                message: `Custo de R$ ${amount.toFixed(2)} registrado com sucesso e deduzido do caixa operacional.`,\n                data: { addedCost: amount }\n            });\n        } catch (error: any) {\n            console.error('Erro ao adicionar custo manual:', error);\n            return c.json({ success: false, message: error.message || 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar Configura√ß√µes Gerais do Sistema\n     */\n    static async updateConfig(c: Context) {\n        try {\n            const body = await c.req.json();\n            const pool = getDbPool(c);\n\n            // Filtrar apenas campos permitidos para atualiza√ß√£o via este endpoint\n            const allowedFields = ['courier_price_per_km', 'quota_price', 'loan_interest_rate', 'penalty_rate'];\n            const updates = Object.keys(body).filter(key => allowedFields.includes(key));\n\n            if (updates.length === 0) {\n                return c.json({ success: false, message: 'Nenhum campo v√°lido para atualiza√ß√£o' }, 400);\n            }\n\n            const setClause = updates.map((key, i) => `${key} = $${i + 1}`).join(', ');\n            const values = updates.map(key => body[key]);\n\n            await pool.query(`UPDATE system_config SET ${setClause}, updated_at = NOW()`, values);\n\n            // Limpar cache do dashboard para refletir as mudan√ßas\n            CacheService.invalidateAdminDashboard();\n\n            return c.json({\n                success: true,\n                message: 'Configura√ß√µes atualizadas com sucesso!',\n                updatedFields: updates\n            });\n        } catch (error: any) {\n            console.error('Erro ao atualizar configura√ß√µes:', error);\n            return c.json({ success: false, message: error.message || 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Relat√≥rio Fiscal (Auditoria para Declara√ß√£o de Impostos)\n     * Separa Receita Bruta (Taxas) de Movimenta√ß√£o de Terceiros (Cust√≥dia)\n     */\n    static async getFiscalReport(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const month = c.req.query('month');\n            const year = c.req.query('year');\n            const isAllTime = month === '0' || !month;\n\n            let dateFilter = '';\n            let params: any[] = [];\n\n            if (!isAllTime) {\n                const startDate = `${year}-${String(month).padStart(2, '0')}-01 00:00:00`;\n                const endDate = new Date(Number(year), Number(month), 0).toISOString().split('T')[0] + ' 23:59:59';\n                dateFilter = `AND created_at BETWEEN $1 AND $2`;\n                params = [startDate, endDate];\n            }\n\n            // 1. Entradas Totais (Gross Inflow) - Dinheiro NOVO entrando\n            // Apenas Dep√≥sitos e Pagamentos via PIX externo.\n            // Uso de saldo (Circular) N√ÉO deve somar aqui para evitar duplicidade.\n            const inflowRes = await pool.query(`\n                SELECT COALESCE(SUM(ABS(amount)), 0) as total_inflow\n                FROM transactions \n                WHERE status = 'APPROVED' \n                AND (\n                    type = 'DEPOSIT' \n                    OR (type = 'BUY_QUOTA' AND metadata->>'paymentMethod' = 'pix')\n                    OR (type = 'ORDER_PAYMENT' AND metadata->>'paymentMethod' = 'pix')\n                )\n                ${dateFilter}\n            `, params);\n\n            // 2. Sa√≠das Totais (Gross Outflow) - Dinheiro SAINDO do sistema\n            // Saques processados\n            const outflowRes = await pool.query(`\n                SELECT COALESCE(SUM(ABS(amount)), 0) as total_outflow\n                FROM transactions\n                WHERE status IN ('APPROVED', 'COMPLETED', 'PAID')\n                AND type IN ('WITHDRAWAL')\n                ${dateFilter}\n            `, params);\n\n            // 3. Distribui√ß√£o de Lucros (Dividends Paid)\n            const dividendsRes = await pool.query(`\n                SELECT COALESCE(SUM(amount), 0) as total_dividends\n                FROM transactions\n                WHERE status = 'APPROVED'\n                AND type = 'DIVIDEND'\n                ${dateFilter}\n            `, params);\n\n            // 4. Receita de Marketplace (Faturamento)\n            const marketplaceRes = await pool.query(`\n                SELECT COALESCE(SUM(fee_amount), 0) as marketplace_fees\n                FROM marketplace_orders\n                WHERE status != 'CANCELED'\n                ${dateFilter}\n            `, params);\n\n            // 5. Taxas Diretas (Faturamento)\n            const feesRes = await pool.query(`\n                SELECT COALESCE(SUM(amount), 0) as direct_fees\n                FROM transactions\n                WHERE type IN ('FEE', 'WITHDRAWAL_FEE', 'SERVICE_TAX')\n                AND status = 'APPROVED'\n                ${dateFilter}\n            `, params);\n\n            // 6. Lucro Log√≠stico (Faturamento)\n            const logisticsProfitRes = await pool.query(`\n                SELECT COALESCE(SUM(delivery_fee * ${LOGISTICS_SUSTAINABILITY_FEE_RATE}), 0) as logistics_profit\n                FROM marketplace_orders\n                WHERE delivery_status = 'DELIVERED'\n                ${dateFilter}\n            `, params);\n\n            // 8. Taxas de Cotas (SVA - Metadata serviceFee)\n            const quotaFeesRes = await pool.query(`\n                SELECT COALESCE(SUM(CAST(metadata ->> 'serviceFee' AS NUMERIC)), 0) as quota_fees\n                FROM transactions\n                WHERE type = 'BUY_QUOTA'\n                AND status = 'APPROVED'\n                ${dateFilter}\n            `, params);\n\n            // 9. Receita de Juros de Empr√©stimos (Metadata interestAmount)\n            const loanInterestRes = await pool.query(`\n            SELECT COALESCE(SUM(CAST(metadata ->> 'interestAmount' AS NUMERIC)), 0) as loan_revenue\n            FROM transactions\n            WHERE type = 'LOAN_PAYMENT'\n            AND status IN('COMPLETED', 'APPROVED')\n            ${dateFilter}\n        `, params);\n\n            // 10. Receita de Educa√ß√£o (Faturamento - 10% de comiss√£o)\n            const educationRevenueRes = await pool.query(`\n            SELECT COALESCE(SUM(amount_paid * 0.10), 0) as education_revenue\n            FROM course_purchases\n            WHERE 1=1\n            ${dateFilter}\n        `, params);\n\n            // 11. Receita de V√≠deos Promocionais (Faturamento - 65% de taxa de servi√ßo)\n            const promoVideosRevenueRes = await pool.query(`\n            SELECT COALESCE(SUM(ABS(amount) * 0.65), 0) as promo_revenue\n            FROM transactions\n            WHERE type = 'PROMO_VIDEO_BUDGET'\n            AND status = 'COMPLETED'\n            ${dateFilter}\n        `, params);\n\n            // 12. Receita de Monetiza√ß√£o (PRO, Badges, etc. - 20% de taxa)\n            const monetizationRevenueRes = await pool.query(`\n            SELECT COALESCE(SUM(ABS(amount) * 0.20), 0) as monetization_revenue\n            FROM transactions\n            WHERE type IN ('MEMBERSHIP_UPGRADE', 'PREMIUM_PURCHASE', 'REPUTATION_CONSULT', 'PROTECTION_PURCHASE')\n            AND status = 'APPROVED'\n            ${dateFilter}\n        `, params);\n\n            // 13. Caixa de Terceiros Real (Soma de todos os saldos de usu√°rios)\n            const custodyRes = await pool.query(`SELECT COALESCE(SUM(balance), 0) as total_custody FROM users`);\n            const totalCustody = parseFloat(custodyRes.rows[0].total_custody);\n\n            // 7. Configura√ß√µes Gerais\n            const configResult = await pool.query('SELECT profit_pool, total_owner_profit, system_balance FROM system_config LIMIT 1');\n            const config = configResult.rows[0] || {};\n\n            // C√°lculos Finais\n            const totalInflow = parseFloat(inflowRes.rows[0].total_inflow);\n            const totalOutflow = parseFloat(outflowRes.rows[0].total_outflow);\n            const totalDividends = parseFloat(dividendsRes.rows[0].total_dividends);\n\n            const revenueFromMarketplace = parseFloat(marketplaceRes.rows[0].marketplace_fees);\n            const revenueFromFees = parseFloat(feesRes.rows[0].direct_fees);\n            const revenueFromLogistics = parseFloat(logisticsProfitRes.rows[0].logistics_profit);\n            const revenueFromQuotas = parseFloat(quotaFeesRes.rows[0].quota_fees);\n            const revenueFromLoans = parseFloat(loanInterestRes.rows[0].loan_revenue);\n            const revenueFromEducation = parseFloat(educationRevenueRes.rows[0].education_revenue);\n            const revenueFromPromoVideos = parseFloat(promoVideosRevenueRes.rows[0].promo_revenue);\n            const revenueFromMonetization = parseFloat(monetizationRevenueRes.rows[0].monetization_revenue);\n\n            const grossRevenue = revenueFromMarketplace + revenueFromFees + revenueFromLogistics + revenueFromQuotas + revenueFromLoans + revenueFromEducation + revenueFromPromoVideos + revenueFromMonetization;\n            const netProfit = grossRevenue - totalDividends;\n\n            const fiscalSummary = {\n                period: isAllTime ? 'Hist√≥rico Completo' : `${month}/${year}`,\n\n                // Fluxo de Caixa\n                total_inflow: totalInflow,\n                total_outflow: totalOutflow,\n\n                // Resultado Econ√¥mico\n                gross_revenue: grossRevenue,\n                total_dividends: totalDividends,\n                net_profit: netProfit,\n\n                // Detalhamento\n                details: {\n                    marketplace_commissions: revenueFromMarketplace,\n                    logistics_margin: revenueFromLogistics,\n                    withdrawal_fees: revenueFromFees,\n                    quota_maintenance_fees: revenueFromQuotas,\n                    loan_interest_revenue: revenueFromLoans,\n                    education_revenue: revenueFromEducation,\n                    promo_videos_revenue: revenueFromPromoVideos,\n                    monetization_revenue: revenueFromMonetization,\n                    total_owner_profit: parseFloat(config.total_owner_profit || 0),\n                    system_balance: parseFloat(config.system_balance || 0),\n                    volume_transitory: totalCustody // Sincronizado com os saldos REAIS\n                },\n\n                legal_notice: \"Relat√≥rio de intermedia√ß√£o de neg√≥cios e gest√£o de cust√≥dia de terceiros (N√£o tribut√°vel sobre o capital social).\"\n            };\n\n            return c.json({\n                success: true,\n                data: fiscalSummary,\n                message: isAllTime ? \"Relat√≥rio consolidado.\" : \"Relat√≥rio mensal.\"\n            });\n        } catch (error: any) {\n            console.error('Erro ao gerar relat√≥rio fiscal:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.investments.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2539,2542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2539,2542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2549,2552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2549,2552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2668,2671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2668,2671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2678,2681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2678,2681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2817,2820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2817,2820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2827,2830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2827,2830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2949,2952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2949,2952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2959,2962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2959,2962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5641,5644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5641,5644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8778,8781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8778,8781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9491,9494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9491,9494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10386,10389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10386,10389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12024,12027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12024,12027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":321,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14086,14089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14086,14089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":349,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":349,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14962,14965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14962,14965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { QUOTA_SHARE_VALUE } from '../../../shared/constants/business.constants';\nimport { executeInTransaction } from '../../../domain/services/transaction.service';\n\n// Schema de valida√ß√£o\nconst investmentSchema = z.object({\n    assetName: z.string().min(2).max(100),\n    assetType: z.enum(['STOCK', 'FII', 'BOND', 'ETF', 'OTHER']),\n    quantity: z.number().positive().optional(),\n    unitPrice: z.number().positive(),\n    totalInvested: z.number().positive(),\n    broker: z.string().optional(),\n    notes: z.string().optional(),\n    investedAt: z.string().optional()\n});\n\nexport class AdminInvestmentsController {\n\n    /**\n     * Listar todos os investimentos (ativos e vendidos)\n     */\n    static async listInvestments(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const activeResult = await pool.query(`\n        SELECT * FROM investments WHERE status = 'ACTIVE' ORDER BY invested_at DESC\n      `);\n\n            const soldResult = await pool.query(`\n        SELECT * FROM investments WHERE status = 'SOLD' ORDER BY sold_at DESC\n      `);\n\n            const configResult = await pool.query('SELECT * FROM system_config LIMIT 1');\n            const config = configResult.rows[0] || {};\n\n            const statsRes = await pool.query(`\n                SELECT \n                    (SELECT COUNT(*) FROM quotas WHERE status = 'ACTIVE') as quotas_count,\n                    (SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING', 'ACTIVE')) as total_loaned\n            `);\n            const stats = statsRes.rows[0];\n\n            const totalInvestedRes = await pool.query(`SELECT COALESCE(SUM(total_invested), 0) as total FROM investments WHERE status = 'ACTIVE'`);\n            const totalInvestedValue = parseFloat(totalInvestedRes.rows[0].total);\n\n            // F√ìRMULA FINAL JOSIAS: Liquidez Real = (Cotas √ó 42) - Empr√©stimos - Investimentos\n            const activeQuotasCount = Number(stats.quotas_count || 0);\n            const totalCapitalSocial = activeQuotasCount * QUOTA_SHARE_VALUE;\n            const totalEmprestimos = Number(stats.total_loaned || 0);\n\n            const realLiquidity = totalCapitalSocial - totalEmprestimos - totalInvestedValue;\n\n            const availableReserve = parseFloat(config.investment_reserve || 0);\n            const totalInvested = activeResult.rows.reduce((acc: any, inv: any) => acc + parseFloat(inv.total_invested), 0);\n            const totalCurrentValue = activeResult.rows.reduce((acc: any, inv: any) => acc + parseFloat(inv.current_value || inv.total_invested), 0);\n\n            const activeDividends = activeResult.rows.reduce((acc: any, inv: any) => acc + parseFloat(inv.dividends_received || 0), 0);\n            const soldDividends = soldResult.rows.reduce((acc: any, inv: any) => acc + parseFloat(inv.dividends_received || 0), 0);\n            const totalDividends = activeDividends + soldDividends;\n\n            return c.json({\n                success: true,\n                data: {\n                    investments: activeResult.rows.map(inv => ({\n                        id: inv.id,\n                        assetName: inv.asset_name,\n                        assetType: inv.asset_type,\n                        quantity: parseFloat(inv.quantity) || 0,\n                        unitPrice: parseFloat(inv.unit_price),\n                        totalInvested: parseFloat(inv.total_invested),\n                        currentValue: parseFloat(inv.current_value || inv.total_invested),\n                        dividendsReceived: parseFloat(inv.dividends_received || 0),\n                        broker: inv.broker,\n                        notes: inv.notes,\n                        investedAt: inv.invested_at,\n                        status: inv.status,\n                        profitLoss: parseFloat(inv.current_value || inv.total_invested) - parseFloat(inv.total_invested),\n                        profitLossPercent: ((parseFloat(inv.current_value || inv.total_invested) / parseFloat(inv.total_invested)) - 1) * 100\n                    })),\n                    sold: soldResult.rows.map(inv => ({\n                        id: inv.id,\n                        assetName: inv.asset_name,\n                        assetType: inv.asset_type,\n                        quantity: parseFloat(inv.quantity) || 0,\n                        unitPrice: parseFloat(inv.unit_price),\n                        totalInvested: parseFloat(inv.total_invested),\n                        saleValue: parseFloat(inv.sale_value),\n                        soldAt: inv.sold_at,\n                        dividendsReceived: parseFloat(inv.dividends_received || 0),\n                        broker: inv.broker,\n                        status: inv.status,\n                        profitLoss: parseFloat(inv.sale_value) - parseFloat(inv.total_invested),\n                        profitLossPercent: ((parseFloat(inv.sale_value) / parseFloat(inv.total_invested)) - 1) * 100\n                    })),\n                    summary: {\n                        availableReserve,\n                        realLiquidity,\n                        totalInvested,\n                        totalCurrentValue,\n                        totalDividends,\n                        totalProfitLoss: totalCurrentValue - totalInvested,\n                        totalProfitLossPercent: totalInvested > 0 ? ((totalCurrentValue / totalInvested) - 1) * 100 : 0\n                    }\n                }\n            });\n        } catch (error: any) {\n            console.error('[INVESTMENTS] Erro ao listar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar novo investimento\n     */\n    static async createInvestment(c: Context) {\n        try {\n            const body = await c.req.json();\n            const data = investmentSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const statsRes = await client.query(`\n                    SELECT \n                        (SELECT COUNT(*) FROM quotas WHERE status = 'ACTIVE') as quotas_count,\n                        (SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING', 'ACTIVE')) as total_loaned,\n                        (SELECT COALESCE(SUM(total_invested), 0) FROM investments WHERE status = 'ACTIVE') as total_invested,\n                        (SELECT system_balance FROM system_config LIMIT 1) as system_balance\n                `);\n                const stats = statsRes.rows[0];\n                const realLiquidity = (Number(stats.quotas_count) * QUOTA_SHARE_VALUE) - Number(stats.total_loaned) - Number(stats.total_invested);\n                const systemBalance = parseFloat(stats.system_balance || 0);\n\n                if (data.totalInvested > realLiquidity) {\n                    throw new Error(`Saldo insuficiente na Liquidez Real. Dispon√≠vel: R$ ${realLiquidity.toFixed(2)}`);\n                }\n\n                if (data.totalInvested > systemBalance) {\n                    throw new Error(`Saldo insuficiente no caixa do sistema (PIX). Dispon√≠vel: R$ ${systemBalance.toFixed(2)}`);\n                }\n\n                // Debita do saldo do sistema (Caixa Real)\n                await client.query(\n                    'UPDATE system_config SET system_balance = system_balance - $1',\n                    [data.totalInvested]\n                );\n\n                const invResult = await client.query(`\n          INSERT INTO investments (asset_name, asset_type, quantity, unit_price, total_invested, current_value, broker, notes, invested_at)\n          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n          RETURNING id\n        `, [\n                    data.assetName,\n                    data.assetType,\n                    data.quantity || 0,\n                    data.unitPrice,\n                    data.totalInvested,\n                    data.totalInvested,\n                    data.broker || null,\n                    data.notes || null,\n                    data.investedAt ? new Date(data.investedAt) : new Date()\n                ]);\n\n                return { investmentId: invResult.rows[0].id };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `Investimento em ${data.assetName} registrado com sucesso!`,\n                data: { id: result.data?.investmentId }\n            });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            console.error('[INVESTMENTS] Erro ao criar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar valor atual do investimento\n     */\n    static async updateInvestment(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const body = await c.req.json();\n            const { currentValue, dividendsReceived } = body;\n            const pool = getDbPool(c);\n\n            const updates: string[] = [];\n            const values: any[] = [];\n            let paramIndex = 1;\n\n            if (currentValue !== undefined) {\n                updates.push(`current_value = $${paramIndex++}`);\n                values.push(currentValue);\n            }\n\n            if (dividendsReceived !== undefined) {\n                updates.push(`dividends_received = $${paramIndex++}`);\n                values.push(dividendsReceived);\n            }\n\n            if (updates.length === 0) {\n                return c.json({ success: false, message: 'Nenhum campo para atualizar' }, 400);\n            }\n\n            updates.push(`updated_at = NOW()`);\n            values.push(id);\n\n            await pool.query(\n                `UPDATE investments SET ${updates.join(', ')} WHERE id = $${paramIndex}`,\n                values\n            );\n\n            return c.json({ success: true, message: 'Investimento atualizado!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar dividendos recebidos\n     */\n    static async receiveDividends(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const body = await c.req.json();\n            const { amount, reinvest } = body;\n\n            if (!amount || amount <= 0) {\n                return c.json({ success: false, message: 'Valor do dividendo inv√°lido' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            await executeInTransaction(pool, async (client) => {\n                await client.query(\n                    'UPDATE investments SET dividends_received = dividends_received + $1, updated_at = NOW() WHERE id = $2',\n                    [amount, id]\n                );\n\n                if (reinvest) {\n                    await client.query(\n                        'UPDATE system_config SET system_balance = COALESCE(system_balance, 0) + $1',\n                        [amount]\n                    );\n                } else {\n                    await client.query(\n                        'UPDATE system_config SET system_balance = system_balance + $1, profit_pool = profit_pool + $2',\n                        [amount, amount * 0.5]\n                    );\n                }\n            });\n\n            return c.json({\n                success: true,\n                message: reinvest\n                    ? `Dividendos de R$ ${amount.toFixed(2)} reinvestidos!`\n                    : `Dividendos de R$ ${amount.toFixed(2)} creditados no sistema!`\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Vender/Liquidar investimento\n     */\n    static async sellInvestment(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const body = await c.req.json();\n            const { saleValue } = body;\n\n            if (!saleValue || saleValue <= 0) {\n                return c.json({ success: false, message: 'Valor de venda inv√°lido' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const invResult = await client.query('SELECT * FROM investments WHERE id = $1 FOR UPDATE', [id]);\n                if (invResult.rows.length === 0) {\n                    throw new Error('Investimento n√£o encontrado');\n                }\n\n                const investment = invResult.rows[0];\n                const totalInvested = parseFloat(investment.total_invested);\n                const profitLoss = saleValue - totalInvested;\n\n                await client.query(\n                    'UPDATE system_config SET system_balance = COALESCE(system_balance, 0) + $1',\n                    [saleValue]\n                );\n\n                await client.query(\n                    'UPDATE investments SET status = $1, sale_value = $2, sold_at = NOW(), updated_at = NOW() WHERE id = $3',\n                    ['SOLD', saleValue, id]\n                );\n\n                return { assetName: investment.asset_name, profitLoss };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            const msg = result.data!.profitLoss >= 0\n                ? `${result.data!.assetName} vendido com lucro de R$ ${result.data!.profitLoss.toFixed(2)}!`\n                : `${result.data!.assetName} vendido com preju√≠zo de R$ ${Math.abs(result.data!.profitLoss).toFixed(2)}.`;\n\n            return c.json({ success: true, message: msg });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Aporte manual na reserva de investimentos\n     */\n    static async addReserve(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { amount } = body;\n\n            if (!amount || amount <= 0) {\n                return c.json({ success: false, message: 'Valor inv√°lido para aporte' }, 400);\n            }\n\n            const pool = getDbPool(c);\n\n            await pool.query(\n                'UPDATE system_config SET system_balance = COALESCE(system_balance, 0) + $1, updated_at = NOW()',\n                [amount]\n            );\n\n            return c.json({\n                success: true,\n                message: `Aporte de R$ ${amount.toFixed(2)} registrado com sucesso na reserva!`\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.marketplace.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1464,1467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1464,1467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4501,4504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4501,4504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5527,5530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5527,5530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6113,6116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6113,6116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6680,6683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6680,6683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9861,9864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9861,9864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11537,11540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11537,11540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, updateUserBalance, createTransaction } from '../../../domain/services/transaction.service';\nimport { updateScore } from '../../../application/services/score.service';\n\n// Schema de valida√ß√£o\nconst resolveDisputeSchema = z.object({\n    orderId: z.number(),\n    resolution: z.enum(['REFUND_BUYER', 'RELEASE_TO_SELLER']),\n    penaltyUserId: z.number().optional(),\n});\n\nexport class AdminMarketplaceController {\n\n    /**\n     * Listar pedidos em disputa\n     */\n    static async listDisputes(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT \n                    o.*, \n                    l.title as listing_title, \n                    l.image_url as listing_image, \n                    ub.name as buyer_name, \n                    us.name as seller_name\n                FROM marketplace_orders o\n                JOIN marketplace_listings l ON o.listing_id = l.id\n                JOIN users ub ON o.buyer_id = ub.id\n                JOIN users us ON o.seller_id = us.id\n                WHERE o.status = 'DISPUTE'\n                ORDER BY o.disputed_at ASC\n            `);\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Resolver disputa de marketplace\n     */\n    static async resolveDispute(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { orderId, resolution, penaltyUserId } = resolveDisputeSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const orderRes = await pool.query('SELECT * FROM marketplace_orders WHERE id = $1 AND status = \\'DISPUTE\\'', [orderId]);\n            if (orderRes.rows.length === 0) return c.json({ success: false, message: 'Disputa n√£o encontrada.' }, 404);\n            const order = orderRes.rows[0];\n\n            await executeInTransaction(pool, async (client) => {\n                if (resolution === 'REFUND_BUYER') {\n                    await client.query('UPDATE marketplace_orders SET status = \\'CANCELLED\\', updated_at = NOW() WHERE id = $1', [orderId]);\n                    await client.query('UPDATE marketplace_listings SET status = \\'ACTIVE\\' WHERE id = $1', [order.listing_id]);\n\n                    if (order.payment_method === 'BALANCE') {\n                        await updateUserBalance(client, order.buyer_id, parseFloat(order.amount), 'credit');\n                        await createTransaction(client, order.buyer_id, 'MARKET_REFUND', parseFloat(order.amount), `Disputa Resolvida: Estorno do Pedido #${orderId}`, 'APPROVED');\n                    } else if (order.payment_method === 'CRED30_CREDIT') {\n                        await client.query(\"UPDATE loans SET status = 'CANCELLED' WHERE status = 'APPROVED' AND metadata->>'orderId' = $1\", [orderId.toString()]);\n                    }\n                } else {\n                    await client.query('UPDATE marketplace_orders SET status = \\'COMPLETED\\', updated_at = NOW() WHERE id = $1', [orderId]);\n\n                    const sellerAmount = parseFloat(order.seller_amount);\n                    if (order.payment_method === 'CRED30_CREDIT') {\n                        await client.query('UPDATE system_config SET system_balance = system_balance - $1', [order.amount]);\n                    }\n                    await updateUserBalance(client, order.seller_id, sellerAmount, 'credit');\n\n                    const feeAmount = parseFloat(order.fee_amount);\n                    await client.query('UPDATE system_config SET system_balance = system_balance + $1, profit_pool = profit_pool + $2', [feeAmount * 0.85, feeAmount * 0.15]);\n\n                    await createTransaction(client, order.seller_id, 'MARKET_SALE', sellerAmount, `Disputa Resolvida: Venda #${orderId} Liberada`, 'APPROVED', { orderId });\n                }\n\n                if (penaltyUserId) {\n                    await updateScore(client, penaltyUserId, -100, `Penalidade: M√° f√© em disputa de marketplace (#${orderId})`);\n                }\n\n                return { success: true };\n            });\n\n            return c.json({ success: true, message: `Disputa resolvida: ${resolution}` });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar todas as avalia√ß√µes/reviews\n     */\n    static async listReviews(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT \n          r.id,\n          r.transaction_id,\n          r.rating,\n          r.comment,\n          r.is_public,\n          r.is_approved,\n          r.created_at,\n          u.name as user_name,\n          u.email as user_email,\n          t.amount as transaction_amount\n        FROM transaction_reviews r\n        JOIN users u ON r.user_id = u.id\n        JOIN transactions t ON r.transaction_id = t.id\n        ORDER BY r.created_at DESC\n      `);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(row => ({\n                    ...row,\n                    transaction_amount: parseFloat(row.transaction_amount)\n                }))\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Aprovar avalia√ß√£o como depoimento p√∫blico\n     */\n    static async approveReview(c: Context) {\n        try {\n            const reviewId = c.req.param('id');\n            const pool = getDbPool(c);\n\n            await pool.query(\n                'UPDATE transaction_reviews SET is_approved = TRUE WHERE id = $1',\n                [reviewId]\n            );\n\n            return c.json({ success: true, message: 'Avalia√ß√£o aprovada como depoimento!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Rejeitar avalia√ß√£o\n     */\n    static async rejectReview(c: Context) {\n        try {\n            const reviewId = c.req.param('id');\n            const pool = getDbPool(c);\n\n            await pool.query(\n                'UPDATE transaction_reviews SET is_approved = FALSE, is_public = FALSE WHERE id = $1',\n                [reviewId]\n            );\n\n            return c.json({ success: true, message: 'Avalia√ß√£o rejeitada.' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Limpar an√∫ncios antigos sem boost\n     */\n    static async cleanupOldListings(c: Context) {\n        try {\n            const body = await c.req.json().catch(() => ({}));\n            const daysOld = body.daysOld || 7;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const countResult = await client.query(`\n          SELECT COUNT(*) as total\n          FROM marketplace_listings \n          WHERE status = 'ACTIVE' \n            AND (is_boosted = FALSE OR is_boosted IS NULL)\n            AND created_at < NOW() - INTERVAL '${daysOld} days'\n        `);\n                const countToDelete = parseInt(countResult.rows[0].total);\n\n                if (countToDelete === 0) {\n                    return { deletedCount: 0 };\n                }\n\n                const listingsToDelete = await client.query(`\n          SELECT id FROM marketplace_listings \n          WHERE status = 'ACTIVE' \n            AND (is_boosted = FALSE OR is_boosted IS NULL)\n            AND created_at < NOW() - INTERVAL '${daysOld} days'\n        `);\n                const idsToDelete = listingsToDelete.rows.map(r => r.id);\n\n                const ordersCheck = await client.query(`\n          SELECT listing_id FROM marketplace_orders \n          WHERE listing_id = ANY($1) \n            AND status NOT IN ('COMPLETED', 'CANCELLED')\n        `, [idsToDelete]);\n\n                if (ordersCheck.rows.length > 0) {\n                    const idsWithOrders = ordersCheck.rows.map(r => r.listing_id);\n                    const safeIdsToDelete = idsToDelete.filter(id => !idsWithOrders.includes(id));\n\n                    if (safeIdsToDelete.length === 0) {\n                        return { deletedCount: 0, skipped: idsWithOrders.length };\n                    }\n\n                    const deleteResult = await client.query(`\n            DELETE FROM marketplace_listings \n            WHERE id = ANY($1)\n            RETURNING id\n          `, [safeIdsToDelete]);\n\n                    return {\n                        deletedCount: deleteResult.rowCount || 0,\n                        skipped: idsWithOrders.length\n                    };\n                }\n\n                const deleteResult = await client.query(`\n          DELETE FROM marketplace_listings \n          WHERE id = ANY($1)\n          RETURNING id\n        `, [idsToDelete]);\n\n                return { deletedCount: deleteResult.rowCount || 0 };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            const { deletedCount, skipped } = result.data!;\n            let message = `Limpeza conclu√≠da: ${deletedCount} an√∫ncio(s) removido(s).`;\n            if (skipped) {\n                message += ` ${skipped} an√∫ncio(s) com pedidos pendentes foram mantidos.`;\n            }\n\n            return c.json({\n                success: true,\n                message,\n                data: { deletedCount, skipped: skipped || 0, daysOld }\n            });\n        } catch (error: any) {\n            console.error('[CLEANUP] Erro ao limpar an√∫ncios:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Estat√≠sticas de an√∫ncios para limpeza\n     */\n    static async getCleanupStats(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT \n          COUNT(*) FILTER (WHERE status = 'ACTIVE' AND (is_boosted = FALSE OR is_boosted IS NULL) AND created_at < NOW() - INTERVAL '7 days') as stale_7_days,\n          COUNT(*) FILTER (WHERE status = 'ACTIVE' AND (is_boosted = FALSE OR is_boosted IS NULL) AND created_at < NOW() - INTERVAL '14 days') as stale_14_days,\n          COUNT(*) FILTER (WHERE status = 'ACTIVE' AND (is_boosted = FALSE OR is_boosted IS NULL) AND created_at < NOW() - INTERVAL '30 days') as stale_30_days,\n          COUNT(*) FILTER (WHERE status = 'ACTIVE' AND is_boosted = TRUE) as boosted_active,\n          COUNT(*) FILTER (WHERE status = 'ACTIVE') as total_active,\n          COUNT(*) as total_all\n        FROM marketplace_listings\n      `);\n\n            const stats = result.rows[0];\n\n            return c.json({\n                success: true,\n                data: {\n                    stale7Days: parseInt(stats.stale_7_days),\n                    stale14Days: parseInt(stats.stale_14_days),\n                    stale30Days: parseInt(stats.stale_30_days),\n                    boostedActive: parseInt(stats.boosted_active),\n                    totalActive: parseInt(stats.total_active),\n                    totalAll: parseInt(stats.total_all)\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.referral.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[858,861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[858,861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1764,1767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1764,1767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3038,3041],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3038,3041],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3775,3778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3775,3778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\n// Schema\nexport const createReferralCodeSchema = z.object({\n    code: z.string().min(3).max(20).toUpperCase(),\n    maxUses: z.number().int().min(1).optional().nullable(),\n});\n\nexport class AdminReferralController {\n\n    /**\n     * Listar todos os c√≥digos\n     */\n    static async listReferralCodes(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query(`\n                SELECT rc.*, u.name as creator_name \n                FROM referral_codes rc\n                LEFT JOIN users u ON rc.created_by = u.id\n                ORDER BY rc.created_at DESC\n            `);\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('Erro ao listar c√≥digos de indica√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Criar novo c√≥digo\n     */\n    static async createReferralCode(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { code, maxUses } = createReferralCodeSchema.parse(body);\n            const user = c.get('user');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                'INSERT INTO referral_codes (code, created_by, max_uses) VALUES ($1, $2, $3) RETURNING *',\n                [code, user.id, maxUses]\n            );\n\n            return c.json({\n                success: true,\n                message: 'C√≥digo de indica√ß√£o criado com sucesso!',\n                data: result.rows[0]\n            });\n        } catch (error: any) {\n            if (error.code === '23505') {\n                return c.json({ success: false, message: 'Este c√≥digo j√° existe. Escolha outro.' }, 409);\n            }\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            console.error('Erro ao criar c√≥digo de indica√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Ativar/Desativar c√≥digo\n     */\n    static async toggleReferralCode(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                'UPDATE referral_codes SET is_active = NOT is_active WHERE id = $1 RETURNING *',\n                [id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'C√≥digo n√£o encontrado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: `C√≥digo ${result.rows[0].is_active ? 'ativado' : 'desativado'} com sucesso!`,\n                data: result.rows[0]\n            });\n        } catch (error: any) {\n            console.error('Erro ao toggle c√≥digo de indica√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Remover c√≥digo\n     */\n    static async deleteReferralCode(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n            const result = await pool.query('DELETE FROM referral_codes WHERE id = $1 RETURNING *', [id]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'C√≥digo n√£o encontrado' }, 404);\n            }\n\n            return c.json({ success: true, message: 'C√≥digo removido com sucesso!' });\n        } catch (error: any) {\n            console.error('Erro ao remover c√≥digo de indica√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.rewards.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UserContext' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":21,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"UserContext"},"fix":{"range":[121,185],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1003,1006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1003,1006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2728,2731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2728,2731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4092,4095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4092,4095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4761,4764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4761,4764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { POINTS_CONVERSION_RATE } from '../../../application/services/points.service';\n\nexport class AdminRewardsController {\n    /**\n     * Listar todas as recompensas (Admin)\n     */\n    static async listRewards(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const res = await pool.query(`\n                SELECT c.*, \n                (SELECT COUNT(*) FROM reward_inventory i WHERE i.reward_id = c.id AND i.is_used = FALSE) as stock_count,\n                (SELECT COUNT(*) FROM reward_inventory i WHERE i.reward_id = c.id AND i.is_used = TRUE) as used_count\n                FROM reward_catalog c\n                ORDER BY created_at DESC\n            `);\n\n            return c.json({\n                success: true,\n                data: res.rows\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Criar ou atualizar recompensa\n     * REGRA: O ADM insere o pre√ßo em REAIS (value), o sistema calcula os PONTOS automaticamente.\n     */\n    static async saveReward(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const { id, name, description, type, value, is_active, image_url } = body;\n\n            // Calcula o custo em pontos automaticamente a partir do valor em reais\n            // F√≥rmula: points_cost = value * POINTS_CONVERSION_RATE\n            // Ex: R$ 10.00 com taxa de 1000 pts/R$ = 10000 pts\n            const points_cost = Math.round(parseFloat(value) * POINTS_CONVERSION_RATE);\n\n            const res = await pool.query(\n                `INSERT INTO reward_catalog (id, name, description, points_cost, type, value, is_active, image_url)\n                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                 ON CONFLICT (id) DO UPDATE SET\n                    name = EXCLUDED.name,\n                    description = EXCLUDED.description,\n                    points_cost = EXCLUDED.points_cost,\n                    type = EXCLUDED.type,\n                    value = EXCLUDED.value,\n                    is_active = EXCLUDED.is_active,\n                    image_url = EXCLUDED.image_url\n                 RETURNING *`,\n                [id, name, description, points_cost, type, value, is_active ?? true, image_url]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Recompensa salva com sucesso!',\n                data: res.rows[0]\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Adicionar c√≥digos ao estoque\n     */\n    static async addInventory(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const { rewardId, codes } = body; // codes pode ser string separada por linha ou array\n\n            if (!rewardId || !codes) {\n                return c.json({ success: false, message: 'ID da recompensa e c√≥digos s√£o necess√°rios.' }, 400);\n            }\n\n            const codeList = Array.isArray(codes)\n                ? codes\n                : codes.split('\\n').map((s: string) => s.trim()).filter((s: string) => s !== '');\n\n            if (codeList.length === 0) {\n                return c.json({ success: false, message: 'Nenhum c√≥digo v√°lido fornecido.' }, 400);\n            }\n\n            // Inserir m√∫ltiplos c√≥digos\n            for (const code of codeList) {\n                await pool.query(\n                    'INSERT INTO reward_inventory (reward_id, code) VALUES ($1, $2) ON CONFLICT DO NOTHING',\n                    [rewardId, code]\n                );\n            }\n\n            return c.json({\n                success: true,\n                message: `${codeList.length} c√≥digos adicionados ao estoque.`\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Ver hist√≥rico de resgates\n     */\n    static async getRedemptions(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const res = await pool.query(`\n                SELECT r.*, u.name as user_name, u.email as user_email\n                FROM reward_redemptions r\n                JOIN users u ON r.user_id = u.id\n                ORDER BY r.created_at DESC\n                LIMIT 100\n            `);\n\n            return c.json({\n                success: true,\n                data: res.rows\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/admin.users.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3859,3862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3859,3862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5459,5462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5459,5462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6381,6384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6381,6384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12306,12309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12306,12309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":358,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13967,13970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13967,13970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":392,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15105,15108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15105,15108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":427,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":427,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16319,16322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16319,16322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":468,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":468,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17823,17826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17823,17826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":502,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":502,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18949,18952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18949,18952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":537,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":537,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20152,20155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20152,20155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":650,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":650,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25780,25783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25780,25783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport bcrypt from 'bcrypt';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { updateScore, SCORE_REWARDS } from '../../../application/services/score.service';\nimport { createTransaction, executeInTransaction, updateUserBalance } from '../../../domain/services/transaction.service';\nimport { QUOTA_PRICE, QUOTA_SHARE_VALUE } from '../../../shared/constants/business.constants';\n\n// Schemas\nconst updateUserRoleStatusSchema = z.object({\n    userId: z.number(),\n    role: z.enum(['MEMBER', 'ATTENDANT', 'ADMIN']).optional(),\n    status: z.enum(['ACTIVE', 'BLOCKED']).optional(),\n    kycStatus: z.enum(['NONE', 'PENDING', 'APPROVED', 'REJECTED']).optional()\n});\n\nconst createAttendantSchema = z.object({\n    name: z.string().min(3),\n    email: z.string().email(),\n    password: z.string().min(6),\n    secretPhrase: z.string().min(3),\n    pixKey: z.string().min(5)\n});\n\nconst addQuotaSchema = z.object({\n    email: z.string().email(),\n    quantity: z.number().int().positive(),\n    reason: z.string().optional()\n});\n\nconst addBalanceSchema = z.object({\n    email: z.string().email(),\n    amount: z.number().positive(),\n    reason: z.string().optional()\n});\n\nexport class AdminUsersController {\n\n    /**\n     * Listar todos os usu√°rios com filtros e pagina√ß√£o\n     */\n    static async listUsers(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { search, role, status, limit, offset } = c.req.query();\n            const limitNum = parseInt(limit || '50');\n            const offsetNum = parseInt(offset || '0');\n\n            let baseQuery = `\n        FROM users\n        WHERE 1=1\n      `;\n            const params = [];\n            let paramIndex = 1;\n\n            if (search) {\n                baseQuery += ` AND (name ILIKE $${paramIndex} OR email ILIKE $${paramIndex})`;\n                params.push(`%${search}%`);\n                paramIndex++;\n            }\n\n            if (role) {\n                baseQuery += ` AND role = $${paramIndex}`;\n                params.push(role);\n                paramIndex++;\n            }\n\n            if (status) {\n                baseQuery += ` AND status = $${paramIndex}`;\n                params.push(status);\n                paramIndex++;\n            }\n\n            // Buscar total para pagina√ß√£o\n            const totalResult = await pool.query(`SELECT COUNT(*) as total ${baseQuery}`, params);\n            const total = parseInt(totalResult.rows[0].total);\n\n            // Buscar dados paginados com contagem e valor de cotas\n            const dataQuery = `\n        SELECT \n            u.id, u.name, u.email, u.role, u.status, u.balance, u.score, u.created_at, u.pix_key, u.membership_type, u.kyc_status,\n            u.referred_by, r.name as referrer_name,\n            (SELECT COUNT(*) FROM quotas q WHERE q.user_id = u.id AND (q.status = 'ACTIVE' OR q.status IS NULL)) as quotas_count,\n            (SELECT COALESCE(SUM(q.current_value), 0) FROM quotas q WHERE q.user_id = u.id AND (q.status = 'ACTIVE' OR q.status IS NULL)) as quotas_value\n        FROM users u\n        LEFT JOIN users r ON (u.referred_by ~ '^[0-9]+$' AND u.referred_by = CAST(r.id AS TEXT))\n        ${baseQuery.substring(baseQuery.indexOf('WHERE'))}\n        ORDER BY u.created_at DESC \n        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}\n      `;\n            params.push(limitNum, offsetNum);\n\n            const result = await pool.query(dataQuery, params);\n            return c.json({\n                success: true,\n                data: result.rows,\n                pagination: {\n                    total,\n                    limit: limitNum,\n                    offset: offsetNum,\n                    hasMore: offsetNum + result.rows.length < total\n                }\n            });\n        } catch (error: any) {\n            console.error('Erro ao listar usu√°rios:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar Role ou Status de um usu√°rio\n     */\n    static async updateUserAccess(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { userId, role, status } = updateUserRoleStatusSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const updateFields = [];\n            const params = [];\n            let index = 1;\n\n            if (role) {\n                updateFields.push(`role = $${index++}`);\n                params.push(role);\n            }\n            if (status) {\n                updateFields.push(`status = $${index++}`);\n                params.push(status);\n            }\n            if (body.kycStatus) {\n                updateFields.push(`kyc_status = $${index++}`);\n                params.push(body.kycStatus);\n            }\n\n            if (updateFields.length === 0) {\n                return c.json({ success: false, message: 'Nenhuma altera√ß√£o fornecida' }, 400);\n            }\n\n            params.push(userId);\n            const query = `UPDATE users SET ${updateFields.join(', ')} WHERE id = $${index} RETURNING id`;\n\n            const result = await pool.query(query, params);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n            }\n\n            return c.json({ success: true, message: 'Permiss√µes atualizadas com sucesso' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Criar um novo atendente diretamente\n     */\n    static async createAttendant(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { name, email, password, secretPhrase, pixKey } = createAttendantSchema.parse(body);\n            const pool = getDbPool(c);\n            const passwordHash = await bcrypt.hash(password, 10);\n\n            const result = await pool.query(\n                `INSERT INTO users (name, email, password_hash, secret_phrase, pix_key, role, status)\n         VALUES ($1, $2, $3, $4, $5, 'ATTENDANT', 'ACTIVE') RETURNING id`,\n                [name, email, passwordHash, secretPhrase, pixKey]\n            );\n\n            return c.json({ success: true, message: 'Atendente criado com sucesso', data: { id: result.rows[0].id } });\n        } catch (error: any) {\n            if (error.code === '23505') {\n                return c.json({ success: false, message: 'Email j√° cadastrado' }, 409);\n            }\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Adicionar cotas manualmente para um usu√°rio (Gift/Bonus)\n     */\n    static async addQuota(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { email, quantity, reason } = addQuotaSchema.parse(body);\n            const pool = getDbPool(c);\n\n            // Usar a l√≥gica centralizada de transa√ß√£o\n            const result = await executeInTransaction(pool, async (client) => {\n                // 1. Encontrar usu√°rio pelo email\n                const userRes = await client.query('SELECT id, name FROM users WHERE email = $1', [email]);\n                if (userRes.rows.length === 0) {\n                    throw new Error('Usu√°rio n√£o encontrado com este email');\n                }\n                const user = userRes.rows[0];\n\n                // 2. Inserir Cotas\n                for (let i = 0; i < quantity; i++) {\n                    await client.query(\n                        `INSERT INTO quotas (user_id, purchase_price, current_value, purchase_date, status)\n             VALUES ($1, $2, $3, $4, 'ACTIVE')`,\n                        [user.id, QUOTA_SHARE_VALUE, QUOTA_SHARE_VALUE, new Date()]\n                    );\n                }\n\n                // 3. Registrar a entrada de capital das cotas presenteadas (Admin aportando/capitalizando)\n                const giftTotal = quantity * QUOTA_PRICE;\n\n                await client.query(\n                    'UPDATE system_config SET system_balance = system_balance + $1',\n                    [giftTotal] // O sistema recebe o valor total (como se o admin estivesse injetando capital)\n                );\n\n                // 4. Atualizar Score do Usu√°rio (Benef√≠cio da Cota)\n                await updateScore(client, user.id, SCORE_REWARDS.QUOTA_PURCHASE * quantity, `Ganhou ${quantity} cotas (Gift Admin)`);\n\n                // 5. Registrar Log no hist√≥rico do usu√°rio\n                await createTransaction(\n                    client,\n                    user.id,\n                    'ADMIN_GIFT',\n                    0,\n                    `Recebeu ${quantity} cotas manualmente do Admin. Motivo: ${reason || 'B√¥nus Administrativo'}`,\n                    'COMPLETED',\n                    { quantity, reason, adminAction: true }\n                );\n\n                return { user: user.name };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `${quantity} cotas adicionadas para ${result.data?.user} com sucesso!`\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            return c.json({ success: false, message: error instanceof Error ? error.message : 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Adicionar saldo diretamente para um usu√°rio (Dep√≥sito Administrativo)\n     */\n    static async addBalance(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { email, amount, reason } = addBalanceSchema.parse(body);\n            const pool = getDbPool(c);\n            const adminUser = c.get('user');\n\n            // Usar a l√≥gica centralizada de transa√ß√£o\n            const result = await executeInTransaction(pool, async (client) => {\n                // 1. Encontrar usu√°rio pelo email\n                const userRes = await client.query('SELECT id, name FROM users WHERE email = $1', [email]);\n                if (userRes.rows.length === 0) {\n                    throw new Error('Usu√°rio n√£o encontrado com este email');\n                }\n                const user = userRes.rows[0];\n\n                // 2. Atualizar Saldo do Usu√°rio\n                await updateUserBalance(client, user.id, amount, 'credit');\n\n                // 3. Registrar Transa√ß√£o\n                await createTransaction(\n                    client,\n                    user.id,\n                    'DEPOSIT',\n                    amount,\n                    `Dep√≥sito Administrativo. Motivo: ${reason || 'Ajuste manual'}`,\n                    'COMPLETED',\n                    { method: 'ADMIN_MANUAL', adminId: adminUser.id, reason }\n                );\n\n                // 4. Atualizar Custos Manuais do Sistema (Passivo)\n                await client.query(\n                    'UPDATE system_config SET total_manual_costs = total_manual_costs + $1',\n                    [amount]\n                );\n\n                return { user: user.name };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `R$ ${amount.toFixed(2)} creditados para ${result.data?.user} com sucesso!`\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            return c.json({ success: false, message: error instanceof Error ? error.message : 'Erro interno' }, 500);\n        }\n    }\n    /**\n     * Limpar todos os administradores (Uso restrito/Desenvolvimento)\n     */\n    static async clearAdmins(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            await pool.query('DELETE FROM users WHERE role = $1', ['ADMIN']);\n            return c.json({ success: true, message: 'Administradores removidos com sucesso (Exceto o sistema se houver)' });\n        } catch (error: any) {\n            console.error('Erro ao limpar admins:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar entregadores pendentes de aprova√ß√£o\n     */\n    static async listPendingCouriers(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const status = c.req.query('status') || 'pending';\n\n            const result = await pool.query(`\n                SELECT \n                    id, name, email, courier_vehicle, courier_phone, courier_cpf,\n                    courier_city, courier_state, courier_status, courier_created_at, score,\n                    courier_id_photo, courier_vehicle_photo, courier_doc_photo\n                FROM users \n                WHERE is_courier = TRUE AND courier_status = $1\n                ORDER BY courier_created_at DESC\n            `, [status]);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(r => ({\n                    id: r.id,\n                    name: r.name,\n                    email: r.email,\n                    vehicle: r.courier_vehicle,\n                    phone: r.courier_phone,\n                    cpf: r.courier_cpf,\n                    city: r.courier_city,\n                    state: r.courier_state,\n                    status: r.courier_status,\n                    score: r.score,\n                    createdAt: r.courier_created_at,\n                    idPhoto: r.courier_id_photo,\n                    vehiclePhoto: r.courier_vehicle_photo,\n                    docPhoto: r.courier_doc_photo\n                }))\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao listar entregadores:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Aprovar entregador\n     */\n    static async approveCourier(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { userId } = await c.req.json();\n\n            if (!userId) {\n                return c.json({ success: false, message: 'userId √© obrigat√≥rio' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE users SET \n                    courier_status = 'approved' \n                 WHERE id = $1 AND is_courier = TRUE AND courier_status = 'pending'\n                 RETURNING name`,\n                [userId]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Entregador n√£o encontrado ou j√° processado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: `Entregador ${result.rows[0].name} aprovado com sucesso!`\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao aprovar entregador:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Rejeitar entregador\n     */\n    static async rejectCourier(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { userId, reason } = await c.req.json();\n\n            if (!userId) {\n                return c.json({ success: false, message: 'userId √© obrigat√≥rio' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE users SET \n                    courier_status = 'rejected',\n                    is_courier = FALSE\n                 WHERE id = $1 AND is_courier = TRUE AND courier_status = 'pending'\n                 RETURNING name`,\n                [userId]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Entregador n√£o encontrado ou j√° processado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: `Cadastro de ${result.rows[0].name} rejeitado. Motivo: ${reason || 'N√£o especificado'}`\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao rejeitar entregador:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar vendedores por status\n     */\n    static async listPendingSellers(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const status = c.req.query('status') || 'pending';\n\n            const result = await pool.query(`\n                SELECT \n                    id, name, email, seller_phone as phone, seller_cpf_cnpj as cpf,\n                    seller_address_city as city, seller_address_state as state,\n                    seller_company_name as company_name, seller_status as status, \n                    seller_created_at as created_at, score\n                FROM users \n                WHERE is_seller = TRUE AND seller_status = $1\n                ORDER BY seller_created_at DESC\n            `, [status]);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(r => ({\n                    id: r.id,\n                    name: r.name,\n                    email: r.email,\n                    phone: r.phone,\n                    cpf: r.cpf,\n                    city: r.city,\n                    state: r.state,\n                    companyName: r.company_name,\n                    status: r.status,\n                    score: r.score,\n                    createdAt: r.created_at\n                }))\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao listar vendedores:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Aprovar vendedor\n     */\n    static async approveSeller(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { userId } = await c.req.json();\n\n            if (!userId) {\n                return c.json({ success: false, message: 'userId √© obrigat√≥rio' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE users SET \n                    seller_status = 'approved' \n                 WHERE id = $1 AND is_seller = TRUE AND seller_status = 'pending'\n                 RETURNING name`,\n                [userId]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Vendedor n√£o encontrado ou j√° processado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: `Vendedor ${result.rows[0].name} aprovado com sucesso!`\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao aprovar vendedor:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Rejeitar vendedor\n     */\n    static async rejectSeller(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { userId, reason } = await c.req.json();\n\n            if (!userId) {\n                return c.json({ success: false, message: 'userId √© obrigat√≥rio' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE users SET \n                    seller_status = 'rejected',\n                    is_seller = FALSE\n                 WHERE id = $1 AND is_seller = TRUE AND seller_status = 'pending'\n                 RETURNING name`,\n                [userId]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Vendedor n√£o encontrado ou j√° processado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: `Cadastro de ${result.rows[0].name} rejeitado. Motivo: ${reason || 'N√£o especificado'}`\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao rejeitar vendedor:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Criar Empr√©stimo Manual (A√ß√£o Admin)\n     */\n    static async createManualLoan(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { userId, amount, interestRate, installments, description } = body;\n            const pool = getDbPool(c);\n\n            if (!userId || !amount || !interestRate || !installments) {\n                return c.json({ success: false, message: 'Campos obrigat√≥rios: userId, amount, interestRate, installments' }, 400);\n            }\n\n            const result = await executeInTransaction(pool, async (client) => {\n                // 1. Verificar Liquidez Real\n                const statsRes = await client.query(`\n                    SELECT \n                        (SELECT COUNT(*) FROM quotas WHERE status = 'ACTIVE') as quotas_count,\n                        (SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING', 'ACTIVE')) as total_loaned,\n                        (SELECT COALESCE(SUM(total_invested), 0) FROM investments WHERE status = 'ACTIVE') as total_invested,\n                        (SELECT system_balance FROM system_config LIMIT 1) as system_balance\n                `);\n                const stats = statsRes.rows[0];\n                const realLiquidity = (Number(stats.quotas_count) * QUOTA_SHARE_VALUE) - Number(stats.total_loaned) - Number(stats.total_invested);\n\n                if (amount > realLiquidity) {\n                    throw new Error(`Saldo insuficiente na Liquidez Real (R$ ${realLiquidity.toFixed(2)}). Empr√©stimo n√£o autorizado.`);\n                }\n\n                // 2. Buscar Usu√°rio\n                const userRes = await client.query('SELECT name FROM users WHERE id = $1', [userId]);\n                if (userRes.rows.length === 0) throw new Error('Usu√°rio n√£o encontrado');\n\n                // 3. Criar Empr√©stimo\n                const interestAmount = amount * (interestRate / 100);\n                const totalRepayment = amount + interestAmount;\n                const installmentAmount = totalRepayment / installments;\n                const dueDate = new Date();\n                dueDate.setDate(dueDate.getDate() + 30); // Primeira parcela em 30 dias\n\n                const loanResult = await client.query(`\n                    INSERT INTO loans (user_id, amount, interest_rate, total_repayment, installments, status, due_date, metadata, created_at)\n                    VALUES ($1, $2, $3, $4, $5, 'APPROVED', $6, $7, NOW())\n                    RETURNING id\n                `, [\n                    userId,\n                    amount,\n                    interestRate / 100,\n                    totalRepayment,\n                    installments,\n                    dueDate,\n                    JSON.stringify({\n                        origin: 'ADMIN_MANUAL',\n                        description: description || 'Empr√©stimo manual administrativo',\n                        interestAmount,\n                        installmentAmount\n                    })\n                ]);\n                const loanId = loanResult.rows[0].id;\n\n                // 3.1. GERAR PARCELAS (CR√çTICO PARA O CLIENTE PAGAR NO APP)\n                // installmentAmount j√° calculado acima\n                for (let i = 1; i <= installments; i++) {\n                    const installmentDueDate = new Date();\n                    installmentDueDate.setDate(installmentDueDate.getDate() + (i * 30)); // 30, 60, 90 dias...\n\n                    await client.query(`\n                        INSERT INTO loan_installments (loan_id, installment_number, amount, due_date, status, expected_amount)\n                        VALUES ($1, $2, $3, $4, 'PENDING', $3)\n                    `, [loanId, i, installmentAmount, installmentDueDate]);\n                }\n\n                // 4. Registrar Transa√ß√£o de Sa√≠da do Caixa\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, status, description, metadata, created_at)\n                    VALUES ($1, 'LOAN_DISBURSEMENT', $2, 'APPROVED', $3, $4, NOW())\n                `, [\n                    userId,\n                    amount,\n                    `Empr√©stimo Especial Liberado pelo Admin`,\n                    JSON.stringify({ loanId: loanResult.rows[0].id })\n                ]);\n\n                // 5. Adicionar saldo ao usu√°rio (para ele sacar ou usar)\n                await client.query('UPDATE users SET balance = balance + $1 WHERE id = $2', [amount, userId]);\n\n                // 6. Deduzir do saldo do sistema (Caixa PIX)\n                await client.query('UPDATE system_config SET system_balance = system_balance - $1', [amount]);\n\n                return { loanId: loanResult.rows[0].id, userName: userRes.rows[0].name };\n            });\n\n            // ‚ö†Ô∏è FIX: Criar parcelas fora da transa√ß√£o principal se necess√°rio, ou melhor, dentro dela.\n            // O c√≥digo original n√£o tinha cria√ß√£o de parcelas. Vamos adicionar DENTRO da transa√ß√£o acima.\n\n            // ... (Reescrevendo o bloco transaction para incluir o loop de parcelas)\n\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `Empr√©stimo de R$ ${amount.toFixed(2)} criado com sucesso para ${result.data?.userName}!`,\n                data: result.data\n            });\n        } catch (error: any) {\n            console.error('[ADMIN] Erro ao criar empr√©stimo manual:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/auth.controller.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'user' is never reassigned. Use 'const' instead.","line":64,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":64,"endColumn":21,"fix":{"range":[2338,2364],"text":"const user = result.rows[0];"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5865,5868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5865,5868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is assigned a value but never used.","line":175,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":175,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":240,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11567,11570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11567,11570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":268,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12937,12940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12937,12940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14703,14706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14703,14706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validatedData' is assigned a value but never used.","line":317,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":317,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15635,15638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15635,15638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'picture' is assigned a value but never used.","line":347,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":347,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":448,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":448,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20966,20969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20966,20969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":490,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":490,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22546,22549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22546,22549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":520,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":520,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23689,23692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23689,23692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":540,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":540,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":540,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24411,24414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24411,24414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":559,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":559,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":559,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25128,25131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25128,25131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":586,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":586,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":586,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":586,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26125,26128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26125,26128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":637,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":637,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28409,28412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28409,28412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport bcrypt from 'bcrypt';\nimport { sign } from 'jsonwebtoken';\nimport { getDbPool, generateReferralCode } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { twoFactorService } from '../../../application/services/two-factor.service';\nimport { notificationService } from '../../../application/services/notification.service';\nimport { firebaseAdmin } from '../../../infrastructure/firebase/admin-config';\n\n// Schemas\nconst loginSchema = z.object({\n    email: z.string().email(),\n    password: z.string().min(6),\n    secretPhrase: z.string().optional().or(z.literal('')),\n    twoFactorCode: z.string().length(6).optional().or(z.literal('')),\n});\n\nconst registerSchema = z.object({\n    name: z.string().min(5).refine(val => val.trim().split(/\\s+/).length >= 2, \"Informe seu Nome e Sobrenome reais\"),\n    email: z.string().email(),\n    password: z.string().min(6),\n    secretPhrase: z.string().min(3),\n    pixKey: z.string().optional(),\n    phone: z.string().optional(),\n    referralCode: z.string().optional(),\n    cpf: z.string().min(11).max(14).optional(),\n});\n\nconst resetPasswordSchema = z.object({\n    email: z.string().email(),\n    secretPhrase: z.string().min(3),\n    newPassword: z.string().min(6),\n});\n\nconst recover2FASchema = z.object({\n    email: z.string().email(),\n    password: z.string().min(6),\n    secretPhrase: z.string().min(3),\n});\n\nconst termsAcceptanceSchema = z.object({\n    termsAccepted: z.boolean().refine(val => val === true, \"Voc√™ deve aceitar os termos de uso\"),\n});\n\nexport class AuthController {\n    /**\n     * Login\n     */\n    static async login(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = loginSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const userEmail = validatedData.email.toLowerCase();\n            const result = await pool.query(\n                `SELECT id, name, email, password_hash, secret_phrase, panic_phrase, is_under_duress, \n                 safe_contact_phone, pix_key, referral_code, is_admin, balance, score, created_at, \n                 is_email_verified, two_factor_enabled, two_factor_secret, status, role \n                 FROM users WHERE email = $1`,\n                [userEmail]\n            );\n\n            let user = result.rows[0];\n            const isAdmin = user?.is_admin || false;\n\n            // Detectar Panic Mode\n            const universalPanicTriggers = ['190', 'SOS', 'COACAO'];\n            const enteredSecret = validatedData.secretPhrase?.trim().toUpperCase();\n\n            if (user && enteredSecret &&\n                (user.panic_phrase === validatedData.secretPhrase || universalPanicTriggers.includes(enteredSecret))) {\n                await pool.query('UPDATE users SET is_under_duress = TRUE WHERE id = $1', [user.id]);\n                if (user.safe_contact_phone) {\n                    notificationService.sendDuressAlert(user.name, user.safe_contact_phone);\n                }\n            }\n\n            if (!user) {\n                return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n            }\n\n            if (user.status && user.status !== 'ACTIVE') {\n                if (user.status === 'WAITLIST') {\n                    return c.json({ success: false, message: 'Voc√™ est√° na Lista de Espera. Aguarde a libera√ß√£o de novas vagas.' }, 403);\n                }\n                return c.json({ success: false, message: 'Esta conta est√° suspensa ou bloqueada.' }, 403);\n            }\n\n            // Verifica√ß√£o de 2FA\n            if (user.two_factor_enabled) {\n                if (!validatedData.twoFactorCode) {\n                    return c.json({ success: false, message: 'C√≥digo de autentica√ß√£o necess√°rio', data: { requires2FA: true } }, 200);\n                }\n                if (!twoFactorService.verifyToken(validatedData.twoFactorCode, user.two_factor_secret)) {\n                    return c.json({ success: false, message: 'C√≥digo de autentica√ß√£o inv√°lido' }, 401);\n                }\n            }\n\n            // Valida√ß√£o de Senha (CR√çTICO: Sem bypass para admin)\n            const isPasswordValid = await bcrypt.compare(validatedData.password, user.password_hash);\n            if (!isPasswordValid) return c.json({ success: false, message: 'Senha incorreta' }, 401);\n\n            // Valida√ß√£o de Frase Secreta (se 2FA n√£o estiver ativo)\n            if (!user.two_factor_enabled && user.secret_phrase !== validatedData.secretPhrase && user.panic_phrase !== validatedData.secretPhrase) {\n                return c.json({ success: false, message: 'Frase secreta incorreta' }, 401);\n            }\n\n            const token = sign({ userId: user.id, isAdmin }, process.env.JWT_SECRET as string, { expiresIn: '7d' });\n            const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n            await pool.query('UPDATE users SET last_ip = $1, last_login_at = NOW() WHERE id = $2', [ip, user.id]);\n\n            return c.json({\n                success: true,\n                message: 'Login realizado com sucesso',\n                data: {\n                    user: {\n                        id: user.id,\n                        name: user.name,\n                        email: user.email,\n                        pixKey: user.pix_key,\n                        balance: parseFloat(user.balance || 0),\n                        joinedAt: user.created_at,\n                        referralCode: user.referral_code,\n                        isAdmin: isAdmin,\n                        score: user.score,\n                        role: user.role || 'MEMBER',\n                        status: user.status || 'ACTIVE',\n                        twoFactorEnabled: user.two_factor_enabled\n                    },\n                    token,\n                },\n            });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('[LOGIN ERROR]:', error);\n            return c.json({ success: false, message: 'Erro interno no servidor' }, 500);\n        }\n    }\n\n    /**\n     * Registro\n     */\n    static async register(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = registerSchema.parse(body);\n            const pool = getDbPool(c);\n            const userEmail = validatedData.email.toLowerCase();\n\n            const existingUser = await pool.query('SELECT id FROM users WHERE email = $1', [userEmail]);\n            if (existingUser.rows.length > 0) return c.json({ success: false, message: 'Email j√° cadastrado' }, 409);\n\n            if (validatedData.pixKey) {\n                const existingPix = await pool.query('SELECT id FROM users WHERE pix_key = $1', [validatedData.pixKey]);\n                if (existingPix.rows.length > 0) return c.json({ success: false, message: 'Esta chave PIX j√° est√° vinculada a outra conta' }, 409);\n            }\n\n            const isAdminEmail = userEmail === (process.env.ADMIN_EMAIL || '').toLowerCase();\n            const hashedPassword = await bcrypt.hash(validatedData.password, 10);\n\n            // --- WAITLIST CHECK ---\n            const { MAX_ACTIVE_MEMBERS, WAITLIST_ENABLED } = await import('../../../shared/constants/business.constants');\n\n            let status = 'ACTIVE';\n            let message = 'Cadastro realizado!';\n            let referrerId = null;\n\n            if (WAITLIST_ENABLED && !isAdminEmail) {\n                const countRes = await pool.query(\"SELECT COUNT(*) FROM users WHERE status = 'ACTIVE'\");\n                const activeCount = parseInt(countRes.rows[0].count);\n\n                if (activeCount >= MAX_ACTIVE_MEMBERS) {\n                    status = 'WAITLIST';\n                    message = 'Cadastro realizado! Voc√™ est√° na LISTA DE ESPERA devido √† alta demanda. Avisaremos quando liberar.';\n                }\n            }\n\n            if (!isAdminEmail) {\n                if (!validatedData.referralCode || validatedData.referralCode.trim() === '') {\n                    return c.json({ success: false, message: 'C√≥digo de indica√ß√£o √© obrigat√≥rio.' }, 403);\n                }\n                const inputCode = validatedData.referralCode.trim().toUpperCase();\n\n                const userReferrerResult = await pool.query('SELECT id FROM users WHERE referral_code = $1', [inputCode]);\n                if (userReferrerResult.rows.length > 0) {\n                    referrerId = userReferrerResult.rows[0].id;\n                } else {\n                    const adminCodeResult = await pool.query('SELECT * FROM referral_codes WHERE code = $1 AND is_active = TRUE', [inputCode]);\n                    if (adminCodeResult.rows.length > 0) {\n                        const adminCode = adminCodeResult.rows[0];\n                        if (adminCode.max_uses !== null && adminCode.current_uses >= adminCode.max_uses) {\n                            return c.json({ success: false, message: 'Este c√≥digo expirou.' }, 403);\n                        }\n                        referrerId = adminCode.created_by;\n                        await pool.query('UPDATE referral_codes SET current_uses = current_uses + 1 WHERE id = $1', [adminCode.id]);\n                    }\n                }\n                if (!referrerId) return c.json({ success: false, message: 'C√≥digo de indica√ß√£o inv√°lido.' }, 403);\n            }\n\n            const referralCode = generateReferralCode();\n            const tfaSecret = twoFactorService.generateSecret();\n            const otpUri = twoFactorService.generateOtpUri(userEmail, tfaSecret);\n            const qrCode = await twoFactorService.generateQrCode(otpUri);\n\n            const newUserResult = await pool.query(\n                `INSERT INTO users (name, email, password_hash, secret_phrase, pix_key, balance, referral_code, is_admin, score, two_factor_secret, two_factor_enabled, is_email_verified, accepted_terms_at, cpf, phone, status, referred_by)\n                 VALUES ($1, $2, $3, $4, $5, 0, $6, $7, 0, $8, FALSE, TRUE, CURRENT_TIMESTAMP, $9, $10, $11, $12)\n                 RETURNING id, name, email, pix_key, balance, score, created_at, referral_code, is_admin, status`,\n                [validatedData.name, userEmail, hashedPassword, validatedData.secretPhrase, validatedData.pixKey || null, referralCode, isAdminEmail, tfaSecret, validatedData.cpf || null, validatedData.phone || null, status, referrerId]\n            );\n\n            const newUser = newUserResult.rows[0];\n\n            // BLINDAGEM: Registrar aceite de termos\n            await AuthController.recordTermsAcceptance(c, newUser.id);\n\n            const token = sign({ userId: newUser.id, email: newUser.email, isAdmin: newUser.is_admin }, process.env.JWT_SECRET!);\n\n            return c.json({\n                success: true,\n                message: 'Cadastro conclu√≠do!',\n                data: {\n                    user: {\n                        id: newUser.id,\n                        name: newUser.name,\n                        email: newUser.email,\n                        pixKey: newUser.pix_key,\n                        balance: 0,\n                        joinedAt: newUser.created_at,\n                        referralCode: newUser.referral_code,\n                        isAdmin: newUser.is_admin,\n                        twoFactorEnabled: false\n                    },\n                    twoFactor: { secret: tfaSecret, qrCode, otpUri },\n                    token,\n                },\n            }, 201);\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: error.errors[0]?.message || 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('[REGISTER ERROR]:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Reset de Senha\n     */\n    static async resetPassword(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = resetPasswordSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const userEmail = validatedData.email.toLowerCase();\n            const result = await pool.query('SELECT id, secret_phrase FROM users WHERE email = $1', [userEmail]);\n\n            if (result.rows.length === 0) return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n\n            const user = result.rows[0];\n            if (user.secret_phrase !== validatedData.secretPhrase) return c.json({ success: false, message: 'Frase secreta incorreta' }, 401);\n\n            const hashedPassword = await bcrypt.hash(validatedData.newPassword, 10);\n            await pool.query('UPDATE users SET password_hash = $1 WHERE id = $2', [hashedPassword, user.id]);\n\n            return c.json({ success: true, message: 'Senha redefinida com sucesso' });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos' }, 400);\n            return c.json({ success: false, message: 'Erro ao redefinir senha' }, 500);\n        }\n    }\n\n    /**\n     * Recuperar 2FA\n     */\n    static async recover2FA(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = recover2FASchema.parse(body);\n            const pool = getDbPool(c);\n\n            const userEmail = validatedData.email.toLowerCase();\n            const result = await pool.query('SELECT id, password_hash, secret_phrase FROM users WHERE email = $1', [userEmail]);\n\n            if (result.rows.length === 0) return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n\n            const user = result.rows[0];\n            const isPasswordValid = await bcrypt.compare(validatedData.password, user.password_hash);\n            if (!isPasswordValid) return c.json({ success: false, message: 'Senha incorreta' }, 401);\n\n            if (user.secret_phrase !== validatedData.secretPhrase) return c.json({ success: false, message: 'Frase secreta incorreta' }, 401);\n\n            const tfaSecret = twoFactorService.generateSecret();\n            const otpUri = twoFactorService.generateOtpUri(userEmail, tfaSecret);\n            const qrCode = await twoFactorService.generateQrCode(otpUri);\n\n            await pool.query('UPDATE users SET two_factor_secret = $1, two_factor_enabled = FALSE WHERE id = $2', [tfaSecret, user.id]);\n\n            return c.json({\n                success: true,\n                message: '2FA redefinido. Reative-o usando o novo QR Code.',\n                data: { secret: tfaSecret, qrCode, otpUri }\n            });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos' }, 400);\n            return c.json({ success: false, message: 'Erro ao recuperar 2FA' }, 500);\n        }\n    }\n\n    /**\n     * Aceitar Termos\n     */\n    static async acceptTerms(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = termsAcceptanceSchema.parse(body);\n            const user = c.get('user');\n            const pool = getDbPool(c);\n\n            if (!user) return c.json({ success: false, message: 'N√£o autorizado' }, 401);\n\n            await pool.query('UPDATE users SET accepted_terms_at = NOW() WHERE id = $1', [user.id]);\n\n            // BLINDAGEM: Registrar na auditoria\n            await AuthController.recordTermsAcceptance(c, user.id);\n\n            return c.json({ success: true, message: 'Termos aceitos com sucesso' });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Voc√™ deve aceitar os termos' }, 400);\n            return c.json({ success: false, message: 'Erro ao aceitar termos' }, 500);\n        }\n    }\n\n    /**\n     * Login via Google (Firebase)\n     */\n    static async loginGoogle(c: Context) {\n        try {\n            const { idToken } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (!idToken) return c.json({ success: false, message: 'ID Token n√£o fornecido' }, 400);\n\n            // Verificar Token no Firebase\n            const decodedToken = await firebaseAdmin.auth().verifyIdToken(idToken);\n            const { email, name, picture } = decodedToken;\n\n            if (!email) return c.json({ success: false, message: 'Email n√£o retornado pelo Google' }, 400);\n\n            // Buscar ou criar usu√°rio\n            const userRes = await pool.query('SELECT * FROM users WHERE email = $1', [email.toLowerCase()]);\n            let user = userRes.rows[0];\n            let isNewUser = false;\n\n            if (!user) {\n                // Criar usu√°rio se n√£o existir\n                const referralCode = generateReferralCode();\n                const newUserRes = await pool.query(\n                    `INSERT INTO users (name, email, password_hash, referral_code, balance, score, is_email_verified, status)\n                     VALUES ($1, $2, $3, $4, 0, 0, TRUE, 'ACTIVE')\n                     RETURNING *`,\n                    [name || 'Usu√°rio Google', email.toLowerCase(), 'GOOGLE_AUTH', referralCode]\n                );\n                user = newUserRes.rows[0];\n                isNewUser = true;\n\n                // BLINDAGEM: Registrar aceite de termos para novos usu√°rios Google\n                await AuthController.recordTermsAcceptance(c, user.id);\n            }\n\n            // Verificar se √© o Admin do Sistema definido no .env\n            const isAdminEmail = email.toLowerCase() === (process.env.ADMIN_EMAIL || '').toLowerCase();\n\n            if (user && isAdminEmail && !user.is_admin) {\n                // Auto-promover para Admin se o email bater\n                // E preencher credenciais do .env para permitir login tradicional\n                const bcrypt = await import('bcrypt');\n\n                const adminPassword = process.env.ADMIN_PASSWORD;\n                const adminSecretPhrase = process.env.ADMIN_SECRET_PHRASE;\n\n                if (!adminPassword || !adminSecretPhrase) {\n                    throw new Error('CONFIGURA√á√ÉO DE SEGURAN√áA INCOMPLETA: ADMIN_PASSWORD ou ADMIN_SECRET_PHRASE n√£o definidos no servidor.');\n                }\n\n                const hashedPassword = await bcrypt.default.hash(adminPassword, 10);\n\n                await pool.query(\n                    `UPDATE users SET \n                        is_admin = TRUE, \n                        role = 'ADMIN',\n                        password_hash = $1,\n                        secret_phrase = $2\n                     WHERE id = $3`,\n                    [hashedPassword, adminSecretPhrase, user.id]\n                );\n                user.is_admin = true;\n                user.role = 'ADMIN';\n                console.log(`[AUTH] Admin ${email} promovido e credenciais sincronizadas com .env`);\n            } else if (user && isAdminEmail && user.password_hash === 'GOOGLE_AUTH') {\n                // Admin j√° existe mas sem senha definida - sincronizar credenciais\n                const bcrypt = await import('bcrypt');\n\n                const adminPassword = process.env.ADMIN_PASSWORD;\n                const adminSecretPhrase = process.env.ADMIN_SECRET_PHRASE;\n\n                if (!adminPassword || !adminSecretPhrase) {\n                    throw new Error('CONFIGURA√á√ÉO DE SEGURAN√áA INCOMPLETA: ADMIN_PASSWORD ou ADMIN_SECRET_PHRASE n√£o definidos no servidor.');\n                }\n\n                const hashedPassword = await bcrypt.default.hash(adminPassword, 10);\n\n                await pool.query(\n                    `UPDATE users SET \n                        password_hash = $1,\n                        secret_phrase = $2\n                     WHERE id = $3`,\n                    [hashedPassword, adminSecretPhrase, user.id]\n                );\n                console.log(`[AUTH] Credenciais do Admin ${email} sincronizadas com .env`);\n            }\n\n            const isAdmin = user.is_admin || false;\n            const token = sign({ userId: user.id, isAdmin }, process.env.JWT_SECRET as string, { expiresIn: '7d' });\n\n            return c.json({\n                success: true,\n                message: 'Login realizado com sucesso',\n                data: {\n                    user: {\n                        id: user.id,\n                        name: user.name,\n                        email: user.email,\n                        pixKey: user.pix_key,\n                        balance: parseFloat(user.balance || 0),\n                        joinedAt: user.created_at,\n                        referralCode: user.referral_code,\n                        isAdmin: isAdmin,\n                        score: user.score,\n                        role: user.role || 'MEMBER',\n                        status: user.status || 'ACTIVE'\n                    },\n                    token,\n                    isNewUser\n                },\n            });\n        } catch (error: any) {\n            console.error('[GOOGLE LOGIN ERROR]:', error);\n            const errorMessage = error.message || 'Erro na autentica√ß√£o Google';\n            return c.json({ success: false, message: errorMessage }, 401);\n        }\n    }\n\n    /**\n     * Logout\n     */\n    static async logout(c: Context) {\n        // No JWT, o logout √© do lado do cliente, mas podemos invalidar no servidor se usarmos blacklist\n        return c.json({ success: true, message: 'Logout realizado com sucesso' });\n    }\n\n    /**\n     * Configura√ß√£o Inicial do 2FA\n     */\n    static async setup2FA(c: Context) {\n        try {\n            const user = c.get('user');\n            const pool = getDbPool(c);\n\n            if (!user) return c.json({ success: false, message: 'N√£o autorizado' }, 401);\n\n            // Buscar usu√°rio para pegar o segredo atual ou gerar um novo\n            const result = await pool.query('SELECT email, two_factor_secret FROM users WHERE id = $1', [user.id]);\n            const dbUser = result.rows[0];\n\n            let secret = dbUser.two_factor_secret;\n            if (!secret) {\n                secret = twoFactorService.generateSecret();\n                await pool.query('UPDATE users SET two_factor_secret = $1 WHERE id = $2', [secret, user.id]);\n            }\n\n            const otpUri = twoFactorService.generateOtpUri(dbUser.email, secret);\n            const qrCode = await twoFactorService.generateQrCode(otpUri);\n\n            return c.json({\n                success: true,\n                data: { secret, qrCode, otpUri }\n            });\n        } catch (error: any) {\n            console.error('[2FA SETUP ERROR]:', error);\n            return c.json({ success: false, message: 'Erro ao configurar 2FA' }, 500);\n        }\n    }\n\n    /**\n     * Verificar e Ativar 2FA\n     */\n    static async verify2FA(c: Context) {\n        try {\n            const { token, secret } = await c.req.json();\n            const user = c.get('user');\n            const pool = getDbPool(c);\n\n            if (!user) return c.json({ success: false, message: 'N√£o autorizado' }, 401);\n\n            if (!token || !secret) {\n                return c.json({ success: false, message: 'Token e Segredo s√£o obrigat√≥rios' }, 400);\n            }\n\n            const isValid = twoFactorService.verifyToken(token, secret);\n            if (!isValid) {\n                return c.json({ success: false, message: 'C√≥digo inv√°lido' }, 400);\n            }\n\n            // Ativar definitivamente para o usu√°rio\n            await pool.query('UPDATE users SET two_factor_enabled = TRUE, two_factor_secret = $1 WHERE id = $2', [secret, user.id]);\n\n            return c.json({ success: true, message: '2FA ativado com sucesso' });\n        } catch (error: any) {\n            console.error('[2FA VERIFY ERROR]:', error);\n            return c.json({ success: false, message: 'Erro ao verificar 2FA' }, 500);\n        }\n    }\n\n    /**\n     * Verificar status de aceite dos termos\n     */\n    static async termsStatus(c: Context) {\n        try {\n            const user = c.get('user');\n            const pool = getDbPool(c);\n\n            if (!user) return c.json({ success: false, message: 'N√£o autorizado' }, 401);\n\n            const result = await pool.query('SELECT accepted_terms_at FROM users WHERE id = $1', [user.id]);\n            const accepted = !!result.rows[0]?.accepted_terms_at;\n\n            return c.json({ success: true, data: { accepted } });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao verificar status dos termos' }, 500);\n        }\n    }\n\n    /**\n     * Admin: Desabilitar 2FA de um usu√°rio\n     */\n    static async adminDisable2FA(c: Context) {\n        try {\n            const adminUser = c.get('user');\n            const { userId } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (!adminUser?.isAdmin) return c.json({ success: false, message: 'Acesso negado' }, 403);\n\n            await pool.query('UPDATE users SET two_factor_enabled = FALSE WHERE id = $1', [userId]);\n\n            return c.json({ success: true, message: '2FA desabilitado com sucesso pelo administrador' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao desabilitar 2FA' }, 500);\n        }\n    }\n\n    /**\n     * Admin: Resetar Seguran√ßa do Usu√°rio\n     */\n    static async adminResetUserSecurity(c: Context) {\n        try {\n            const adminUser = c.get('user');\n            const { userId, newPassword, newSecretPhrase } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (!adminUser?.isAdmin) return c.json({ success: false, message: 'Acesso negado' }, 403);\n\n            const hashedPassword = await bcrypt.hash(newPassword, 10);\n            await pool.query(\n                `UPDATE users SET \n                 password_hash = $1, \n                 secret_phrase = $2, \n                 two_factor_enabled = FALSE \n                 WHERE id = $3`,\n                [hashedPassword, newSecretPhrase, userId]\n            );\n\n            return c.json({ success: true, message: 'Seguran√ßa do usu√°rio resetada com sucesso' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao resetar seguran√ßa' }, 500);\n        }\n    }\n    /**\n     * Aplicar c√≥digo de indica√ß√£o (P√≥s-Login Social)\n     */\n    static async applyReferral(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const { referralCode } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (!referralCode) return c.json({ success: false, message: 'C√≥digo obrigat√≥rio' }, 400);\n\n            // Verificar se usu√°rio j√° tem indica√ß√£o\n            const userCheck = await pool.query('SELECT referred_by, referral_code FROM users WHERE id = $1', [userPayload.id]);\n            const user = userCheck.rows[0];\n\n            if (user.referred_by) {\n                return c.json({ success: false, message: 'Voc√™ j√° possui um indicador vinculado.' }, 400);\n            }\n\n            if (user.referral_code === referralCode) {\n                return c.json({ success: false, message: 'Voc√™ n√£o pode indicar a si mesmo.' }, 400);\n            }\n\n            // Buscar quem √© o dono do c√≥digo\n            let referrerId = null;\n            const referrerCheck = await pool.query('SELECT id FROM users WHERE referral_code = $1', [referralCode]);\n\n            if (referrerCheck.rows.length > 0) {\n                referrerId = referrerCheck.rows[0].id;\n            } else {\n                // Verificar c√≥digos administrativos\n                const adminCodeCheck = await pool.query('SELECT * FROM referral_codes WHERE code = $1 AND is_active = TRUE', [referralCode]);\n                if (adminCodeCheck.rows.length > 0) {\n                    referrerId = adminCodeCheck.rows[0].created_by;\n                    await pool.query('UPDATE referral_codes SET current_uses = current_uses + 1 WHERE id = $1', [adminCodeCheck.rows[0].id]);\n                }\n            }\n\n            if (!referrerId) {\n                return c.json({ success: false, message: 'C√≥digo de indica√ß√£o inv√°lido ou n√£o encontrado.' }, 404);\n            }\n\n            // Atualizar usu√°rio\n            await pool.query('UPDATE users SET referred_by = $1 WHERE id = $2', [referrerId, userPayload.id]);\n\n            return c.json({ success: true, message: 'Indica√ß√£o vinculada com sucesso!' });\n\n        } catch (error: any) {\n            console.error('[APPLY REFERRAL ERROR]:', error);\n            return c.json({ success: false, message: 'Erro ao aplicar indica√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Helper para registrar aceite de termos na tabela de auditoria (Blindagem)\n     */\n    private static async recordTermsAcceptance(c: Context, userId: number) {\n        try {\n            const pool = getDbPool(c);\n            const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || '127.0.0.1';\n            const userAgent = c.req.header('user-agent') || 'Unknown';\n\n            await pool.query(\n                `INSERT INTO terms_acceptance \n                (user_id, terms_version, privacy_version, ip_address, user_agent) \n                VALUES ($1, '2.0', '1.0', $2, $3)\n                ON CONFLICT (user_id, terms_version, privacy_version) DO NOTHING`,\n                [userId, ip, userAgent]\n            );\n        } catch (error) {\n            console.error('[COMPLIANCE ERROR] Falha ao registrar aceite de termos:', error);\n            // N√£o bloqueia o fluxo principal, mas loga o erro\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/bug-reports.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1839,1842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1839,1842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2747,2750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2747,2750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4137,4140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4137,4140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5516,5519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5516,5519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6032,6035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6032,6035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n// Schema de valida√ß√£o para criar bug report\nconst createBugReportSchema = z.object({\n    title: z.string().min(5, 'T√≠tulo muito curto').max(255),\n    description: z.string().min(20, 'Descri√ß√£o muito curta'),\n    category: z.enum(['general', 'payment', 'ui', 'performance', 'other']).optional().default('general'),\n    severity: z.enum(['low', 'medium', 'high', 'critical']).optional().default('low'),\n    deviceInfo: z.string().optional(),\n});\n\nexport class BugReportsController {\n    /**\n     * Criar um bug report\n     */\n    static async createBugReport(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n\n            const validatedData = createBugReportSchema.parse(body);\n\n            const result = await getDbPool(c).query(\n                `INSERT INTO bug_reports (user_id, user_email, user_name, title, description, category, severity, device_info)\n                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                 RETURNING id`,\n                [\n                    user.id,\n                    user.email,\n                    user.name,\n                    validatedData.title,\n                    validatedData.description,\n                    validatedData.category,\n                    validatedData.severity,\n                    validatedData.deviceInfo || null\n                ]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Bug reportado com sucesso! Nossa equipe ir√° analisar.',\n                data: { id: result.rows[0].id }\n            });\n        } catch (error: any) {\n            console.error('Erro ao criar bug report:', error);\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: error.errors[0].message }, 400);\n            }\n            return c.json({ success: false, message: error.message || 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Listar meus bugs\n     */\n    static async listMyBugs(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n\n            const result = await getDbPool(c).query(\n                `SELECT id, title, category, severity, status, created_at, admin_notes, resolved_at\n                 FROM bug_reports\n                 WHERE user_id = $1\n                 ORDER BY created_at DESC\n                 LIMIT 50`,\n                [user.id]\n            );\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('Erro ao listar bugs:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar todos os bugs (Admin)\n     */\n    static async adminListAllBugs(c: Context) {\n        try {\n            const status = c.req.query('status') || 'open';\n\n            const result = await getDbPool(c).query(\n                `SELECT br.*, \n                        (SELECT COUNT(*) FROM bug_reports WHERE status = 'open') as total_open,\n                        (SELECT COUNT(*) FROM bug_reports WHERE status = 'in_progress') as total_in_progress\n                 FROM bug_reports br\n                 WHERE ($1 = 'all' OR br.status = $1)\n                 ORDER BY \n                    CASE br.severity \n                        WHEN 'critical' THEN 1 \n                        WHEN 'high' THEN 2 \n                        WHEN 'medium' THEN 3 \n                        ELSE 4 \n                    END,\n                    br.created_at DESC\n                 LIMIT 100`,\n                [status]\n            );\n\n            return c.json({\n                success: true,\n                data: result.rows,\n                counts: {\n                    open: result.rows[0]?.total_open || 0,\n                    inProgress: result.rows[0]?.total_in_progress || 0\n                }\n            });\n        } catch (error: any) {\n            console.error('Erro ao listar bugs (admin):', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar bug (Admin)\n     */\n    static async adminUpdateBug(c: Context) {\n        try {\n            const admin = c.get('user') as UserContext;\n            const bugId = parseInt(c.req.param('id'));\n            const body = await c.req.json();\n\n            const { status, adminNotes } = body;\n\n            if (!['open', 'in_progress', 'resolved', 'closed'].includes(status)) {\n                return c.json({ success: false, message: 'Status inv√°lido' }, 400);\n            }\n\n            const resolvedBy = status === 'resolved' || status === 'closed' ? admin.id : null;\n\n            await getDbPool(c).query(\n                `UPDATE bug_reports \n                 SET status = $1, \n                     admin_notes = COALESCE($2, admin_notes),\n                     resolved_by = COALESCE($3, resolved_by),\n                     resolved_at = ${status === 'resolved' || status === 'closed' ? 'CURRENT_TIMESTAMP' : 'resolved_at'},\n                     updated_at = CURRENT_TIMESTAMP\n                 WHERE id = $4`,\n                [status, adminNotes, resolvedBy, bugId]\n            );\n\n            return c.json({ success: true, message: 'Bug atualizado com sucesso!' });\n        } catch (error: any) {\n            console.error('Erro ao atualizar bug:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Excluir bug (Admin)\n     */\n    static async adminDeleteBug(c: Context) {\n        try {\n            const bugId = parseInt(c.req.param('id'));\n\n            await getDbPool(c).query('DELETE FROM bug_reports WHERE id = $1', [bugId]);\n\n            return c.json({ success: true, message: 'Bug exclu√≠do com sucesso!' });\n        } catch (error: any) {\n            console.error('Erro ao excluir bug:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/claims.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DELIVERY_CLAIM_TYPES' is defined but never used.","line":5,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"DELIVERY_CLAIM_TYPES"},"fix":{"range":[159,180],"text":""},"desc":"Remove unused variable \"DELIVERY_CLAIM_TYPES\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DELIVERY_INSURANCE_RATE' is defined but never used.","line":6,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":28,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"DELIVERY_INSURANCE_RATE"},"fix":{"range":[146,264],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'order' is assigned a value but never used.","line":72,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport {\n    DELIVERY_CLAIM_TYPES,\n    DELIVERY_INSURANCE_RATE\n} from '../../../shared/constants/business.constants';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n\n// Schema de valida√ß√£o para criar claim\nconst createClaimSchema = z.object({\n    orderId: z.number(),\n    claimType: z.enum(['LOST', 'DAMAGED', 'ACCIDENT', 'THEFT', 'OTHER']),\n    description: z.string().min(10, 'Descreva o ocorrido com pelo menos 10 caracteres'),\n    evidenceUrls: z.array(z.string()).optional()\n});\n\n// Schema para resolver claim (admin)\nconst resolveClaimSchema = z.object({\n    status: z.enum(['APPROVED', 'REJECTED']),\n    sellerRefund: z.number().min(0).optional(),\n    buyerRefund: z.number().min(0).optional(),\n    courierPenalty: z.number().min(0).optional(),\n    adminNotes: z.string().optional()\n});\n\n/**\n * Controller para gerenciar incidentes/claims de entregas\n */\nexport class ClaimsController {\n\n    /**\n     * Criar um novo claim (reportar problema)\n     * Usado pelo entregador quando ocorre um incidente\n     */\n    static async createClaim(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = createClaimSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({\n                    success: false,\n                    message: 'Dados inv√°lidos',\n                    errors: parseResult.error.errors\n                }, 400);\n            }\n\n            const { orderId, claimType, description, evidenceUrls } = parseResult.data;\n\n            // Verificar se o pedido existe e o usu√°rio √© o entregador\n            const orderCheck = await pool.query(\n                `SELECT mo.*, ml.title, ml.price, u_seller.name as seller_name, u_buyer.name as buyer_name\n                 FROM marketplace_orders mo\n                 LEFT JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                 LEFT JOIN users u_seller ON mo.seller_id = u_seller.id\n                 LEFT JOIN users u_buyer ON mo.buyer_id = u_buyer.id\n                 WHERE mo.id = $1 AND mo.courier_id = $2`,\n                [orderId, user.id]\n            );\n\n            if (orderCheck.rows.length === 0) {\n                return c.json({\n                    success: false,\n                    message: 'Pedido n√£o encontrado ou voc√™ n√£o √© o entregador.'\n                }, 404);\n            }\n\n            const order = orderCheck.rows[0];\n\n            // Verificar se j√° existe um claim para este pedido\n            const existingClaim = await pool.query(\n                `SELECT id FROM delivery_claims WHERE order_id = $1`,\n                [orderId]\n            );\n\n            if (existingClaim.rows.length > 0) {\n                return c.json({\n                    success: false,\n                    message: 'J√° existe um incidente reportado para este pedido.'\n                }, 400);\n            }\n\n            // Criar o claim\n            const result = await pool.query(\n                `INSERT INTO delivery_claims (order_id, courier_id, reported_by, claim_type, description, evidence_urls)\n                 VALUES ($1, $2, $3, $4, $5, $6)\n                 RETURNING id`,\n                [orderId, user.id, user.id, claimType, description, evidenceUrls || []]\n            );\n\n            const claimId = result.rows[0].id;\n\n            // Marcar o pedido como em disputa\n            await pool.query(\n                `UPDATE marketplace_orders SET status = 'DISPUTE', delivery_status = 'INCIDENT', updated_at = NOW() WHERE id = $1`,\n                [orderId]\n            );\n\n            // Notificar admin\n            await pool.query(\n                `INSERT INTO notifications (user_id, title, message, type)\n                 SELECT id, 'Incidente Reportado', $1, 'SYSTEM_ALERT'\n                 FROM users WHERE is_admin = true`,\n                [`Entregador reportou ${claimType} no pedido #${orderId}. Verificar imediatamente.`]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Incidente reportado com sucesso. Nossa equipe ir√° analisar.',\n                data: { claimId }\n            });\n        } catch (error) {\n            console.error('[CLAIMS] Erro ao criar claim:', error);\n            return c.json({ success: false, message: 'Erro ao reportar incidente' }, 500);\n        }\n    }\n\n    /**\n     * Listar claims pendentes (admin)\n     */\n    static async listClaims(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const status = c.req.query('status') || 'PENDING';\n\n            const result = await pool.query(`\n                SELECT \n                    dc.*,\n                    mo.amount as order_amount,\n                    mo.delivery_fee,\n                    ml.title as product_title,\n                    ml.price as product_price,\n                    u_courier.name as courier_name,\n                    u_courier.email as courier_email,\n                    u_seller.name as seller_name,\n                    u_buyer.name as buyer_name,\n                    dif.total_amount as insurance_available\n                FROM delivery_claims dc\n                LEFT JOIN marketplace_orders mo ON dc.order_id = mo.id\n                LEFT JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                LEFT JOIN users u_courier ON dc.courier_id = u_courier.id\n                LEFT JOIN users u_seller ON mo.seller_id = u_seller.id\n                LEFT JOIN users u_buyer ON mo.buyer_id = u_buyer.id\n                LEFT JOIN delivery_insurance_fund dif ON dif.order_id = mo.id AND dif.status = 'RESERVED'\n                WHERE dc.status = $1\n                ORDER BY dc.created_at DESC\n            `, [status]);\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (error) {\n            console.error('[CLAIMS] Erro ao listar claims:', error);\n            return c.json({ success: false, message: 'Erro ao listar incidentes' }, 500);\n        }\n    }\n\n    /**\n     * Resolver claim (aprovar ou rejeitar) - Admin\n     */\n    static async resolveClaim(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const claimId = c.req.param('id');\n            const body = await c.req.json();\n\n            const parseResult = resolveClaimSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({\n                    success: false,\n                    message: 'Dados inv√°lidos',\n                    errors: parseResult.error.errors\n                }, 400);\n            }\n\n            const { status, sellerRefund, buyerRefund, courierPenalty, adminNotes } = parseResult.data;\n\n            // Buscar claim e dados relacionados\n            const claimResult = await pool.query(`\n                SELECT dc.*, mo.seller_id, mo.buyer_id, mo.courier_id, mo.amount, mo.listing_id,\n                       dif.id as insurance_id, dif.total_amount as insurance_amount\n                FROM delivery_claims dc\n                LEFT JOIN marketplace_orders mo ON dc.order_id = mo.id\n                LEFT JOIN delivery_insurance_fund dif ON dif.order_id = mo.id AND dif.status = 'RESERVED'\n                WHERE dc.id = $1\n            `, [claimId]);\n\n            if (claimResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Claim n√£o encontrado' }, 404);\n            }\n\n            const claim = claimResult.rows[0];\n\n            if (claim.status !== 'PENDING') {\n                return c.json({ success: false, message: 'Este claim j√° foi resolvido' }, 400);\n            }\n\n            const client = await pool.connect();\n            try {\n                await client.query('BEGIN');\n\n                // Atualizar claim\n                await client.query(`\n                    UPDATE delivery_claims \n                    SET status = $1, seller_refund = $2, buyer_refund = $3, courier_penalty = $4,\n                        admin_notes = $5, resolved_by = $6, resolved_at = NOW()\n                    WHERE id = $7\n                `, [status, sellerRefund || 0, buyerRefund || 0, courierPenalty || 0, adminNotes, user.id, claimId]);\n\n                if (status === 'APPROVED') {\n                    // Usar o fundo de seguro\n                    if (claim.insurance_id) {\n                        await client.query(`\n                            UPDATE delivery_insurance_fund SET status = 'USED', used_for_claim_id = $1 WHERE id = $2\n                        `, [claimId, claim.insurance_id]);\n                    }\n\n                    // Devolver ao vendedor\n                    if (sellerRefund && sellerRefund > 0) {\n                        await client.query(\n                            `UPDATE users SET balance = balance + $1 WHERE id = $2`,\n                            [sellerRefund, claim.seller_id]\n                        );\n                        await client.query(`\n                            INSERT INTO transactions (user_id, type, amount, description, status)\n                            VALUES ($1, 'INSURANCE_REFUND', $2, $3, 'APPROVED')\n                        `, [claim.seller_id, sellerRefund, `Ressarcimento por incidente na entrega #${claim.order_id}`]);\n                    }\n\n                    // Devolver ao comprador\n                    if (buyerRefund && buyerRefund > 0) {\n                        await client.query(\n                            `UPDATE users SET balance = balance + $1 WHERE id = $2`,\n                            [buyerRefund, claim.buyer_id]\n                        );\n                        await client.query(`\n                            INSERT INTO transactions (user_id, type, amount, description, status)\n                            VALUES ($1, 'INSURANCE_REFUND', $2, $3, 'APPROVED')\n                        `, [claim.buyer_id, buyerRefund, `Reembolso por incidente na entrega #${claim.order_id}`]);\n                    }\n\n                    // Penalizar entregador\n                    if (courierPenalty && courierPenalty > 0) {\n                        await client.query(\n                            `UPDATE users SET balance = balance - $1 WHERE id = $2`,\n                            [courierPenalty, claim.courier_id]\n                        );\n                        await client.query(`\n                            INSERT INTO transactions (user_id, type, amount, description, status)\n                            VALUES ($1, 'INSURANCE_PENALTY', $2, $3, 'APPROVED')\n                        `, [claim.courier_id, -courierPenalty, `Penalidade por incidente na entrega #${claim.order_id}`]);\n                    }\n\n                    // Marcar pedido como cancelado/resolvido\n                    await client.query(\n                        `UPDATE marketplace_orders SET status = 'CANCELLED', delivery_status = 'RESOLVED', updated_at = NOW() WHERE id = $1`,\n                        [claim.order_id]\n                    );\n\n                    // Restaurar estoque do produto\n                    await client.query(\n                        `UPDATE marketplace_listings SET stock = stock + 1, status = 'ACTIVE' WHERE id = $1`,\n                        [claim.listing_id]\n                    );\n                } else {\n                    // Rejeitado - liberar seguro de volta ao entregador\n                    if (claim.insurance_id) {\n                        await client.query(`\n                            UPDATE delivery_insurance_fund SET status = 'RELEASED', released_at = NOW() WHERE id = $1\n                        `, [claim.insurance_id]);\n\n                        // Devolver contribui√ß√£o do entregador\n                        const insuranceResult = await client.query(\n                            `SELECT courier_contribution FROM delivery_insurance_fund WHERE id = $1`,\n                            [claim.insurance_id]\n                        );\n                        if (insuranceResult.rows.length > 0) {\n                            const courierContribution = parseFloat(insuranceResult.rows[0].courier_contribution);\n                            await client.query(\n                                `UPDATE users SET courier_insurance_balance = courier_insurance_balance + $1 WHERE id = $2`,\n                                [courierContribution, claim.courier_id]\n                            );\n                        }\n                    }\n\n                    // Pedido volta ao normal (se poss√≠vel)\n                    await client.query(\n                        `UPDATE marketplace_orders SET status = 'IN_TRANSIT', delivery_status = 'IN_TRANSIT', updated_at = NOW() WHERE id = $1`,\n                        [claim.order_id]\n                    );\n                }\n\n                // Notificar envolvidos\n                const notifyMessage = status === 'APPROVED'\n                    ? `Seu incidente #${claimId} foi aprovado. Os valores ser√£o processados.`\n                    : `Seu incidente #${claimId} foi rejeitado. ${adminNotes || 'Entre em contato para mais detalhes.'}`;\n\n                await client.query(`\n                    INSERT INTO notifications (user_id, title, message, type)\n                    VALUES ($1, 'Incidente Resolvido', $2, 'SYSTEM_ALERT')\n                `, [claim.courier_id, notifyMessage]);\n\n                await client.query('COMMIT');\n\n                return c.json({\n                    success: true,\n                    message: `Claim ${status === 'APPROVED' ? 'aprovado' : 'rejeitado'} com sucesso.`\n                });\n            } catch (error) {\n                await client.query('ROLLBACK');\n                throw error;\n            } finally {\n                client.release();\n            }\n        } catch (error) {\n            console.error('[CLAIMS] Erro ao resolver claim:', error);\n            return c.json({ success: false, message: 'Erro ao resolver incidente' }, 500);\n        }\n    }\n\n    /**\n     * Obter detalhes de um claim espec√≠fico\n     */\n    static async getClaimDetails(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const claimId = c.req.param('id');\n\n            const result = await pool.query(`\n                SELECT \n                    dc.*,\n                    mo.amount as order_amount,\n                    mo.delivery_fee,\n                    mo.delivery_address,\n                    mo.pickup_address,\n                    ml.title as product_title,\n                    ml.price as product_price,\n                    ml.image_url as product_image,\n                    u_courier.name as courier_name,\n                    u_courier.email as courier_email,\n                    u_courier.phone as courier_phone,\n                    u_seller.name as seller_name,\n                    u_buyer.name as buyer_name,\n                    dif.total_amount as insurance_available,\n                    dif.courier_contribution,\n                    dif.platform_contribution,\n                    u_resolver.name as resolved_by_name\n                FROM delivery_claims dc\n                LEFT JOIN marketplace_orders mo ON dc.order_id = mo.id\n                LEFT JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                LEFT JOIN users u_courier ON dc.courier_id = u_courier.id\n                LEFT JOIN users u_seller ON mo.seller_id = u_seller.id\n                LEFT JOIN users u_buyer ON mo.buyer_id = u_buyer.id\n                LEFT JOIN users u_resolver ON dc.resolved_by = u_resolver.id\n                LEFT JOIN delivery_insurance_fund dif ON dif.order_id = mo.id\n                WHERE dc.id = $1\n            `, [claimId]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Claim n√£o encontrado' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                data: result.rows[0]\n            });\n        } catch (error) {\n            console.error('[CLAIMS] Erro ao buscar claim:', error);\n            return c.json({ success: false, message: 'Erro ao buscar incidente' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/consortium.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2593,2596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2593,2596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3329,3332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3329,3332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4907,4910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4907,4910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9994,9997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9994,9997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":287,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14448,14451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14448,14451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15613,15616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15613,15616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":436,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":436,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22182,22185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22182,22185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":508,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":508,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26235,26238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26235,26238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":531,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":531,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27301,27304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27301,27304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":569,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":569,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29137,29140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29137,29140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":588,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":588,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29798,29801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29798,29801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":633,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":633,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31544,31547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31544,31547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":671,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":671,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33116,33119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33116,33119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":710,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":710,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35336,35339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35336,35339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":760,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":760,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37830,37833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37830,37833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":786,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":786,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39034,39037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39034,39037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":851,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":851,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42139,42142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42139,42142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction } from '../../../domain/services/transaction.service';\nimport { PoolClient } from 'pg';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport class ConsortiumController {\n\n    // --- GRUPOS (Admin) ---\n\n    static async createGroup(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            const {\n                name, totalValue, durationMonths, adminFeePercent,\n                startDate, reserveFeePercent, fixedBidPercent,\n                maxEmbeddedBidPercent, minMembersToStart,\n                annualAdjustmentPercent\n            } = await c.req.json();\n            const pool = getDbPool(c);\n\n            // Gera√ß√£o Autom√°tica do Identificador (Ex: GRP-001)\n            const countRes = await pool.query('SELECT COUNT(*) as total FROM consortium_groups');\n            const nextNum = (parseInt(countRes.rows[0].total) + 1).toString().padStart(3, '0');\n            const groupIdentifier = `GRP-${nextNum}`;\n\n            // Calcula parcela: (Valor + Taxa + Reserva) / Prazo\n            // Nota: O fundo de reserva √© calculado sobre o valor da carta\n            const adminFee = Number(totalValue) * (Number(adminFeePercent) / 100);\n            const reserveFee = Number(totalValue) * (Number(reserveFeePercent || 1) / 100);\n            const installmentValue = (Number(totalValue) + adminFee + reserveFee) / Number(durationMonths);\n\n            const result = await pool.query(\n                `INSERT INTO consortium_groups \n                (name, total_value, duration_months, admin_fee_percent, monthly_installment_value, \n                 start_date, status, reserve_fee_percent, fixed_bid_percent, \n                 max_embedded_bid_percent, min_members_to_start, group_identifier, annual_adjustment_percent)\n                VALUES ($1, $2, $3, $4, $5, $6, 'OPEN', $7, $8, $9, $10, $11, $12)\n                RETURNING *`,\n                [\n                    name, totalValue, durationMonths, adminFeePercent, installmentValue,\n                    startDate, reserveFeePercent || 1, fixedBidPercent || 30,\n                    maxEmbeddedBidPercent || 30, minMembersToStart || 10,\n                    groupIdentifier, annualAdjustmentPercent || 0\n                ]\n            );\n\n            return c.json({ success: true, group: result.rows[0] });\n\n        } catch (error: any) {\n            console.error('Erro ao criar grupo:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // --- GRUPOS (Leitura) ---\n\n    static async listGroups(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query(`\n                SELECT cg.*, \n                       (SELECT COUNT(*)::int FROM consortium_members cm WHERE cm.group_id = cg.id) as member_count\n                FROM consortium_groups cg\n                WHERE cg.status IN ('OPEN', 'ACTIVE', 'COMPLETED') \n                ORDER BY cg.created_at DESC\n            `);\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async myConsortiums(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT cm.*, cg.name as group_name, cg.total_value, cg.monthly_installment_value, cg.duration_months,\n                       cg.admin_fee_percent, cg.reserve_fee_percent,\n                       cg.status as group_status, cg.current_assembly_number, cg.current_pool,\n                       (cg.duration_months - cm.paid_installments) as remaining_installments,\n                       ((cg.duration_months - cm.paid_installments) * cg.monthly_installment_value) as total_remaining_due,\n                       (SELECT amount FROM consortium_bids WHERE member_id = cm.id ORDER BY amount DESC LIMIT 1) as my_bid_amount,\n                       (SELECT u.name FROM consortium_assemblies ca \n                        JOIN consortium_members win_cm ON ca.winner_member_id = win_cm.id\n                        JOIN users u ON win_cm.user_id = u.id\n                        WHERE ca.group_id = cg.id AND ca.status = 'FINISHED'\n                        ORDER BY ca.assembly_number DESC LIMIT 1) as last_winner_name\n                FROM consortium_members cm\n                JOIN consortium_groups cg ON cm.group_id = cg.id\n                WHERE cm.user_id = $1\n            `, [user.id]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // --- A√á√ïES DO USU√ÅRIO ---\n\n    static async joinGroup(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { groupId } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Verifica Grupo e Status\n                const groupRes = await client.query('SELECT * FROM consortium_groups WHERE id = $1 FOR UPDATE', [groupId]);\n                if (groupRes.rows.length === 0) throw new Error('Grupo n√£o encontrado.');\n                const group = groupRes.rows[0];\n\n                if (group.status !== 'OPEN') throw new Error('Este grupo n√£o aceita mais ades√µes.');\n\n                // 2. Verifica se j√° est√° no grupo\n                const existing = await client.query(\n                    'SELECT id FROM consortium_members WHERE group_id = $1 AND user_id = $2',\n                    [groupId, user.id]\n                );\n                if (existing.rows.length > 0) throw new Error('Voc√™ j√° participa deste grupo.');\n\n                // 3. Verifica Saldo para 1¬™ Parcela (Entrada)\n                const entryCost = Number(group.monthly_installment_value);\n                const userBal = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n\n                if (Number(userBal.rows[0].balance) < entryCost) {\n                    throw new Error(`Saldo insuficiente. A entrada custa R$ ${entryCost.toFixed(2)}.`);\n                }\n\n\n                // 4. Determina n√∫mero da cota (Sequencial)\n                const quotaRes = await client.query('SELECT COUNT(*) as total FROM consortium_members WHERE group_id = $1', [groupId]);\n                const nextQuota = Number(quotaRes.rows[0].total) + 1;\n\n                // 5. Calcula taxa administrativa e valor l√≠quido para o pool\n                const adminFeePercent = Number(group.admin_fee_percent || 10);\n                const adminFee = entryCost * (adminFeePercent / 100);\n                const poolContribution = entryCost - adminFee;\n\n                // Divis√£o da taxa: 80% para cotistas (profit_pool), 20% para o projeto (owner_profit)\n                const cotistasShare = adminFee * 0.8;\n                const platformShare = adminFee * 0.2;\n\n                // 6. Debita do usu√°rio\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [entryCost, user.id]);\n\n                // 7. Acumula no pool do grupo (valor l√≠quido + reserva)\n                await client.query(`\n                    UPDATE consortium_groups \n                    SET current_pool = COALESCE(current_pool, 0) + $1,\n                        current_pool_available = COALESCE(current_pool_available, 0) + $1\n                    WHERE id = $2\n                `, [poolContribution, groupId]);\n\n                // 8. Taxas divididas entre cotistas e plataforma\n                await client.query(`\n                    UPDATE system_config \n                    SET profit_pool = COALESCE(profit_pool, 0) + $1,\n                        total_owner_profit = COALESCE(total_owner_profit, 0) + $2\n                    WHERE id = 1\n                `, [cotistasShare, platformShare]);\n\n                // 9. Registra transa√ß√£o de sa√≠da (D√©bito do usu√°rio)\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                    VALUES ($1, 'CONSORTIUM_ENTRY', $2, $3, 'APPROVED', NOW())\n                `, [user.id, -entryCost, `Entrada Cons√≥rcio: ${group.name} (Cota ${nextQuota})`]);\n\n                // 10. Registra receita da taxa admin\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                    VALUES ($1, 'CONSORTIUM_ADMIN_FEE', $2, $3, 'APPROVED', NOW())\n                `, [user.id, adminFee, `Taxa Admin Cons√≥rcio: ${group.name}`]);\n\n                // 11. Pr√≥ximo vencimento = 30 dias a partir de hoje\n                const nextDueDate = new Date();\n                nextDueDate.setDate(nextDueDate.getDate() + 30);\n\n                // 12. Insere membro com tracking de pagamentos\n                await client.query(`\n                    INSERT INTO consortium_members (group_id, user_id, quota_number, status, paid_installments, total_paid, next_due_date)\n                    VALUES ($1, $2, $3, 'ACTIVE', 1, $4, $5)\n                `, [groupId, user.id, nextQuota, entryCost, nextDueDate.toISOString().split('T')[0]]);\n\n                return { success: true, message: `Bem-vindo ao grupo! Sua cota √© #${nextQuota}. Pool: R$${poolContribution.toFixed(2)} | Taxa: R$${adminFee.toFixed(2)}` };\n            });\n\n            if (result.success) {\n                return c.json(result.data);\n            } else {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 400);\n        }\n    }\n\n    // --- PAGAMENTOS MENSAIS ---\n\n    static async payInstallment(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { memberId } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Validar Membro e Grupo\n                const memberRes = await client.query(`\n                    SELECT cm.*, cg.name as group_name, cg.monthly_installment_value, cg.admin_fee_percent, cg.id as group_id,\n                           cg.total_value, cg.duration_months, cg.reserve_fee_percent\n                    FROM consortium_members cm\n                    JOIN consortium_groups cg ON cm.group_id = cg.id\n                    WHERE cm.id = $1 AND cm.user_id = $2\n                `, [memberId, user.id]);\n\n                if (memberRes.rows.length === 0) throw new Error('Membro n√£o encontrado.');\n                const member = memberRes.rows[0];\n\n                // 2. Verificar Saldo\n                const installmentValue = Number(member.monthly_installment_value);\n                const userRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                if (Number(userRes.rows[0].balance) < installmentValue) {\n                    throw new Error('Saldo insuficiente para pagar a parcela.');\n                }\n\n                // 3. Calcular Taxa Admin e Pool (Baseado no valor da Carta e n√£o da parcela total)\n                const totalValue = Number(member.total_value); // Precisa vir da query\n                const duration = Number(member.duration_months); // Precisa vir da query\n\n                // Recalcular base para garantir precis√£o\n                const baseShare = totalValue / duration;\n                const adminFeeVal = (totalValue * (Number(member.admin_fee_percent || 10) / 100)) / duration;\n                const reserveFeeVal = (totalValue * (Number(member.reserve_fee_percent || 1) / 100)) / duration;\n\n                // 4. Executar D√©bito e Cr√©ditos\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [installmentValue, user.id]);\n\n                // Fundo Comum -> Paga as cartas\n                await client.query(`\n                    UPDATE consortium_groups \n                    SET current_pool = COALESCE(current_pool, 0) + $1,\n                        current_pool_available = COALESCE(current_pool_available, 0) + $1,\n                        reserve_pool = COALESCE(reserve_pool, 0) + $2\n                    WHERE id = $3\n                `, [baseShare, reserveFeeVal, member.group_id]);\n\n                // Taxa Adm -> Lucro do Sistema (80% Investidores / 20% Plataforma)\n                const cotistasShare = adminFeeVal * 0.8;\n                const platformShare = adminFeeVal * 0.2;\n\n                await client.query(`\n                    UPDATE system_config \n                    SET profit_pool = COALESCE(profit_pool, 0) + $1,\n                        total_owner_profit = COALESCE(total_owner_profit, 0) + $2\n                    WHERE id = 1\n                `, [cotistasShare, platformShare]);\n\n                // 5. Atualizar Membro\n                const nextDueDate = new Date(member.next_due_date || new Date());\n                nextDueDate.setMonth(nextDueDate.getMonth() + 1);\n\n                await client.query(`\n                    UPDATE consortium_members \n                    SET paid_installments = paid_installments + 1,\n                        total_paid = COALESCE(total_paid, 0) + $1,\n                        next_due_date = $2\n                    WHERE id = $3\n                `, [installmentValue, nextDueDate.toISOString().split('T')[0], memberId]);\n\n                // 6. Registrar Transa√ß√µes\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                    VALUES ($1, 'CONSORTIUM_PAY', $2, $3, 'APPROVED', NOW())\n                `, [user.id, -installmentValue, `Parcela Cons√≥rcio: ${member.group_name} (${member.paid_installments + 1}¬™)`]);\n\n                return { success: true, message: 'Parcela paga com sucesso!' };\n            });\n\n            return c.json(result.data || { success: false, message: result.error });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 400);\n        }\n    }\n\n    // --- ADMIN: GERENCIAMENTO DE ASSEMBLEIAS ---\n\n    static async createAssembly(c: Context) {\n        try {\n            const { groupId, monthYear } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const groupRes = await pool.query('SELECT current_assembly_number FROM consortium_groups WHERE id = $1', [groupId]);\n            if (groupRes.rows.length === 0) return c.json({ success: false, message: 'Grupo n√£o encontrado.' }, 404);\n\n            const nextNumber = (groupRes.rows[0].current_assembly_number || 0) + 1;\n\n            const assemblyRes = await pool.query(`\n                INSERT INTO consortium_assemblies (group_id, assembly_number, month_year, status)\n                VALUES ($1, $2, $3, 'OPEN_FOR_BIDS')\n                RETURNING id\n            `, [groupId, nextNumber, monthYear]);\n\n            await pool.query('UPDATE consortium_groups SET current_assembly_number = $1 WHERE id = $2', [nextNumber, groupId]);\n\n            return c.json({ success: true, assemblyId: assemblyRes.rows[0].id });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async closeAssembly(c: Context) {\n        try {\n            const { assemblyId, winnerMemberId, winningBidAmount } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Buscar Assembleia\n                const assemblyRes = await client.query('SELECT * FROM consortium_assemblies WHERE id = $1', [assemblyId]);\n                if (assemblyRes.rows.length === 0) throw new Error('Assembleia n√£o encontrada.');\n                const assembly = assemblyRes.rows[0];\n\n                // 2. Buscar Grupo\n                const groupRes = await client.query('SELECT * FROM consortium_groups WHERE id = $1', [assembly.group_id]);\n                const group = groupRes.rows[0];\n\n                // 3. Se houver vencedor, processar contempla√ß√£o\n                if (winnerMemberId) {\n                    const memberRes = await client.query('SELECT * FROM consortium_members WHERE id = $1', [winnerMemberId]);\n                    const member = memberRes.rows[0];\n\n                    const totalCredit = Number(group.total_value);\n                    const bidAmount = Number(winningBidAmount || 0);\n\n                    const bidRes = await client.query('SELECT * FROM consortium_bids WHERE assembly_id = $1 AND member_id = $2', [assemblyId, winnerMemberId]);\n                    const bid = bidRes.rows[0];\n\n                    let finalCreditValue = totalCredit;\n\n                    // --- L√ìGICA DE PAGAMENTO DO LANCE ---\n                    if (bid && !bid.is_embedded && bidAmount > 0) {\n                        // Lance Livre: O usu√°rio paga do bolso\n                        const userBal = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [member.user_id]);\n                        if (Number(userBal.rows[0].balance) < bidAmount) {\n                            throw new Error('O vencedor n√£o tem saldo suficiente para honrar o lance livre.');\n                        }\n\n                        // 1. Debitar Usuario\n                        await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [bidAmount, member.user_id]);\n\n                        // 2. Registrar no Pool (Entra como antecipa√ß√£o)\n                        await client.query(`UPDATE consortium_groups SET current_pool = current_pool + $1 WHERE id = $2`, [bidAmount, group.id]);\n\n                        // 3. Amortizar Parcelas (De tr√°s pra frente ou apenas reduzir saldo devedor)\n                        // L√≥gica Simplificada: Aumentar o total pago e numero de parcelas eq\n                        const installmentVal = Number(group.monthly_installment_value);\n                        const installmentsPaidByBid = Math.floor(bidAmount / installmentVal);\n\n                        await client.query(`\n                            UPDATE consortium_members \n                            SET paid_installments = paid_installments + $1,\n                                total_paid = total_paid + $2\n                            WHERE id = $3\n                        `, [installmentsPaidByBid, bidAmount, winnerMemberId]);\n\n                        await client.query(`\n                            INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                            VALUES ($1, 'CONSORTIUM_BID_PAY', $2, $3, 'APPROVED', NOW())\n                        `, [member.user_id, -bidAmount, `Pagamento de Lance: ${group.name}`]);\n                    }\n                    else if (bid && bid.is_embedded) {\n                        // Lance Embutido: Desconta da carta\n                        finalCreditValue = totalCredit - Number(bid.embedded_amount || 0);\n\n                        // Consideramos o valor embutido como \"pago\" para fins de amortiza√ß√£o da d√≠vida?\n                        // Geralmente sim, pois ele abriu m√£o do cr√©dito para quitar d√≠vida.\n                        const installmentsPaidByBid = Math.floor(Number(bid.embedded_amount) / Number(group.monthly_installment_value));\n\n                        await client.query(`\n                            UPDATE consortium_members \n                            SET paid_installments = paid_installments + $1,\n                                total_paid = total_paid + $2\n                            WHERE id = $3\n                        `, [installmentsPaidByBid, Number(bid.embedded_amount), winnerMemberId]);\n                    }\n\n                    // Apenas atualiza o status do cr√©dito para PENDING\n                    await client.query(`\n                        UPDATE consortium_members \n                        SET status = 'CONTEMPLATED', \n                            contemplated_at = NOW(),\n                            credit_status = 'PENDING'\n                        WHERE id = $1\n                    `, [winnerMemberId]);\n\n                    // Deduz o pr√™mio do saldo dispon√≠vel do grupo (reserva o valor)\n                    await client.query(`\n                        UPDATE consortium_groups \n                        SET current_pool_available = current_pool_available - $1\n                        WHERE id = $2\n                    `, [totalCredit, group.id]);\n\n                    await client.query(`\n                        INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                        VALUES ($1, 'CONSORTIUM_AWARD', $2, $3, 'PENDING', NOW())\n                    `, [member.user_id, finalCreditValue, `Cr√©dito Cons√≥rcio: ${group.name}${bid?.is_embedded ? ' (Lance Embutido)' : ''} - Aguardando Garantia`]);\n\n                    if (bid) {\n                        await client.query(`\n                            UPDATE consortium_bids SET status = 'WINNER' \n                            WHERE id = $1\n                        `, [bid.id]);\n                    }\n                }\n\n                // 4. Fechar Assembleia\n                await client.query(`\n                    UPDATE consortium_assemblies \n                    SET status = 'FINISHED', \n                        winner_member_id = $1, \n                        winning_bid_amount = $2,\n                        finished_at = NOW()\n                    WHERE id = $3\n                `, [winnerMemberId, winningBidAmount, assemblyId]);\n\n                return { success: true };\n            });\n\n            return c.json(result.data || { success: false, message: result.error });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async approveCredit(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            const { memberId, guaranteeDescription, partnerId, invoiceUrl } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Validar Membro e se foi Contemplado\n                const memberRes = await client.query('SELECT * FROM consortium_members WHERE id = $1 FOR UPDATE', [memberId]);\n                if (memberRes.rows.length === 0) throw new Error('Membro n√£o encontrado.');\n                const member = memberRes.rows[0];\n\n                if (member.status !== 'CONTEMPLATED') throw new Error('Este membro ainda n√£o foi contemplado.');\n                if (member.credit_status === 'APPROVED') throw new Error('Cr√©dito j√° foi liberado.');\n\n                // 1.5 Validar Parceiro (Lojista)\n                if (!partnerId) throw new Error('√â obrigat√≥rio informar o ID do Lojista Parceiro.');\n                const partnerRes = await client.query('SELECT id, name, role FROM users WHERE id = $1', [partnerId]);\n                if (partnerRes.rows.length === 0) throw new Error('Lojista parceiro n√£o encontrado.');\n                // Opcional: Verificar se role √© 'SELLER' ou 'PARTNER' se houver essa distin√ß√£o. Por hora, qualquer user serve.\n                const partner = partnerRes.rows[0];\n\n                // 2. Buscar o valor do cr√©dito (considerando lance embutido)\n                const groupRes = await client.query('SELECT total_value, name FROM consortium_groups WHERE id = $1', [member.group_id]);\n                const group = groupRes.rows[0];\n\n                const bidRes = await client.query('SELECT * FROM consortium_bids WHERE member_id = $1 AND status = \\'WINNER\\'', [memberId]);\n                const bid = bidRes.rows[0];\n\n                let finalCreditValue = Number(group.total_value);\n                if (bid && bid.is_embedded) {\n                    finalCreditValue -= Number(bid.embedded_amount || 0);\n                }\n\n                // 3. Liberar o saldo na conta do PARCEIRO (Lojista) e aprovar status\n                // AQUI EST√Å A MUDAN√áA: member.user_id -> partnerId\n                await client.query('UPDATE users SET balance = balance + $1 WHERE id = $2', [finalCreditValue, partnerId]);\n\n                await client.query(`\n                    UPDATE consortium_members \n                    SET credit_status = 'APPROVED', \n                        guarantee_description = $1,\n                        invoice_url = $2,\n                        credit_limit_released = $3\n                    WHERE id = $4\n                `, [guaranteeDescription, invoiceUrl, finalCreditValue, memberId]);\n\n                // 4. Atualizar transa√ß√£o de pendente para aprovado\n                await client.query(`\n                    UPDATE transactions \n                    SET status = 'APPROVED', \n                        description = description || ' (Cr√©dito Pago ao Lojista: ' || $1 || ')' \n                    WHERE user_id = $2 AND type = 'CONSORTIUM_AWARD' AND status = 'PENDING'\n                `, [partner.name, member.user_id]);\n\n                // 5. Registrar entrada no extrato do Lojista\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status, created_at)\n                    VALUES ($1, 'SALE_RECEIPT', $2, $3, 'APPROVED', NOW())\n                `, [partnerId, finalCreditValue, `Venda Cons√≥rcio: ${group.name} (Cliente: ${member.user_id})`]);\n\n                return { success: true, message: `Cr√©dito liberado com sucesso para o parceiro ${partner.name}.` };\n            });\n\n            return c.json(result.success ? result : { success: false, message: result.error });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async addMemberDocument(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { memberId, documentType, documentUrl } = await c.req.json();\n            const pool = getDbPool(c);\n\n            // Se for usu√°rio comum, s√≥ pode enviar para si mesmo\n            if (!user.isAdmin) {\n                const memberCheck = await pool.query('SELECT id FROM consortium_members WHERE id = $1 AND user_id = $2', [memberId, user.id]);\n                if (memberCheck.rows.length === 0) return c.json({ success: false, message: 'N√£o autorizado' }, 403);\n            }\n\n            await pool.query(`\n                INSERT INTO consortium_member_documents (member_id, document_type, document_url, status)\n                VALUES ($1, $2, $3, 'PENDING')\n            `, [memberId, documentType, documentUrl]);\n\n            return c.json({ success: true, message: 'Documento enviado para an√°lise.' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async getPerformanceStats(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            const pool = getDbPool(c);\n\n            // 1. Total arrecadado em todos os pools\n            const poolRes = await pool.query('SELECT SUM(current_pool) as total_pool, SUM(current_pool_available) as total_available FROM consortium_groups');\n\n            // 2. Lucro da plataforma (config)\n            const statsRes = await pool.query('SELECT total_owner_profit, profit_pool FROM system_config WHERE id = 1');\n\n            // 3. Contagens\n            const countsRes = await pool.query(`\n                SELECT \n                    (SELECT COUNT(*) FROM consortium_groups) as total_groups,\n                    (SELECT COUNT(*) FROM consortium_members) as total_members,\n                    (SELECT COUNT(*) FROM consortium_members WHERE status = 'CONTEMPLATED') as total_contemplated\n            `);\n\n            return c.json({\n                success: true,\n                data: {\n                    totalPool: Number(poolRes.rows[0].total_pool || 0),\n                    totalAvailable: Number(poolRes.rows[0].total_available || 0),\n                    ownerProfit: Number(statsRes.rows[0].total_owner_profit || 0),\n                    investorsProfit: Number(statsRes.rows[0].profit_pool || 0),\n                    totalGroups: Number(countsRes.rows[0].total_groups || 0),\n                    totalMembers: Number(countsRes.rows[0].total_members || 0),\n                    totalContemplated: Number(countsRes.rows[0].total_contemplated || 0)\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async listMembers(c: Context) {\n        try {\n            const groupId = c.req.param('groupId');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT cm.*, u.name as user_name, u.email as user_email\n                FROM consortium_members cm\n                JOIN users u ON cm.user_id = u.id\n                WHERE cm.group_id = $1\n                ORDER BY cm.quota_number ASC\n            `, [groupId]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // --- INTERA√á√ÉO COM ASSEMBLEIAS ---\n\n    static async getActiveAssembly(c: Context) {\n        try {\n            const groupId = c.req.param('groupId');\n            const pool = getDbPool(c);\n\n            // Pega a assembleia atual ou a √∫ltima para o grupo\n            const result = await pool.query(`\n                SELECT ca.*, cg.name as group_name, cg.total_value, cg.current_pool\n                FROM consortium_assemblies ca\n                JOIN consortium_groups cg ON ca.group_id = cg.id\n                WHERE ca.group_id = $1\n                ORDER BY ca.assembly_number DESC\n                LIMIT 1\n            `, [groupId]);\n\n            if (result.rows.length === 0) return c.json({ success: true, data: null });\n\n            const assembly = result.rows[0];\n\n            // Buscar lances\n            const bidsRes = await pool.query(`\n                SELECT cb.*, u.name as user_name,\n                       (SELECT COUNT(*) FROM consortium_votes cv WHERE cv.target_bid_id = cb.id AND cv.vote = true) as votes_yes,\n                       (SELECT COUNT(*) FROM consortium_votes cv WHERE cv.target_bid_id = cb.id AND cv.vote = false) as votes_no\n                FROM consortium_bids cb\n                JOIN consortium_members cm ON cb.member_id = cm.id\n                JOIN users u ON cm.user_id = u.id\n                WHERE cb.assembly_id = $1\n                ORDER BY cb.amount DESC\n            `, [assembly.id]);\n\n            return c.json({\n                success: true,\n                data: {\n                    ...assembly,\n                    bids: bidsRes.rows\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async getAssembly(c: Context) {\n        try {\n            const assemblyId = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const assemblyRes = await pool.query(`\n                SELECT ca.*, cg.name as group_name, cg.total_value, cg.current_pool\n                FROM consortium_assemblies ca\n                JOIN consortium_groups cg ON ca.group_id = cg.id\n                WHERE ca.id = $1\n            `, [assemblyId]);\n\n            if (assemblyRes.rows.length === 0) return c.json({ success: false, message: 'Assembleia n√£o encontrada' }, 404);\n            const assembly = assemblyRes.rows[0];\n\n            const bidsRes = await pool.query(`\n                SELECT cb.*, u.name as user_name,\n                       (SELECT COUNT(*) FROM consortium_votes cv WHERE cv.target_bid_id = cb.id AND cv.vote = true) as votes_yes,\n                       (SELECT COUNT(*) FROM consortium_votes cv WHERE cv.target_bid_id = cb.id AND cv.vote = false) as votes_no\n                FROM consortium_bids cb\n                JOIN consortium_members cm ON cb.member_id = cm.id\n                JOIN users u ON cm.user_id = u.id\n                WHERE cb.assembly_id = $1\n                ORDER BY cb.amount DESC\n            `, [assemblyId]);\n\n            return c.json({\n                success: true,\n                data: {\n                    ...assembly,\n                    bids: bidsRes.rows\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async placeBid(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { assemblyId, memberId, amount, bidType, isEmbedded, embeddedAmount } = await c.req.json();\n            const pool = getDbPool(c);\n\n            // Validar se o membro pertence ao usu√°rio\n            const memberCheck = await pool.query('SELECT id FROM consortium_members WHERE id = $1 AND user_id = $2', [memberId, user.id]);\n            if (memberCheck.rows.length === 0) return c.json({ success: false, message: 'Membro inv√°lido ou n√£o autorizado' }, 403);\n\n            // Verificar se a assembleia est√° aberta para lances\n            const assemblyRes = await pool.query('SELECT status FROM consortium_assemblies WHERE id = $1', [assemblyId]);\n            if (assemblyRes.rows.length === 0) return c.json({ success: false, message: 'Assembleia n√£o encontrada' }, 404);\n            if (assemblyRes.rows[0].status !== 'OPEN_FOR_BIDS') return c.json({ success: false, message: 'Assembleia n√£o aceita lances no momento.' }, 400);\n\n            // Se n√£o for embutido, verificar saldo\n            if (!isEmbedded) {\n                const userBal = await pool.query('SELECT balance FROM users WHERE id = $1', [user.id]);\n                if (Number(userBal.rows[0].balance) < Number(amount)) {\n                    return c.json({ success: false, message: 'Saldo insuficiente para ofertar este lance.' }, 400);\n                }\n            }\n\n            await pool.query(`\n                INSERT INTO consortium_bids (assembly_id, member_id, amount, status, bid_type, is_embedded, embedded_amount)\n                VALUES ($1, $2, $3, 'PENDING', $4, $5, $6)\n                ON CONFLICT (assembly_id, member_id) DO UPDATE SET \n                    amount = $3, \n                    bid_type = $4, \n                    is_embedded = $5, \n                    embedded_amount = $6\n            `, [assemblyId, memberId, amount, bidType || 'FREE', isEmbedded || false, embeddedAmount || 0]);\n\n            return c.json({ success: true, message: 'Lance registrado com sucesso!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async withdraw(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { memberId } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Validar Membro\n                const memberRes = await client.query(`\n                    SELECT * FROM consortium_members WHERE id = $1 AND user_id = $2 FOR UPDATE\n                `, [memberId, user.id]);\n\n                if (memberRes.rows.length === 0) throw new Error('Membro n√£o encontrado.');\n                const member = memberRes.rows[0];\n\n                if (member.status === 'CONTEMPLATED') throw new Error('Cotas contempladas n√£o podem ser canceladas desta forma.');\n                if (member.status === 'WITHDRAWN') throw new Error('Esta cota j√° foi cancelada.');\n\n                // 2. Calcular Multa e Reembolso\n                const totalPaidToPool = Number(member.total_paid || 0);\n                const penaltyAmount = totalPaidToPool * 0.20; // 20% de multa\n                const refundAmount = totalPaidToPool - penaltyAmount;\n\n                // 3. Registrar Retirada\n                await client.query(`\n                    INSERT INTO consortium_withdrawals (member_id, total_paid_to_pool, penalty_amount, refund_amount_due, status)\n                    VALUES ($1, $2, $3, $4, 'PENDING')\n                `, [memberId, totalPaidToPool, penaltyAmount, refundAmount]);\n\n                // 4. Atualizar Membro\n                await client.query(`UPDATE consortium_members SET status = 'WITHDRAWN' WHERE id = $1`, [memberId]);\n\n                // 5. O valor da multa vai para o lucro da plataforma (ou fundo de reserva conforme regra)\n                // Aqui vamos colocar como plataforma para o Josias ver o lucro\n                await client.query(`\n                    UPDATE system_config SET total_owner_profit = total_owner_profit + $1 WHERE id = 1\n                `, [penaltyAmount]);\n\n                return {\n                    success: true,\n                    message: `Cancelamento realizado. Reembolso pendente de R$ ${refundAmount.toFixed(2)} (Multa de R$ ${penaltyAmount.toFixed(2)} aplicada).`\n                };\n            });\n\n            return c.json(result.data || { success: false, message: result.error });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    static async voteOnBid(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { bidId, vote } = await c.req.json();\n            const pool = getDbPool(c);\n\n            // Pegar assembly_id atrav√©s do bid\n            const bidRes = await pool.query('SELECT assembly_id FROM consortium_bids WHERE id = $1', [bidId]);\n            if (bidRes.rows.length === 0) return c.json({ success: false, message: 'Lance n√£o encontrado' }, 404);\n            const assemblyId = bidRes.rows[0].assembly_id;\n\n            // Verificar se a assembleia est√° em fase de vota√ß√£o (ou permitindo votos)\n            // No modelo simplificado, permitimos votar enquanto aberta\n\n            await pool.query(`\n                INSERT INTO consortium_votes (assembly_id, voter_id, target_bid_id, vote)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (assembly_id, voter_id, target_bid_id) DO UPDATE SET vote = $4\n            `, [assemblyId, user.id, bidId, vote]);\n\n            return c.json({ success: true, message: 'Voto registrado!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // --- REAJUSTE ANUAL ---\n\n    static async adjustAnnualValue(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            const { groupId, adjustmentPercent, customNewValue } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Buscar grupo\n                const groupRes = await client.query('SELECT * FROM consortium_groups WHERE id = $1 FOR UPDATE', [groupId]);\n                if (groupRes.rows.length === 0) throw new Error('Grupo n√£o encontrado.');\n                const group = groupRes.rows[0];\n\n                const oldTotalValue = Number(group.total_value);\n                let newTotalValue = oldTotalValue;\n\n                if (customNewValue) {\n                    newTotalValue = Number(customNewValue);\n                } else if (adjustmentPercent) {\n                    newTotalValue = oldTotalValue * (1 + (Number(adjustmentPercent) / 100));\n                } else {\n                    const groupAdjPercent = Number(group.annual_adjustment_percent || 0);\n                    if (groupAdjPercent === 0) throw new Error('Nenhuma porcentagem de reajuste definida para este grupo.');\n                    newTotalValue = oldTotalValue * (1 + (groupAdjPercent / 100));\n                }\n\n                const finalPercent = ((newTotalValue / oldTotalValue) - 1) * 100;\n\n                // 2. Recalcular Parcela: (Novo Valor + Taxas) / Prazo Total\n                // Mantemos as taxas originais do grupo\n                const adminFee = newTotalValue * (Number(group.admin_fee_percent) / 100);\n                const reserveFee = newTotalValue * (Number(group.reserve_fee_percent || 1) / 100);\n                const newInstallmentValue = (newTotalValue + adminFee + reserveFee) / Number(group.duration_months);\n\n                // 3. Atualizar Grupo\n                await client.query(`\n                    UPDATE consortium_groups \n                    SET total_value = $1, \n                        monthly_installment_value = $2,\n                        updated_at = NOW()\n                    WHERE id = $3\n                `, [newTotalValue, newInstallmentValue, groupId]);\n\n                // 4. Registrar Hist√≥rico\n                await client.query(`\n                    INSERT INTO consortium_adjustment_history (group_id, old_value, new_value, adjustment_percent)\n                    VALUES ($1, $2, $3, $4)\n                `, [groupId, oldTotalValue, newTotalValue, finalPercent]);\n\n                return {\n                    success: true,\n                    message: `Reajuste aplicado! Valor: R$${newTotalValue.toFixed(2)} | Parcela: R$${newInstallmentValue.toFixed(2)}`\n                };\n            });\n\n            return c.json(result.data || { success: false, message: result.error });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/earn.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createTransaction' is defined but never used.","line":3,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":49,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"createTransaction"},"fix":{"range":[150,169],"text":""},"desc":"Remove unused variable \"createTransaction\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'REWARDS_CATALOG' is assigned a value but never used.","line":21,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'generateVoucherCode' is defined but never used.","line":35,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5275,5278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5275,5278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6658,6661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6658,6661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8715,8718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8715,8718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9589,9592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9589,9592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":275,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10834,10837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10834,10837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":380,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15605,15608],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15605,15608],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":425,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17138,17141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17138,17141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, createTransaction } from '../../../domain/services/transaction.service';\nimport { PoolClient } from 'pg';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { PointsService, VALUE_PER_1000_POINTS, MIN_POINTS_FOR_CONVERSION } from '../../../application/services/points.service';\n\n// Constantes do sistema de pontos\n// Constantes sincronizadas com PointsService\nconst POINTS_RATE = MIN_POINTS_FOR_CONVERSION;\nconst MONEY_VALUE = VALUE_PER_1000_POINTS;\n\ninterface RewardConfig {\n    id: string;\n    name: string;\n    pointsCost: number;\n    type: 'GIFT_CARD' | 'COUPON' | 'PIX_CASHBACK' | 'MEMBERSHIP';\n    value: number; // Valor em R$\n}\n\nconst REWARDS_CATALOG: Record<string, RewardConfig> = {\n    'gc-amazon-10': { id: 'gc-amazon-10', name: 'Gift Card Amazon R$ 10', pointsCost: 1000, type: 'GIFT_CARD', value: 10 },\n    'gc-ifood-15': { id: 'gc-ifood-15', name: 'Cupom iFood R$ 15', pointsCost: 1500, type: 'COUPON', value: 15 },\n    'gc-spotify-1m': { id: 'gc-spotify-1m', name: 'Spotify Premium 1 m√™s', pointsCost: 2000, type: 'GIFT_CARD', value: 20 },\n    'gc-netflix-25': { id: 'gc-netflix-25', name: 'Gift Card Netflix R$ 25', pointsCost: 2500, type: 'GIFT_CARD', value: 25 },\n    'gc-uber-20': { id: 'gc-uber-20', name: 'Cr√©dito Uber R$ 20', pointsCost: 2000, type: 'GIFT_CARD', value: 20 },\n    'gc-playstore-30': { id: 'gc-playstore-30', name: 'Google Play R$ 30', pointsCost: 3000, type: 'GIFT_CARD', value: 30 },\n    'gc-recarga-10': { id: 'gc-recarga-10', name: 'Recarga Celular R$ 10', pointsCost: 1000, type: 'GIFT_CARD', value: 10 },\n    'membership-pro-1m': { id: 'membership-pro-1m', name: 'PRO 1 M√™s', pointsCost: 10000, type: 'MEMBERSHIP', value: 29.90 },\n};\n\n/**\n * Gera c√≥digo de voucher alfanum√©rico\n */\nfunction generateVoucherCode(prefix: string = 'C30'): string {\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n    let code = prefix + '-';\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            code += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        if (i < 3) code += '-';\n    }\n    return code;\n}\n\nexport class EarnController {\n    /**\n     * Recompensa do Ba√∫ Di√°rio\n     */\n    static async chestReward(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const REWARD_POINTS = Math.floor(Math.random() * 101) + 50; // 50-150 pontos\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userRes = await client.query(\n                    `SELECT last_reward_at, daily_chests_opened, last_chest_date, ad_points FROM users WHERE id = $1`,\n                    [user.id]\n                );\n\n                const userData = userRes.rows[0];\n                const lastReward = userData?.last_reward_at;\n                const now = new Date();\n                const today = now.toISOString().split('T')[0];\n                const cooldownMs = 60 * 60 * 1000;\n\n                let dailyChestsOpened = userData?.daily_chests_opened || 0;\n                const lastChestDate = userData?.last_chest_date;\n\n                if (lastChestDate !== today) {\n                    dailyChestsOpened = 0;\n                }\n\n                if (dailyChestsOpened >= 3) {\n                    throw new Error('Limite di√°rio de ba√∫s atingido. Volte amanh√£!');\n                }\n\n                if (lastReward && (now.getTime() - new Date(lastReward).getTime()) < cooldownMs) {\n                    const remaining = Math.ceil((cooldownMs - (now.getTime() - new Date(lastReward).getTime())) / 60000);\n                    throw new Error(`Aguarde ${remaining} minutos para abrir outro ba√∫`);\n                }\n\n                await client.query(\n                    `UPDATE users SET \n                        last_reward_at = CURRENT_TIMESTAMP,\n                        daily_chests_opened = $1,\n                        last_chest_date = $2\n                    WHERE id = $3`,\n                    [dailyChestsOpened + 1, today, user.id]\n                );\n\n                await PointsService.addPoints(client, user.id, REWARD_POINTS, `Abertura de Ba√∫ Di√°rio (${dailyChestsOpened + 1}/3)`);\n\n                const updatedRes = await client.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n                const newPoints = updatedRes.rows[0].ad_points || 0;\n\n                return {\n                    success: true,\n                    chestsRemaining: 3 - (dailyChestsOpened + 1),\n                    rewardPoints: REWARD_POINTS,\n                    totalPoints: newPoints\n                };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            const message = `+${result.data?.rewardPoints} pontos farm! Troque por pr√™mios na Loja.`;\n\n            return c.json({\n                success: true,\n                message,\n                chestsRemaining: result.data?.chestsRemaining,\n                points: result.data?.totalPoints\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Consultar status do ba√∫\n     */\n    static async getChestStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const res = await pool.query(\n                `SELECT last_reward_at, daily_chests_opened, last_chest_date FROM users WHERE id = $1`,\n                [user.id]\n            );\n\n            const userData = res.rows[0];\n            const now = new Date();\n            const today = now.toISOString().split('T')[0];\n            const cooldownMs = 60 * 60 * 1000;\n\n            let dailyChestsOpened = userData?.daily_chests_opened || 0;\n            if (userData?.last_chest_date !== today) {\n                dailyChestsOpened = 0;\n            }\n\n            let countdown = 0;\n            if (userData?.last_reward_at) {\n                const elapsed = now.getTime() - new Date(userData.last_reward_at).getTime();\n                countdown = Math.max(0, Math.ceil((cooldownMs - elapsed) / 1000));\n            }\n\n            return c.json({\n                success: true,\n                chestsRemaining: Math.max(0, 3 - dailyChestsOpened),\n                countdown,\n                canOpen: dailyChestsOpened < 3 && countdown === 0\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Recompensa de v√≠deo\n     */\n    static async videoReward(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const REWARD_POINTS = 30;\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // Verificar cooldown (30 segundos)\n                const userRes = await client.query(\n                    'SELECT last_video_reward_at FROM users WHERE id = $1 FOR UPDATE',\n                    [user.id]\n                );\n                const lastReward = userRes.rows[0]?.last_video_reward_at;\n                const now = new Date();\n\n                if (lastReward && (now.getTime() - new Date(lastReward).getTime()) < 30000) {\n                    const remaining = Math.ceil((30000 - (now.getTime() - new Date(lastReward).getTime())) / 1000);\n                    throw new Error(`Aguarde ${remaining} segundos para assistir outro v√≠deo.`);\n                }\n\n                await client.query(\n                    `UPDATE users SET \n                        last_video_reward_at = CURRENT_TIMESTAMP\n                     WHERE id = $1`,\n                    [user.id]\n                );\n\n                await PointsService.addPoints(client, user.id, REWARD_POINTS, 'Recompensa de V√≠deo R√°pido');\n\n                const updatedRes = await client.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n                const newPoints = updatedRes.rows[0].ad_points || 0;\n\n                return { success: true, newPoints };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `+${REWARD_POINTS} pontos farm! Troque por pr√™mios na Loja.`,\n                points: result.data?.newPoints\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Converter pontos\n     */\n    /**\n     * Converter pontos - DESATIVADO\n     */\n    /**\n     * Converter pontos - REATIVADO E CENTRALIZADO\n     */\n    static async convertPoints(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await PointsService.convertPointsToBalance(pool, user.id);\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.message }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `Sucesso! R$ ${result.data?.convertedAmount.toFixed(2)} adicionados ao seu saldo.`,\n                data: result.data\n            });\n        } catch (error: any) {\n            console.error('[EARN] Erro ao converter pontos:', error);\n            return c.json({ success: false, message: error.message || 'Erro ao converter pontos' }, 500);\n        }\n    }\n\n    /**\n     * Informa√ß√µes de pontos\n     */\n    static async getPointsInfo(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const res = await pool.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n            const currentPoints = res.rows[0]?.ad_points || 0;\n\n            const canConvert = currentPoints >= POINTS_RATE;\n            // C√°lculo novo: (Pontos / 1000) * 0.07\n            const possibleConversion = Math.floor(currentPoints / POINTS_RATE) * MONEY_VALUE;\n            const pointsToNextConversion = canConvert ? 0 : POINTS_RATE - currentPoints;\n\n            return c.json({\n                success: true,\n                data: {\n                    currentPoints,\n                    canConvert,\n                    possibleConversion,\n                    pointsToNextConversion,\n                    rate: `${POINTS_RATE.toLocaleString()} pts = R$ ${MONEY_VALUE.toFixed(2)}`\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Resgatar recompensa\n     */\n    static async redeemReward(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const { rewardId } = body;\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Buscar a recompensa no cat√°logo din√¢mico\n                const rewardRes = await client.query(\n                    'SELECT * FROM reward_catalog WHERE id = $1 AND is_active = TRUE FOR SHARE',\n                    [rewardId]\n                );\n                const reward = rewardRes.rows[0];\n\n                if (!reward) {\n                    throw new Error('Recompensa n√£o encontrada ou inativa.');\n                }\n\n                // 2. Verificar pontos do usu√°rio\n                const userRes = await client.query('SELECT ad_points, membership_type FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const currentPoints = userRes.rows[0]?.ad_points || 0;\n                const currentMembership = userRes.rows[0]?.membership_type;\n\n                if (currentPoints < reward.points_cost) {\n                    throw new Error(`Pontos insuficientes. Voc√™ tem ${currentPoints} pts, mas precisa de ${reward.points_cost} pts.`);\n                }\n\n                let deliveredCode = '';\n                let deliveryMessage = '';\n\n                // 3. L√≥gica espec√≠fica por tipo\n                if (reward.type === 'GIFT_CARD' || reward.type === 'COUPON') {\n                    // Buscar c√≥digo dispon√≠vel no estoque\n                    const codeRes = await client.query(\n                        'SELECT id, code FROM reward_inventory WHERE reward_id = $1 AND is_used = FALSE LIMIT 1 FOR UPDATE SKIP LOCKED',\n                        [rewardId]\n                    );\n\n                    if (codeRes.rows.length === 0) {\n                        throw new Error('Estoque esgotado para este pr√™mio. Tente novamente mais tarde ou escolha outro.');\n                    }\n\n                    const inventoryItem = codeRes.rows[0];\n                    deliveredCode = inventoryItem.code;\n\n                    // Marcar c√≥digo como usado\n                    await client.query(\n                        'UPDATE reward_inventory SET is_used = TRUE, used_by_user_id = $1, used_at = NOW() WHERE id = $2',\n                        [user.id, inventoryItem.id]\n                    );\n\n                    deliveryMessage = `Resgate realizado! Seu c√≥digo: ${deliveredCode}.`;\n                } else if (reward.type === 'MEMBERSHIP') {\n                    if (currentMembership === 'PRO') {\n                        await client.query(\n                            `UPDATE users SET pro_expires_at = COALESCE(pro_expires_at, NOW()) + INTERVAL '30 days' WHERE id = $1`,\n                            [user.id]\n                        );\n                        deliveryMessage = 'Seu plano PRO foi estendido por mais 30 dias!';\n                    } else {\n                        await client.query(\n                            `UPDATE users SET membership_type = 'PRO', pro_expires_at = NOW() + INTERVAL '30 days' WHERE id = $1`,\n                            [user.id]\n                        );\n                        deliveryMessage = 'Voc√™ agora √© Cred30 PRO por 30 dias!';\n                    }\n                    deliveredCode = `PRO-${Date.now()}`;\n                } else {\n                    throw new Error('Tipo de recompensa n√£o suportado.');\n                }\n\n                // 4. Deduzir pontos\n                const newPoints = currentPoints - reward.points_cost;\n                await client.query('UPDATE users SET ad_points = $1 WHERE id = $2', [newPoints, user.id]);\n\n                // 5. Registrar no hist√≥rico\n                await client.query(\n                    `INSERT INTO reward_redemptions (user_id, reward_id, reward_name, points_spent, code_delivered, status, created_at)\n                     VALUES ($1, $2, $3, $4, $5, 'COMPLETED', NOW())`,\n                    [user.id, reward.id, reward.name, reward.points_cost, deliveredCode]\n                );\n\n                return { success: true, code: deliveredCode, deliveryMessage, newPoints };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: result.data?.deliveryMessage,\n                code: result.data?.code,\n                pointsRemaining: result.data?.newPoints\n            });\n\n        } catch (error: any) {\n            console.error('[REWARDS] Erro ao resgatar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Cat√°logo de recompensas\n     */\n    static async getRewardsCatalog(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const userRes = await pool.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n            const currentPoints = userRes.rows[0]?.ad_points || 0;\n\n            const res = await pool.query(`\n                SELECT c.*, \n                (SELECT COUNT(*) FROM reward_inventory i WHERE i.reward_id = c.id AND i.is_used = FALSE) as stock\n                FROM reward_catalog c\n                WHERE is_active = TRUE\n                ORDER BY points_cost ASC\n            `);\n\n            const catalog = res.rows.map(r => ({\n                id: r.id,\n                name: r.name,\n                pointsCost: r.points_cost,\n                type: r.type,\n                value: parseFloat(r.value),\n                stock: parseInt(r.stock),\n                image_url: r.image_url,\n                canAfford: currentPoints >= r.points_cost\n            }));\n\n            console.log('[EarnController] Cat√°logo de recompensas enviado:', catalog);\n\n            return c.json({\n                success: true,\n                data: {\n                    currentPoints,\n                    catalog\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/education.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'POINTS_TO_CURRENCY_RATE' is assigned a value but never used.","line":16,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2499,2502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2499,2502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4473,4476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4473,4476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5355,5358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5355,5358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5765,5768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5765,5768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7651,7654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7651,7654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12411,12414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12411,12414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13440,13443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13440,13443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":358,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14186,14189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14186,14189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":384,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15185,15188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15185,15188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'amountToPay' is assigned a value but never used.","line":418,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":418,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":450,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":450,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18131,18134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18131,18134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, createTransaction } from '../../../domain/services/transaction.service';\nimport { PoolClient } from 'pg';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n// ============================================\n// CONSTANTES\n// ============================================\nconst INSTRUCTOR_SHARE = 0.70;  // 70% para o instrutor\nconst INVESTORS_SHARE = 0.20;   // 20% para cotistas (profit_pool)\nconst PLATFORM_SHARE = 0.10;    // 10% para plataforma (system_balance - custos)\n\n// Taxa de convers√£o para sistema de pontos legado\nconst POINTS_TO_CURRENCY_RATE = 0.03 / 1000;\nconst POINTS_TO_SCORE_RATE = 0.02;\n\n// ============================================\n// SCHEMAS DE VALIDA√á√ÉO\n// ============================================\nconst createCourseSchema = z.object({\n    title: z.string().min(5).max(200),\n    description: z.string().min(10).max(2000),\n    price: z.number().min(0).max(9999),\n    category: z.string().optional(),\n    thumbnailUrl: z.string().url().optional()\n});\n\nconst addLessonSchema = z.object({\n    courseId: z.number(),\n    title: z.string().min(3).max(200),\n    description: z.string().optional(),\n    youtubeUrl: z.string().min(10), // Link do YouTube\n    durationMinutes: z.number().optional(),\n    isPreview: z.boolean().optional()\n});\n\nconst rewardSchema = z.object({\n    points: z.number().positive(),\n    lessonId: z.string().or(z.number()),\n    sessionId: z.number()\n});\n\nexport class EducationController {\n    /**\n     * Criar um novo curso\n     */\n    static async createCourse(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n            const data = createCourseSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                INSERT INTO courses (instructor_id, title, description, price, category, thumbnail_url, status)\n                VALUES ($1, $2, $3, $4, $5, $6, 'APPROVED')\n                RETURNING id, title, price, status\n            `, [user.id, data.title, data.description, data.price, data.category || 'GERAL', data.thumbnailUrl || null]);\n\n            return c.json({\n                success: true,\n                message: 'Curso criado com sucesso!',\n                data: result.rows[0]\n            });\n        } catch (e: any) {\n            if (e instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: e.errors }, 400);\n            console.error('[COURSES] Erro ao criar curso:', e);\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Adicionar aula a um curso\n     */\n    static async addLesson(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n            const data = addLessonSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const courseRes = await pool.query(\n                'SELECT id, instructor_id FROM courses WHERE id = $1',\n                [data.courseId]\n            );\n\n            if (courseRes.rows.length === 0) {\n                return c.json({ success: false, message: 'Curso n√£o encontrado.' }, 404);\n            }\n\n            if (courseRes.rows[0].instructor_id !== user.id) {\n                return c.json({ success: false, message: 'Voc√™ n√£o √© o instrutor deste curso.' }, 403);\n            }\n\n            const orderRes = await pool.query(\n                'SELECT COALESCE(MAX(order_index), 0) + 1 as next_order FROM course_lessons WHERE course_id = $1',\n                [data.courseId]\n            );\n            const orderIndex = orderRes.rows[0].next_order;\n\n            const result = await pool.query(`\n                INSERT INTO course_lessons (course_id, title, description, youtube_url, duration_minutes, order_index, is_preview)\n                VALUES ($1, $2, $3, $4, $5, $6, $7)\n                RETURNING id, title, order_index\n            `, [data.courseId, data.title, data.description || '', data.youtubeUrl, data.durationMinutes || 0, orderIndex, data.isPreview || false]);\n\n            return c.json({\n                success: true,\n                message: 'Aula adicionada com sucesso!',\n                data: result.rows[0]\n            });\n        } catch (e: any) {\n            if (e instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: e.errors }, 400);\n            console.error('[COURSES] Erro ao adicionar aula:', e);\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Listar cursos dispon√≠veis\n     */\n    static async listCourses(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const category = c.req.query('category');\n\n            let query = `\n                SELECT c.*, u.name as instructor_name, u.is_verified as instructor_verified,\n                       (SELECT COUNT(*) FROM course_lessons WHERE course_id = c.id) as total_lessons\n                FROM courses c\n                JOIN users u ON c.instructor_id = u.id\n                WHERE c.status = 'APPROVED'\n            `;\n\n            const params: any[] = [];\n            if (category) {\n                params.push(category);\n                query += ` AND c.category = $${params.length}`;\n            }\n\n            query += ' ORDER BY c.created_at DESC LIMIT 50';\n\n            const result = await pool.query(query, params);\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Ver detalhes de um curso\n     */\n    static async getCourseDetails(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const courseId = parseInt(c.req.param('id'));\n            const pool = getDbPool(c);\n\n            const courseRes = await pool.query(`\n                SELECT c.*, u.name as instructor_name, u.is_verified as instructor_verified\n                FROM courses c\n                JOIN users u ON c.instructor_id = u.id\n                WHERE c.id = $1\n            `, [courseId]);\n\n            if (courseRes.rows.length === 0) {\n                return c.json({ success: false, message: 'Curso n√£o encontrado.' }, 404);\n            }\n\n            const course = courseRes.rows[0];\n\n            const purchaseRes = await pool.query(\n                'SELECT id FROM course_purchases WHERE user_id = $1 AND course_id = $2',\n                [user.id, courseId]\n            );\n            const hasPurchased = purchaseRes.rows.length > 0 || course.instructor_id === user.id;\n\n            let lessonsQuery = `\n                SELECT id, title, description, duration_minutes, order_index, is_preview\n                ${hasPurchased ? ', youtube_url' : ''}\n                FROM course_lessons\n                WHERE course_id = $1\n            `;\n            if (!hasPurchased) {\n                lessonsQuery += ' AND is_preview = TRUE';\n            }\n            lessonsQuery += ' ORDER BY order_index ASC';\n\n            const lessonsRes = await pool.query(lessonsQuery, [courseId]);\n\n            return c.json({\n                success: true,\n                data: {\n                    ...course,\n                    hasPurchased,\n                    lessons: lessonsRes.rows\n                }\n            });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Comprar curso\n     */\n    static async buyCourse(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const courseId = parseInt(c.req.param('id'));\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const courseRes = await client.query(\n                    'SELECT id, instructor_id, price, title FROM courses WHERE id = $1 AND status = $2',\n                    [courseId, 'APPROVED']\n                );\n\n                if (courseRes.rows.length === 0) {\n                    throw new Error('Curso n√£o encontrado ou n√£o dispon√≠vel.');\n                }\n\n                const course = courseRes.rows[0];\n\n                if (course.instructor_id === user.id) {\n                    throw new Error('Voc√™ n√£o pode comprar seu pr√≥prio curso.');\n                }\n\n                const existingPurchase = await client.query(\n                    'SELECT id FROM course_purchases WHERE user_id = $1 AND course_id = $2',\n                    [user.id, courseId]\n                );\n\n                if (existingPurchase.rows.length > 0) {\n                    throw new Error('Voc√™ j√° possui este curso.');\n                }\n\n                if (parseFloat(course.price) === 0) {\n                    await client.query(`\n                        INSERT INTO course_purchases (user_id, course_id, amount_paid, instructor_share, platform_share)\n                        VALUES ($1, $2, 0, 0, 0)\n                    `, [user.id, courseId]);\n\n                    await client.query('UPDATE courses SET total_students = total_students + 1 WHERE id = $1', [courseId]);\n\n                    return { success: true, free: true };\n                }\n\n                const userRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const userBalance = parseFloat(userRes.rows[0].balance || '0');\n                const price = parseFloat(course.price);\n\n                if (userBalance < price) {\n                    throw new Error(`Saldo insuficiente. Voc√™ tem R$ ${userBalance.toFixed(2)}, mas precisa de R$ ${price.toFixed(2)}.`);\n                }\n\n                const instructorShare = price * INSTRUCTOR_SHARE;\n                const investorsShare = price * INVESTORS_SHARE;\n                const platformBucketShare = (price * PLATFORM_SHARE) / 5; // Divide os 10% em 5 potes (2% cada)\n\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [price, user.id]);\n                await client.query('UPDATE users SET balance = balance + $1 WHERE id = $2', [instructorShare, course.instructor_id]);\n\n                // BLINDAGEM FINANCEIRA: Distribuir taxas nos potes corretos\n                await client.query(`\n                    UPDATE system_config SET \n                        profit_pool = profit_pool + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $2,\n                        total_owner_profit = total_owner_profit + $2,\n                        investment_reserve = investment_reserve + $2,\n                        total_corporate_investment_reserve = total_corporate_investment_reserve + $2\n                `, [investorsShare, platformBucketShare]);\n\n                await client.query(`\n                    INSERT INTO course_purchases (user_id, course_id, amount_paid, instructor_share, platform_share)\n                    VALUES ($1, $2, $3, $4, $5)\n                `, [user.id, courseId, price, instructorShare, investorsShare + (platformBucketShare * 5)]);\n\n                await client.query(`\n                    UPDATE courses SET total_students = total_students + 1, total_revenue = total_revenue + $1 WHERE id = $2\n                `, [price, courseId]);\n\n                await createTransaction(client, String(user.id), 'COURSE_PURCHASE', -price, `Compra: ${course.title}`, 'APPROVED');\n                await createTransaction(client, String(course.instructor_id), 'COURSE_SALE', instructorShare, `Venda: ${course.title}`, 'APPROVED');\n\n                return { success: true, price, instructorShare, platformShare };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: result.data?.free ? 'Curso adicionado √† sua biblioteca!' : 'Curso comprado com sucesso!',\n                data: result.data\n            });\n        } catch (e: any) {\n            console.error('[COURSES] Erro ao comprar:', e);\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Meus cursos\n     */\n    static async getMyCourses(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT c.*, cp.created_at as purchased_at,\n                       (SELECT COUNT(*) FROM course_lessons WHERE course_id = c.id) as total_lessons,\n                       (SELECT COUNT(*) FROM course_progress WHERE user_id = $1 AND course_id = c.id AND completed = TRUE) as completed_lessons\n                FROM course_purchases cp\n                JOIN courses c ON cp.course_id = c.id\n                WHERE cp.user_id = $1\n                ORDER BY cp.created_at DESC\n            `, [user.id]);\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Meus cursos (instrutor)\n     */\n    static async getMyTeaching(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT c.*,\n                       (SELECT COUNT(*) FROM course_lessons WHERE course_id = c.id) as total_lessons\n                FROM courses c\n                WHERE c.instructor_id = $1\n                ORDER BY c.created_at DESC\n            `, [user.id]);\n\n            return c.json({\n                success: true,\n                data: result.rows\n            });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Iniciar sess√£o (legacy)\n     */\n    static async startSession(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n            const { lessonId } = body;\n            const pool = getDbPool(c);\n\n            await pool.query('UPDATE education_sessions SET is_active = FALSE WHERE user_id = $1 AND is_active = TRUE', [user.id]);\n\n            const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n            const ua = c.req.header('user-agent') || 'Unknown';\n\n            const result = await pool.query(`\n                INSERT INTO education_sessions (user_id, video_id, ip_address, user_agent)\n                VALUES ($1, $2, $3, $4) RETURNING id\n            `, [user.id, String(lessonId), ip, ua]);\n\n            return c.json({ success: true, data: { sessionId: result.rows[0].id } });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Recompensa (legacy)\n     */\n    static async reward(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { points, lessonId, sessionId } = rewardSchema.parse(body);\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const sessionRes = await pool.query(\n                'SELECT * FROM education_sessions WHERE id = $1 AND user_id = $2 AND is_active = TRUE',\n                [sessionId, user.id]\n            );\n\n            if (sessionRes.rows.length === 0) {\n                return c.json({ success: false, message: 'Sess√£o inv√°lida ou j√° finalizada.' }, 403);\n            }\n\n            const session = sessionRes.rows[0];\n            const startTime = new Date(session.started_at).getTime();\n            const now = Date.now();\n            const elapsedSeconds = (now - startTime) / 1000;\n            const minRequiredSeconds = (points / 0.5) * 0.9;\n\n            if (elapsedSeconds < minRequiredSeconds) {\n                return c.json({ success: false, message: 'Tempo de estudo insuficiente.' }, 400);\n            }\n\n            const amountToPay = 0; // DESATIVADO: Aulas n√£o pagam mais em dinheiro\n            const scoreToAdd = Math.floor(points * POINTS_TO_SCORE_RATE);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                await client.query('UPDATE education_sessions SET is_active = FALSE, total_seconds = $1 WHERE id = $2', [Math.floor(elapsedSeconds), sessionId]);\n\n                // Removido d√©bito do profit_pool, pois n√£o h√° pagamento monet√°rio\n\n                if (scoreToAdd > 0) {\n                    await client.query('UPDATE users SET score = score + $1 WHERE id = $2', [scoreToAdd, user.id]);\n                }\n\n                // Opcional: Registrar transa√ß√£o de Score (se houver tabela para isso) ou apenas logar\n                // Como transactions √© financeiro, vamos evitar poluir com R$ 0,00 se poss√≠vel, \n                // mas para manter hist√≥rico de \"Aula Conclu√≠da\", podemos inserir com valor 0.\n\n                const txResult = await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                    VALUES ($1, 'EDUCATION_REWARD', 0, $2, 'COMPLETED', $3)\n                    RETURNING id`,\n                    [user.id, `Aula Conclu√≠da: #${lessonId} (+${scoreToAdd} Score)`, JSON.stringify({ points, lessonId, sessionId })]\n                );\n\n                return { transactionId: txResult.rows[0].id, amount: 0, scoreAdded: scoreToAdd };\n            });\n\n            if (!result.success) {\n                throw new Error(result.error);\n            }\n\n            return c.json({ success: true, message: 'Recompensa creditada!', data: result.data });\n\n        } catch (error: any) {\n            if (error.message === 'LIMIT_REACHED') return c.json({ success: false, message: 'Limite do Fundo atingido.' }, 429);\n            return c.json({ success: false, message: error.message || 'Erro interno' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/kyc.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":170,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":170,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\n// Pasta Segura (Fora do Public)\nconst SECURE_STORAGE_PATH = path.resolve(__dirname, '../../../../secure_storage/kyc');\n\n// Garantir que a pasta existe\nif (!fs.existsSync(SECURE_STORAGE_PATH)) {\n    fs.mkdirSync(SECURE_STORAGE_PATH, { recursive: true });\n}\n\nexport class KycController {\n\n    /**\n     * Upload de Documento para Verifica√ß√£o\n     */\n    static async uploadDocument(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.parseBody();\n            const file = body['document'];\n            const docType = body['docType'] as string || 'ID'; // ID, VEHICLE, DOC_VEHICLE\n\n            if (!file || typeof file === 'string') {\n                return c.json({ success: false, message: 'Arquivo obrigat√≥rio' }, 400);\n            }\n\n            // Valida√ß√£o de Tipo\n            const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];\n            if (!allowedTypes.includes(file.type)) {\n                return c.json({ success: false, message: 'Formato inv√°lido. Use JPG, PNG ou PDF.' }, 400);\n            }\n\n            // Gerar nome seguro (Hash)\n            const fileExt = file.name.split('.').pop();\n            const secureName = `${crypto.randomBytes(16).toString('hex')}_${docType}.${fileExt}`;\n            const diskPath = path.join(SECURE_STORAGE_PATH, secureName);\n\n            // Salvar arquivo\n            const fileData = await file.arrayBuffer();\n            fs.writeFileSync(diskPath, Buffer.from(fileData));\n\n            // Atualizar BD baseado no tipo\n            const pool = getDbPool(c);\n            let updateQuery = '';\n\n            if (docType === 'VEHICLE') {\n                updateQuery = `UPDATE users SET courier_vehicle_photo = $1 WHERE id = $2`;\n            } else if (docType === 'DOC_VEHICLE') {\n                updateQuery = `UPDATE users SET courier_doc_photo = $1 WHERE id = $2`;\n            } else if (docType === 'BUSINESS') {\n                updateQuery = `UPDATE users SET business_license_path = $1, kyc_status = 'PENDING' WHERE id = $2`;\n            } else {\n                // Padr√£o: Documento de Identidade (KYC)\n                updateQuery = `UPDATE users SET kyc_status = 'PENDING', kyc_document_path = $1, courier_id_photo = $1 WHERE id = $2`;\n            }\n\n            await pool.query(updateQuery, [secureName, user.id]);\n\n            return c.json({ success: true, message: 'Documento enviado com sucesso.', fileName: secureName });\n\n        } catch (error) {\n            console.error('KYC Upload Error:', error);\n            return c.json({ success: false, message: 'Erro no upload' }, 500);\n        }\n    }\n\n    /**\n     * Visualizar Documento (Apenas Admin ou Dono)\n     */\n    static async viewDocument(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const userIdTarget = c.req.param('userId');\n            const docType = c.req.query('type') || 'ID'; // ID, VEHICLE, DOC_VEHICLE\n\n            const pool = getDbPool(c);\n\n            // Verificar permiss√£o\n            const canView = user.isAdmin || user.id.toString() === userIdTarget.toString();\n            if (!canView) return c.json({ success: false, message: 'Acesso negado.' }, 403);\n\n            // Mapear coluna baseada no tipo\n            let column = 'kyc_document_path';\n            if (docType === 'VEHICLE') column = 'courier_vehicle_photo';\n            if (docType === 'DOC_VEHICLE') column = 'courier_doc_photo';\n\n            // Buscar nome do arquivo no banco\n            const res = await pool.query(`SELECT ${column} FROM users WHERE id = $1`, [userIdTarget]);\n            if (res.rows.length === 0 || !res.rows[0][column]) {\n                return c.json({ success: false, message: 'Documento n√£o encontrado.' }, 404);\n            }\n\n            const fileName = res.rows[0][column];\n            const diskPath = path.join(SECURE_STORAGE_PATH, fileName);\n\n            if (!fs.existsSync(diskPath)) {\n                return c.json({ success: false, message: 'Arquivo f√≠sico n√£o encontrado.' }, 404);\n            }\n\n            // Servir arquivo\n            const fileContent = fs.readFileSync(diskPath);\n            const ext = path.extname(fileName).toLowerCase();\n            const contentType = ext === '.pdf' ? 'application/pdf' :\n                ext === '.png' ? 'image/png' : 'image/jpeg';\n\n            c.header('Content-Type', contentType);\n            return c.body(fileContent);\n\n        } catch (error) {\n            console.error('KYC View Error:', error);\n            return c.json({ success: false, message: 'Erro ao visualizar' }, 500);\n        }\n    }\n\n    /**\n     * Solicitar Revis√£o (Sem Upload - Flow Simplificado)\n     */\n    static async requestReview(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Verifica se j√° n√£o est√° aprovado\n            const check = await pool.query('SELECT kyc_status FROM users WHERE id = $1', [user.id]);\n            if (check.rows[0]?.kyc_status === 'APPROVED') {\n                return c.json({ success: false, message: 'J√° verificado' }, 400);\n            }\n\n            // Atualiza para PENDING\n            await pool.query(\n                `UPDATE users SET kyc_status = 'PENDING', kyc_notes = 'Solicita√ß√£o Simplificada via App' WHERE id = $1`,\n                [user.id]\n            );\n\n            return c.json({ success: true, message: 'Solicita√ß√£o enviada com sucesso.' });\n        } catch (error) {\n            console.error('KYC Request Error:', error);\n            return c.json({ success: false, message: 'Erro ao solicitar' }, 500);\n        }\n    }\n\n    /**\n     * Aprovar/Rejeitar KYC (Admin)\n     */\n    static async reviewKyc(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            if (!user.isAdmin) return c.json({ success: false, message: 'Apenas Admin' }, 403);\n\n            const { userId, status, notes } = await c.req.json();\n            if (!['APPROVED', 'REJECTED'].includes(status)) {\n                return c.json({ success: false, message: 'Status inv√°lido' }, 400);\n            }\n\n            const pool = getDbPool(c);\n            await pool.query(\n                `UPDATE users SET kyc_status = $1, kyc_notes = $2, is_verified = $4 WHERE id = $3`,\n                [status, notes, userId, status === 'APPROVED']\n            );\n\n            // Se aprovado, poderia liberar automaticamente tags de \"Vendedor Verificado\" etc.\n\n            return c.json({ success: true, message: `Status atualizado para ${status}` });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro na revis√£o' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/loans.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PLATFORM_FEE_CORPORATE_SHARE' is defined but never used.","line":11,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":33,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PLATFORM_FEE_CORPORATE_SHARE"},"fix":{"range":[318,352],"text":""},"desc":"Remove unused variable \"PLATFORM_FEE_CORPORATE_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3604,3607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3604,3607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3715,3718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3715,3718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originationRate' is assigned a value but never used.","line":171,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentDebt' is assigned a value but never used.","line":195,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":195,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'paymentMethod' is assigned a value but never used.","line":345,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":345,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport {\n    ONE_MONTH_MS,\n    PENALTY_RATE,\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE,\n    PLATFORM_FEE_CORPORATE_SHARE,\n    ADMIN_PIX_KEY,\n    LOAN_GFC_FEE_RATE\n} from '../../../shared/constants/business.constants';\nimport { updateScore, SCORE_REWARDS } from '../../../application/services/score.service';\nimport { AuditService, AuditActionType } from '../../../application/services/audit.service';\nimport { calculateTotalToPay, PaymentMethod } from '../../../shared/utils/financial.utils';\nimport { executeInTransaction, processLoanApproval } from '../../../domain/services/transaction.service';\nimport {\n    calculateLoanOffer,\n    getCreditAnalysis\n} from '../../../application/services/credit-analysis.service';\nimport { PoolClient } from 'pg';\nimport { getWelcomeBenefit, consumeWelcomeBenefitUse } from '../../../application/services/welcome-benefit.service';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n// Esquemas de valida√ß√£o\nconst createLoanSchema = z.object({\n    amount: z.number().positive(),\n    installments: z.number().int().min(1).max(12),\n    guaranteePercentage: z.number().int().min(50).max(100).optional().default(100),\n    guarantorId: z.string().optional(),\n    acceptedTerms: z.boolean().refine(val => val === true, \"Voc√™ deve ler e aceitar os termos do contrato de empr√©stimo (CCB).\"),\n});\n\nconst repayLoanSchema = z.object({\n    loanId: z.union([z.string(), z.number()]).transform((val) => val.toString()),\n    useBalance: z.boolean(),\n    paymentMethod: z.enum(['pix']).optional().default('pix'),\n});\n\nconst repayInstallmentSchema = z.object({\n    loanId: z.union([z.string(), z.number()]).transform((val) => val.toString()),\n    installmentAmount: z.number().positive(),\n    useBalance: z.boolean(),\n    paymentMethod: z.enum(['pix']).optional().default('pix'),\n});\n\nexport class LoansController {\n    /**\n     * Listar empr√©stimos do usu√°rio\n     */\n    static async listLoans(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT l.*, u.name as requester_name,\n                COALESCE(\n                  (SELECT json_agg(json_build_object(\n                    'id', li.id,\n                    'installmentNumber', li.installment_number,\n                    'amount', li.amount::float,\n                    'expectedAmount', li.expected_amount::float,\n                    'dueDate', li.due_date,\n                    'status', li.status,\n                    'useBalance', li.use_balance,\n                    'createdAt', li.created_at,\n                    'paidAt', li.paid_at\n                  ) ORDER BY li.installment_number ASC NULLS LAST, li.created_at ASC)\n                   FROM loan_installments li \n                   WHERE li.loan_id = l.id),\n                  '[]'\n                ) as installments_json\n         FROM loans l\n         LEFT JOIN users u ON u.id = l.user_id\n         WHERE l.user_id = $1::integer OR l.metadata->>'guarantorId' = $1::text OR l.metadata->>'guarantor_id' = $1::text\n         ORDER BY l.created_at DESC`,\n                [user.id]\n            );\n\n            const formattedLoans = result.rows.map(loan => {\n                const allInstallments = loan.installments_json;\n                const paidInstallments = allInstallments.filter((inst: any) => inst.status === 'PAID');\n                const totalPaid = paidInstallments.reduce((sum: number, inst: any) => sum + (inst.amount || inst.expectedAmount || 0), 0);\n                const remainingAmount = Math.max(0, parseFloat(loan.total_repayment) - totalPaid);\n\n                return {\n                    id: loan.id,\n                    userId: loan.user_id,\n                    amount: parseFloat(loan.amount),\n                    totalRepayment: parseFloat(loan.total_repayment),\n                    installments: loan.installments,\n                    interestRate: parseFloat(loan.interest_rate),\n                    requestDate: new Date(loan.created_at).getTime(),\n                    status: loan.status,\n                    pixKeyToReceive: loan.pix_key_to_receive || '',\n                    dueDate: new Date(loan.due_date).getTime(),\n                    installmentsList: allInstallments,\n                    paidInstallments,\n                    totalPaid,\n                    remainingAmount,\n                    paidInstallmentsCount: paidInstallments.length,\n                    isFullyPaid: totalPaid >= parseFloat(loan.total_repayment) - 0.01,\n                    requesterName: loan.requester_name || null,\n                    isGuarantor: loan.metadata?.guarantorId === String(user.id) || loan.metadata?.guarantor_id === String(user.id)\n                };\n            });\n\n            return c.json({ success: true, data: { loans: formattedLoans } });\n        } catch (error) {\n            console.error('Erro ao listar empr√©stimos:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Obter limite de cr√©dito dispon√≠vel\n     */\n    static async getAvailableLimit(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const creditAnalysis = await getCreditAnalysis(pool, user.id);\n\n            return c.json({\n                success: true,\n                data: {\n                    totalLimit: creditAnalysis.limit,\n                    activeDebt: creditAnalysis.details.activeDebt,\n                    remainingLimit: creditAnalysis.details.availableLimit,\n                    analysis: creditAnalysis\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao analisar cr√©dito:', error);\n            return c.json({ success: false, message: 'Erro ao analisar cr√©dito' }, 500);\n        }\n    }\n\n    /**\n     * Solicitar empr√©stimo\n     */\n    static async requestLoan(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { amount, installments, guaranteePercentage, guarantorId } = createLoanSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const loanOffer = await calculateLoanOffer(pool, user.id, amount, guaranteePercentage, guarantorId);\n\n            if (!loanOffer.approved) {\n                return c.json({\n                    success: false,\n                    message: loanOffer.reason || 'Sua solicita√ß√£o n√£o atende aos crit√©rios de m√©rito e garantia.'\n                }, 400);\n            }\n\n\n\n            const offer = loanOffer.offer!;\n            const welcomeBenefit = await getWelcomeBenefit(pool, user.id);\n            let finalInterestRate = offer.interestRate;\n            if (welcomeBenefit.hasDiscount && welcomeBenefit.loanInterestRate < finalInterestRate) {\n                finalInterestRate = welcomeBenefit.loanInterestRate;\n            }\n            const originationRate = welcomeBenefit.loanOriginationFeeRate;\n\n            // FGC: Taxa de Prote√ß√£o de Cr√©dito (capitalizada no momento do empr√©stimo)\n            const gfcFee = amount * LOAN_GFC_FEE_RATE;\n            const amountWithFee = amount + gfcFee;\n\n            const originationFee = 0;\n            const amountToDisburse = amount;\n            // O Total a Pagar inclui o Principal + Taxa FGC + Juros sobre ambos\n            const totalRepayment = amountWithFee * (1 + finalInterestRate);\n\n            const initialStatus = guarantorId ? 'WAITING_GUARANTOR' : 'PENDING';\n\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. LOCK DE SEGURAN√áA: Bloquear usu√°rio para evitar m√∫ltiplos empr√©stimos simult√¢neos excedendo limite\n                await client.query('SELECT id FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n\n                // 2. RE-VALIDANDO LIMITE DENTRO DA TRANSA√á√ÉO (CR√çTICO)\n                // O calculateLoanOffer foi feito fora da tx (vis√£o \"suja\"). Agora com lock, verificamos o estado real.\n                const activeLoansCheck = await client.query(\n                    `SELECT COALESCE(SUM(amount), 0) as total FROM loans WHERE user_id = $1 AND status IN ('APPROVED', 'PAYMENT_PENDING', 'PENDING')`,\n                    [user.id]\n                );\n                const currentDebt = parseFloat(activeLoansCheck.rows[0].total);\n\n                // Usamos o limite calculado anteriormente como refer√™ncia base, mas verificamos se a nova d√≠vida estoura\n                // Se o usu√°rio j√° tiver d√≠vida > limite (caso raro), n√£o permitimos novos.\n                // Mas a l√≥gica principal √©: activeDebt + newAmount <= offer.limit\n\n                // Recalcular limite REAL (baseado no saldo/cotas atuais que est√£o lockadas agora)\n                // Simplifica√ß√£o: vamos usar o offer.limit calculado fora, assumindo que cotas n√£o mudaram drasticamente,\n                // mas a d√≠vida (activeDebt) √© a vari√°vel mais vol√°til em concorr√™ncia.\n\n                // Para maior seguran√ßa, poder√≠amos trazer calculateLoanOffer para dentro, mas isso exige refatorar o service para aceitar client.\n                // Vamos bloquear se (d√≠vida atual + novo) > limite estimado.\n\n                // *NOTA*: Se o usu√°rio sacou cotas nesse meio tempo, o limite real diminuiu. \n                // RISCO ACEIT√ÅVEL: O preju√≠zo seria pequeno e coberto pela garantia restante. O foco aqui √© evitar 10 loans seguidos.\n\n                // Anti-Flood: Se tiver empr√©stimo PENDING criado nos √∫ltimos 5 segundos, bloqueia.\n                const recentLoan = await client.query(\n                    `SELECT id FROM loans WHERE user_id = $1 AND created_at > NOW() - INTERVAL '5 seconds'`,\n                    [user.id]\n                );\n                if (recentLoan.rows.length > 0) {\n                    throw new Error('Aguarde alguns segundos antes de solicitar novo apoio.');\n                }\n\n                const loanResult = await client.query(\n                    `INSERT INTO loans (user_id, amount, total_repayment, installments, interest_rate, penalty_rate, status, due_date, term_days, metadata)\n           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n           RETURNING id`,\n                    [\n                        user.id,\n                        amount,\n                        totalRepayment,\n                        installments,\n                        finalInterestRate,\n                        PENALTY_RATE,\n                        initialStatus,\n                        new Date(Date.now() + (installments * ONE_MONTH_MS)),\n                        installments * 30,\n                        JSON.stringify({\n                            originationFee,\n                            gfcFee,\n                            disbursedAmount: amountToDisburse,\n                            guaranteePercentage: offer.guaranteePercentage,\n                            guaranteeValue: offer.guaranteeValue,\n                            guarantorId: guarantorId || null,\n                            guarantorName: offer.guarantorName || null,\n                            welcomeBenefitApplied: welcomeBenefit.hasDiscount,\n                            riskClassInterestRate: offer.interestRate,\n                            finalInterestRate,\n                            legal_context: {\n                                accepted_at: new Date().toISOString(),\n                                accepted_terms: true,\n                                ip_address: c.req.header('x-forwarded-for') || '127.0.0.1',\n                                user_agent: c.req.header('user-agent') || 'Unknown',\n                                contract_version: 'TERMO_ADESAO_MUTUO_V1'\n                            }\n                        })\n                    ]\n                );\n\n                const newLoanId = loanResult.rows[0].id;\n\n                await client.query(\n                    `UPDATE system_config SET \n            total_tax_reserve = total_tax_reserve + $1,\n            total_operational_reserve = total_operational_reserve + $2,\n            total_owner_profit = total_owner_profit + $3,\n            investment_reserve = investment_reserve + $4,\n            system_balance = system_balance + $5`,\n                    [\n                        originationFee * PLATFORM_FEE_TAX_SHARE,\n                        originationFee * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        originationFee * PLATFORM_FEE_OWNER_SHARE,\n                        originationFee * PLATFORM_FEE_INVESTMENT_SHARE,\n                        originationFee\n                    ]\n                );\n\n                if (welcomeBenefit.hasDiscount) {\n                    await consumeWelcomeBenefitUse(client, user.id, 'LOAN');\n                }\n\n                try {\n                    const configRes = await client.query('SELECT system_balance FROM system_config LIMIT 1');\n                    const systemBalance = parseFloat(configRes.rows[0].system_balance);\n                    const loansRes = await client.query(\"SELECT COALESCE(SUM(amount), 0) as total FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING')\");\n                    const totalLoaned = parseFloat(loansRes.rows[0].total);\n\n                    const liquidity = (systemBalance * 0.7) - totalLoaned;\n\n                    if (amount <= liquidity && initialStatus === 'PENDING') {\n                        await processLoanApproval(client, newLoanId.toString(), 'APPROVE');\n                        return { loanId: newLoanId, autoApproved: true };\n                    }\n                } catch (e) {\n                    console.error('Erro auto-aprova√ß√£o:', e);\n                }\n\n                return { loanId: newLoanId, autoApproved: false };\n            });\n\n            if (!result.success) {\n                throw new Error(result.error || 'Erro na transa√ß√£o de empr√©stimo');\n            }\n\n            // AUDITORIA FINTECH\n            try {\n                const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n                const userAgent = c.req.header('user-agent') || 'Unknown';\n                // Usando AuditService global (pool do connection ou do service)\n                await AuditService.logSensitiveAction(pool, user.id, AuditActionType.LOAN_REQUEST, {\n                    amount,\n                    term: installments,\n                    guarantorId,\n                    resultId: result.data?.loanId,\n                    autoApproved: result.data?.autoApproved,\n                    userAgent\n                }, ip);\n            } catch (auditError) { console.error('Audit Error', auditError); }\n\n            const isAutoApproved = result.data?.autoApproved;\n            return c.json({\n                success: true,\n                message: isAutoApproved\n                    ? `Apoio aprovado! R$ ${amount.toFixed(2)} j√° dispon√≠vel. Garantia de ${offer.guaranteePercentage}% vinculada.`\n                    : guarantorId\n                        ? `Solicita√ß√£o enviada! O fiador ${offer.guarantorName} precisa aprovar na conta dele para prosseguir.`\n                        : `Solicita√ß√£o enviada! Aguardando recursos no caixa do Clube Cred30.`,\n                data: {\n                    loanId: result.data?.loanId,\n                    totalRepayment,\n                    interestRate: finalInterestRate,\n                    guaranteePercentage: offer.guaranteePercentage,\n                    autoApproved: isAutoApproved\n                }\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('Erro ao solicitar apoio:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Repagar empr√©stimo (Repay)\n     */\n    static async repayLoan(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { loanId, useBalance, paymentMethod } = repayLoanSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // FLUXO DE PAGAMENTO COM SALDO (AUTOM√ÅTICO)\n            if (useBalance) {\n                const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                    // 1. LOCK DE SEGURAN√áA NO USU√ÅRIO (Para checar saldo com seguran√ßa)\n                    // Isso impede que ele use o mesmo saldo para pagar 2 coisas ao mesmo tempo\n                    const userBalanceRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                    if (userBalanceRes.rows.length === 0) throw new Error('Usu√°rio n√£o encontrado');\n                    const currentBalance = parseFloat(userBalanceRes.rows[0].balance);\n\n                    // 2. Buscar empr√©stimo COM LOCK (row-level lock)\n                    const loanResult = await client.query(\n                        'SELECT * FROM loans WHERE id = $1 AND user_id = $2 FOR UPDATE',\n                        [loanId, user.id]\n                    );\n\n                    if (loanResult.rows.length === 0) throw new Error('Apoio n√£o encontrado');\n                    const loan = loanResult.rows[0];\n                    const totalToPay = parseFloat(loan.total_repayment);\n\n                    // 3. Verificar saldo DENTRO dA TRANSA√á√ÉO E AP√ìS O LOCK\n                    if (currentBalance < totalToPay) {\n                        throw new Error(`Saldo insuficiente. Necess√°rio: ${totalToPay.toFixed(2)}, Atual: ${currentBalance.toFixed(2)}`);\n                    }\n\n                    // 2. Calcular saldo devedor real\n                    const paidInstallmentsResult = await client.query('SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) as paid_amount FROM loan_installments WHERE loan_id = $1', [loanId]);\n                    const paidAmount = parseFloat(paidInstallmentsResult.rows[0].paid_amount);\n\n                    const totalRepayOriginal = parseFloat(loan.total_repayment);\n                    const remainingToPay = Math.max(0, totalRepayOriginal - paidAmount);\n\n                    if (remainingToPay <= 0) throw new Error('Este apoio j√° est√° quitado.');\n\n                    // 3. Verificar saldo do usu√°rio COM LOCK\n                    const userBalanceResult = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                    const refreshedBalance = parseFloat(userBalanceResult.rows[0].balance);\n\n                    if (refreshedBalance < remainingToPay) throw new Error('Saldo insuficiente');\n\n                    // C√°lculos de distribui√ß√£o\n                    const principalAmount = parseFloat(loan.amount);\n                    const interestRatio = (totalRepayOriginal - principalAmount) / totalRepayOriginal;\n                    const remainingInterest = remainingToPay * interestRatio;\n                    const remainingPrincipal = remainingToPay - remainingInterest;\n                    const { total: finalCost } = calculateTotalToPay(remainingToPay, 'balance');\n\n                    // 4. Executar Pagamento\n                    // Debitar saldo\n                    await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [remainingToPay, user.id]);\n\n                    // Marcar empr√©stimo como PAGO\n                    await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['PAID', loanId]);\n\n                    // Registrar parcela final\n                    await client.query('INSERT INTO loan_installments (loan_id, amount, use_balance, created_at) VALUES ($1, $2, $3, $4)', [loanId, remainingToPay, true, new Date()]);\n\n                    // Registrar Transa√ß√£o\n                    await client.query(\n                        `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                         VALUES ($1, 'LOAN_PAYMENT', $2, $3, 'COMPLETED', $4)`,\n                        [\n                            user.id, finalCost,\n                            `Quita√ß√£o de Apoio (Saldo)`,\n                            JSON.stringify({ loanId, useBalance: true, principalAmount: remainingPrincipal, interestAmount: remainingInterest })\n                        ]\n                    );\n\n                    // 5. Distribui√ß√£o Cont√°bil\n                    const profitShare = remainingInterest * 0.80;\n                    const systemShare = remainingInterest * 0.20;\n                    const taxPart = systemShare * 0.20;\n                    const operPart = systemShare * 0.20;\n                    const ownerPart = systemShare * 0.20;\n                    const investPart = systemShare * 0.20;\n                    const corporatePart = systemShare * 0.20;\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            system_balance = COALESCE(system_balance, 0) + $1,\n                            investment_reserve = COALESCE(investment_reserve, 0) + $2,\n                            profit_pool = profit_pool + $3,\n                            total_tax_reserve = total_tax_reserve + $4,\n                            total_operational_reserve = total_operational_reserve + $5,\n                            total_owner_profit = total_owner_profit + $6,\n                            total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $7\n                        `, [remainingToPay, remainingPrincipal + investPart, profitShare, taxPart, operPart, ownerPart, corporatePart]\n                    );\n\n                    // 6. Atualizar Score\n                    await updateScore(client, user.id, SCORE_REWARDS.LOAN_PAYMENT_ON_TIME, 'Quita√ß√£o antecipada total');\n\n                    return { success: true };\n                });\n\n                if (!result.success) return c.json({ success: false, message: result.error || 'Erro ao processar pagamento' }, 400);\n                return c.json({ success: true, message: 'Apoio quitado com sucesso!' });\n            }\n\n            // FLUXO DE PAGAMENTO VIA PIX (Sem Transa√ß√£o Complexa por enquanto)\n            // Aqui mantemos simples pois cria apenas uma inten√ß√£o (Transaction PENDING)\n            // A atomicidade necess√°ria √© menor pois n√£o mexe em saldo ainda.\n            // Mas idealmente dever√≠amos verificar se j√° n√£o est√° pago.\n\n            const loanCheck = await pool.query('SELECT * FROM loans WHERE id = $1 AND user_id = $2', [loanId, user.id]);\n            if (loanCheck.rows.length === 0) return c.json({ success: false, message: 'Apoio n√£o encontrado' }, 404);\n            const loan = loanCheck.rows[0];\n\n            if (loan.status !== 'APPROVED' && loan.status !== 'PAYMENT_PENDING') {\n                return c.json({ success: false, message: 'Apoio n√£o eleg√≠vel para pagamento' }, 400);\n            }\n\n            const paidInstallmentsResult = await pool.query('SELECT COALESCE(SUM(CAST(amount AS NUMERIC)), 0) as paid_amount FROM loan_installments WHERE loan_id = $1', [loanId]);\n            const paidAmount = parseFloat(paidInstallmentsResult.rows[0].paid_amount);\n            const remainingToPay = Math.max(0, parseFloat(loan.total_repayment) - paidAmount);\n            const { total: finalCost } = calculateTotalToPay(remainingToPay, 'pix');\n\n            await pool.query('UPDATE loans SET status = $1 WHERE id = $2', ['PAYMENT_PENDING', loanId]);\n\n            const transaction = await pool.query(\n                `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                 VALUES ($1, 'LOAN_PAYMENT', $2, $3, 'PENDING', $4) RETURNING id`,\n                [\n                    user.id, finalCost,\n                    `Quita√ß√£o de Apoio (PIX Manual)`,\n                    JSON.stringify({ loanId, useBalance: false, paymentMethod: 'pix', manualPix: true })\n                ]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Reposi√ß√£o enviada!',\n                data: {\n                    transactionId: transaction.rows[0].id,\n                    finalCost,\n                    manualPix: {\n                        key: ADMIN_PIX_KEY,\n                        owner: 'Cred30',\n                        amount: finalCost,\n                        description: `Reposi√ß√£o de Apoio - ID ${loanId}`\n                    }\n                }\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('Erro ao pagar apoio:', error);\n            return c.json({ success: false, message: 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Pagar parcela (Repay Installment)\n     */\n    static async repayInstallment(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { loanId, installmentAmount, useBalance, paymentMethod } = repayInstallmentSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // 1. Buscar empr√©stimo com bloqueio\n                const loanResult = await client.query('SELECT * FROM loans WHERE id = $1 AND user_id = $2 FOR UPDATE', [loanId, user.id]);\n                if (loanResult.rows.length === 0) throw new Error('Apoio n√£o encontrado');\n                const loan = loanResult.rows[0];\n                if (loan.status !== 'APPROVED') throw new Error('Apoio n√£o est√° ativo para reposi√ß√£o');\n\n                // 2. Verificar saldo devedor\n                const paidInstallmentsResult = await client.query('SELECT COALESCE(SUM(CAST(COALESCE(amount, expected_amount) AS NUMERIC)), 0) as paid_amount FROM loan_installments WHERE loan_id = $1 AND status = $2', [loanId, 'PAID']);\n                const paidAmount = parseFloat(paidInstallmentsResult.rows[0].paid_amount);\n                const totalRepayment = parseFloat(loan.total_repayment);\n                const remainingAmountPre = Math.round((totalRepayment - paidAmount) * 100) / 100;\n\n                let actualInstallmentAmount = Math.round(installmentAmount * 100) / 100;\n\n                // Margem de manobra para arredondamento (ajusta se for quase o total)\n                if (actualInstallmentAmount > remainingAmountPre && actualInstallmentAmount <= remainingAmountPre + 0.05) {\n                    actualInstallmentAmount = remainingAmountPre;\n                }\n\n                if (actualInstallmentAmount > remainingAmountPre + 0.01) {\n                    throw new Error(`Valor excede o restante (Restante: R$ ${remainingAmountPre.toFixed(2)})`);\n                }\n\n                // 3. Identificar a pr√≥xima parcela pendente no cronograma\n                const pendingInstallmentRes = await client.query(\n                    'SELECT id FROM loan_installments WHERE loan_id = $1 AND status = $2 ORDER BY installment_number ASC NULLS LAST LIMIT 1',\n                    [loanId, 'PENDING']\n                );\n                const pendingInstallment = pendingInstallmentRes.rows[0];\n\n                const method: PaymentMethod = useBalance ? 'balance' : (paymentMethod as PaymentMethod);\n                const { total: finalInstallmentCost } = calculateTotalToPay(actualInstallmentAmount, method);\n\n                // FLUXO PIX MANUAL\n                if (!useBalance) {\n                    await client.query(\n                        `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                         VALUES ($1, 'LOAN_PAYMENT', $2, $3, 'PENDING', $4)`,\n                        [user.id, finalInstallmentCost, `Parcela (PIX Manual)`, JSON.stringify({\n                            loanId,\n                            installmentAmount: actualInstallmentAmount,\n                            isInstallment: true,\n                            manualPix: true,\n                            installmentId: pendingInstallment?.id || null\n                        })]\n                    );\n\n                    return { success: true, manualPix: true, finalCost: finalInstallmentCost };\n                }\n\n                // FLUXO SALDO INTERNO\n                const balanceLock = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const currentBalance = parseFloat(balanceLock.rows[0].balance);\n\n                if (currentBalance < actualInstallmentAmount) {\n                    throw new Error('Saldo insuficiente para pagar esta parcela.');\n                }\n\n                // A. Debitar saldo\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [actualInstallmentAmount, user.id]);\n\n                // B. Registrar/Atualizar parcela\n                if (pendingInstallment) {\n                    await client.query(\n                        'UPDATE loan_installments SET amount = $1, status = $2, use_balance = $3, paid_at = NOW() WHERE id = $4',\n                        [actualInstallmentAmount, 'PAID', true, pendingInstallment.id]\n                    );\n                } else {\n                    await client.query(\n                        'INSERT INTO loan_installments (loan_id, amount, use_balance, created_at, status, paid_at) VALUES ($1, $2, $3, NOW(), $4, NOW())',\n                        [loanId, actualInstallmentAmount, true, 'PAID']\n                    );\n                }\n\n                // C. Distribui√ß√£o Cont√°bil\n                const principalPortion = actualInstallmentAmount * (parseFloat(loan.amount) / parseFloat(loan.total_repayment));\n                const interestPortion = Math.max(0, actualInstallmentAmount - principalPortion);\n\n                const profitShare = interestPortion * 0.80; // 80% dos juros para cotistas\n                const systemShare = interestPortion * 0.20; // 20% dos juros para o sistema\n\n                const taxPart = systemShare * 0.20;\n                const operPart = systemShare * 0.20;\n                const ownerPart = systemShare * 0.20;\n                const investPart = systemShare * 0.20;\n                const corporatePart = systemShare * 0.20;\n\n                await client.query(`\n                    UPDATE system_config SET \n                        investment_reserve = COALESCE(investment_reserve, 0) + $1 + $6,\n                        profit_pool = profit_pool + $2,\n                        total_tax_reserve = total_tax_reserve + $3,\n                        total_operational_reserve = total_operational_reserve + $4,\n                        total_owner_profit = total_owner_profit + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $7\n                    `, [principalPortion, profitShare, taxPart, operPart, ownerPart, investPart, corporatePart]\n                );\n\n                // D. Registrar Transa√ß√£o no Hist√≥rico (CORRE√á√ÉO DE BUG: Faltava este registro)\n                await client.query(\n                    `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n                     VALUES ($1, 'LOAN_PAYMENT', $2, $3, 'COMPLETED', $4)`,\n                    [\n                        user.id, finalInstallmentCost,\n                        `Parcela de Apoio (Saldo)`,\n                        JSON.stringify({ loanId, installmentAmount, isInstallment: true, principalAmount: principalPortion, interestAmount: interestPortion })\n                    ]\n                );\n\n                // E. Verificar quita√ß√£o total\n                const newPaidAmount = paidAmount + installmentAmount;\n                if (newPaidAmount >= parseFloat(loan.total_repayment) - 0.01) {\n                    await client.query('UPDATE loans SET status = $1 WHERE id = $2', ['PAID', loanId]);\n                    await updateScore(client, user.id, SCORE_REWARDS.LOAN_PAYMENT_ON_TIME, 'Reposi√ß√£o integral via parcelas');\n                }\n\n                return { success: true, manualPix: false, remainingAmount: Math.max(0, remainingAmountPre - installmentAmount) };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error || 'Erro ao processar pagamento' }, 400);\n            }\n\n            if (result.data?.manualPix) {\n                return c.json({\n                    success: true,\n                    message: 'Realize a transfer√™ncia PIX para confirmar!',\n                    data: {\n                        finalCost: result.data.finalCost,\n                        manualPix: {\n                            key: ADMIN_PIX_KEY,\n                            owner: 'Cred30 (Admin)',\n                            amount: result.data.finalCost,\n                            description: `Parcela do Apoio - ID ${loanId}`\n                        }\n                    }\n                });\n            }\n\n            return c.json({\n                success: true,\n                message: 'Parcela paga com sucesso!',\n                data: { remainingAmount: result.data?.remainingAmount }\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('Erro ao pagar parcela:', error);\n            return c.json({ success: false, message: 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Fiador responde √† solicita√ß√£o (Aceitar/Recusar)\n     */\n    static async respondToGuarantorRequest(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { loanId, action } = z.object({\n                loanId: z.union([z.string(), z.number()]).transform(v => v.toString()),\n                action: z.enum(['APPROVE', 'REJECT'])\n            }).parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const loanRes = await pool.query(\n                `SELECT * FROM loans WHERE id = $1 AND (metadata->>'guarantorId' = $2 OR metadata->>'guarantor_id' = $2) AND status = 'WAITING_GUARANTOR'`,\n                [loanId, user.id]\n            );\n\n            if (loanRes.rows.length === 0) {\n                return c.json({ success: false, message: 'Solicita√ß√£o de fian√ßa n√£o encontrada ou j√° processada.' }, 404);\n            }\n\n            const loan = loanRes.rows[0];\n\n            if (action === 'REJECT') {\n                await pool.query(\"UPDATE loans SET status = 'REJECTED' WHERE id = $1\", [loanId]);\n                return c.json({ success: true, message: 'Solicita√ß√£o de fian√ßa recusada.' });\n            }\n\n            // Atualizar para PENDING para que possa ser aprovado\n            await pool.query(\"UPDATE loans SET status = 'PENDING' WHERE id = $1\", [loanId]);\n\n            // Tentar auto-aprova√ß√£o agora que o fiador aceitou\n            const result = await executeInTransaction(pool, async (client) => {\n                try {\n                    const configRes = await client.query('SELECT system_balance FROM system_config LIMIT 1');\n                    const systemBalance = parseFloat(configRes.rows[0].system_balance);\n                    const loansRes = await client.query(\"SELECT COALESCE(SUM(amount), 0) as total FROM loans WHERE status IN ('APPROVED', 'PAYMENT_PENDING')\");\n                    const totalLoaned = parseFloat(loansRes.rows[0].total);\n\n                    const liquidity = (systemBalance * 0.7) - totalLoaned;\n\n                    if (parseFloat(loan.amount) <= liquidity) {\n                        await processLoanApproval(client, loanId, 'APPROVE');\n                        return { autoApproved: true };\n                    }\n                } catch (e) {\n                    console.error('Erro auto-aprova√ß√£o p√≥s-fian√ßa:', e);\n                }\n                return { autoApproved: false };\n            });\n\n            return c.json({\n                success: true,\n                message: result.data?.autoApproved\n                    ? 'Fian√ßa aceita e apoio aprovado!'\n                    : 'Fian√ßa aceita! A solicita√ß√£o agora aguarda an√°lise ou recursos no caixa.'\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos' }, 400);\n            console.error('Erro ao responder fian√ßa:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/logistics.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3267,3270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3267,3270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":410,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":410,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17369,17372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17369,17372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19008,19011],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19008,19011],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":477,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":477,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20295,20298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20295,20298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'idPhoto' is assigned a value but never used.","line":492,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":492,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vehiclePhoto' is assigned a value but never used.","line":492,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":492,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'docPhoto' is assigned a value but never used.","line":492,"column":78,"nodeType":"Identifier","messageId":"unusedVar","endLine":492,"endColumn":86},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":555,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":555,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23659,23662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23659,23662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":584,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":584,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24739,24742],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24739,24742],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport {\n    LOGISTICS_SUSTAINABILITY_FEE_RATE,\n    DELIVERY_INSURANCE_RATE\n} from '../../../shared/constants/business.constants';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport class LogisticsController {\n    /**\n     * Lista entregas dispon√≠veis\n     */\n    static async listAvailable(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT \n                    mo.id as order_id,\n                    mo.delivery_fee,\n                    mo.delivery_address,\n                    mo.pickup_address,\n                    mo.contact_phone,\n                    mo.created_at,\n                    mo.pickup_lat,\n                    mo.pickup_lng,\n                    mo.delivery_lat,\n                    mo.delivery_lng,\n                    ml.title as item_title,\n                    ml.price as item_price,\n                    ml.image_url,\n                    COALESCE(seller.seller_company_name, seller.name) as seller_name,\n                    seller.id as seller_id,\n                    buyer.name as buyer_name,\n                    buyer.id as buyer_id\n                FROM marketplace_orders mo\n                LEFT JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                LEFT JOIN users seller ON mo.seller_id = seller.id\n                LEFT JOIN users buyer ON mo.buyer_id = buyer.id\n                WHERE mo.delivery_status = 'AVAILABLE'\n                  AND mo.status = 'WAITING_SHIPPING'\n                ORDER BY mo.delivery_fee DESC, mo.created_at ASC\n                LIMIT 50\n            `);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(row => {\n                    const deliveryFee = parseFloat(row.delivery_fee || '0');\n                    const courierEarnings = deliveryFee * (1 - LOGISTICS_SUSTAINABILITY_FEE_RATE);\n\n                    return {\n                        orderId: row.order_id,\n                        itemTitle: row.item_title,\n                        itemPrice: parseFloat(row.item_price || '0'),\n                        imageUrl: row.image_url,\n                        deliveryFee: deliveryFee,\n                        courierEarnings: courierEarnings.toFixed(2),\n                        deliveryAddress: row.delivery_address,\n                        pickupAddress: row.pickup_address,\n                        pickupLat: row.pickup_lat ? parseFloat(row.pickup_lat) : null,\n                        pickupLng: row.pickup_lng ? parseFloat(row.pickup_lng) : null,\n                        deliveryLat: row.delivery_lat ? parseFloat(row.delivery_lat) : null,\n                        deliveryLng: row.delivery_lng ? parseFloat(row.delivery_lng) : null,\n                        contactPhone: row.contact_phone,\n                        sellerName: row.seller_name,\n                        sellerId: row.seller_id,\n                        buyerName: row.buyer_name,\n                        buyerId: row.buyer_id,\n                        createdAt: row.created_at,\n                    };\n                })\n            });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao listar entregas:', error);\n            return c.json({ success: false, message: `Erro ao buscar entregas: ${error.message}` }, 500);\n        }\n    }\n\n    /**\n     * Aceitar entrega\n     */\n    static async acceptDelivery(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('orderId');\n            const pool = getDbPool(c);\n\n            // 1. Verificar Penalidade\n            /*\n            const userCheck = await pool.query('SELECT courier_penalty_until FROM users WHERE id = $1', [user.id]);\n            if (userCheck.rows[0]?.courier_penalty_until && new Date(userCheck.rows[0].courier_penalty_until) > new Date()) {\n                const waitTime = Math.ceil((new Date(userCheck.rows[0].courier_penalty_until).getTime() - new Date().getTime()) / 60000);\n                return c.json({ success: false, message: `Voc√™ est√° em per√≠odo de penalidade por cancelamento. Aguarde ${waitTime} minutos.` }, 403);\n            }\n            */\n\n            // 2. Verificar Entrega Ativa (Regra: Uma por vez)\n            const activeOrderCheck = await pool.query(\n                `SELECT id FROM marketplace_orders \n                 WHERE courier_id = $1 AND delivery_status IN ('ACCEPTED', 'IN_TRANSIT', 'DELIVERED')`,\n                [user.id]\n            );\n\n            if (activeOrderCheck.rows.length > 0) {\n                return c.json({ success: false, message: 'Voc√™ j√° tem uma entrega em andamento. Finalize-a antes de pegar outra.' }, 400);\n            }\n\n            const orderCheck = await pool.query(\n                `SELECT * FROM marketplace_orders \n                 WHERE id = $1 AND delivery_status = 'AVAILABLE' AND status = 'WAITING_SHIPPING'`,\n                [orderId]\n            );\n\n            if (orderCheck.rows.length === 0) {\n                return c.json({ success: false, message: 'Entrega n√£o dispon√≠vel ou j√° foi aceita.' }, 404);\n            }\n\n            const order = orderCheck.rows[0];\n\n            if (order.seller_id === user.id || order.buyer_id === user.id) {\n                return c.json({ success: false, message: 'Voc√™ n√£o pode entregar seu pr√≥prio pedido.' }, 400);\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET courier_id = $1, delivery_status = 'ACCEPTED', updated_at = NOW()\n                 WHERE id = $2`,\n                [user.id, orderId]\n            );\n\n            // --- RESERVAR SEGURO ---\n            // --- RESERVAR SEGURO & CALCULAR GANHOS ---\n            // Buscar dados atualizados do entregador para taxa correta\n            const courierData = await pool.query('SELECT is_verified FROM users WHERE id = $1', [user.id]);\n            const isVerified = courierData.rows[0]?.is_verified || false;\n\n            // TAXA DIN√ÇMICA: 10% (Selo) vs 27.5% (Sem Selo)\n            const feeRate = isVerified ? 0.10 : 0.275;\n\n            const deliveryFee = parseFloat(order.delivery_fee || '0');\n            const platformFee = deliveryFee * feeRate;\n            const courierEarnings = deliveryFee - platformFee;\n\n            // 5% de cada parte vai pro fundo de seguro\n            const courierContribution = courierEarnings * DELIVERY_INSURANCE_RATE;\n            const platformContribution = platformFee * DELIVERY_INSURANCE_RATE;\n            const totalInsurance = courierContribution + platformContribution;\n\n            await pool.query(`\n                INSERT INTO delivery_insurance_fund (order_id, courier_contribution, platform_contribution, total_amount)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (order_id) DO NOTHING\n            `, [orderId, courierContribution, platformContribution, totalInsurance]);\n\n            const listingResult = await pool.query(\n                'SELECT title FROM marketplace_listings WHERE id = $1',\n                [order.listing_id]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Entrega aceita com sucesso! V√° at√© o vendedor para coletar o produto.',\n                data: {\n                    orderId,\n                    itemTitle: listingResult.rows[0]?.title,\n                    pickupAddress: order.pickup_address,\n                    deliveryAddress: order.delivery_address,\n                    contactPhone: order.contact_phone,\n                    deliveryFee: parseFloat(order.delivery_fee),\n                    insuranceReserved: totalInsurance.toFixed(2)\n                }\n            });\n        } catch (error) {\n            console.error('[LOGISTICS] Erro ao aceitar entrega:', error);\n            return c.json({ success: false, message: 'Erro ao aceitar entrega' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar coleta\n     */\n    static async pickupDelivery(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('orderId');\n            const pool = getDbPool(c);\n\n            const body = await c.req.json().catch(() => ({}));\n            const { pickupCode } = body;\n\n            const orderCheck = await pool.query(\n                `SELECT mo.*, ml.title\n                 FROM marketplace_orders mo\n                 JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                 WHERE mo.id = $1 AND mo.courier_id = $2 AND mo.delivery_status = 'ACCEPTED'`,\n                [orderId, user.id]\n            );\n\n            if (orderCheck.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou voc√™ n√£o √© o entregador.' }, 404);\n            }\n\n            const order = orderCheck.rows[0];\n\n            if (order.pickup_code && pickupCode && order.pickup_code !== pickupCode) {\n                return c.json({ success: false, message: 'C√≥digo de coleta incorreto.' }, 400);\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET delivery_status = 'IN_TRANSIT', picked_up_at = NOW(), updated_at = NOW()\n                 WHERE id = $1`,\n                [orderId]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Coleta confirmada! Agora leve o produto at√© o comprador.',\n                data: {\n                    orderId,\n                    itemTitle: order.title,\n                    deliveryAddress: order.delivery_address,\n                    contactPhone: order.contact_phone,\n                }\n            });\n        } catch (error) {\n            console.error('[LOGISTICS] Erro ao confirmar coleta:', error);\n            return c.json({ success: false, message: 'Erro ao confirmar coleta' }, 500);\n        }\n    }\n\n    /**\n     * Marcar como entregue\n     */\n    static async markDelivered(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('orderId');\n            const pool = getDbPool(c);\n\n            const orderCheck = await pool.query(\n                `SELECT * FROM marketplace_orders \n                 WHERE id = $1 AND courier_id = $2 AND delivery_status = 'IN_TRANSIT'`,\n                [orderId, user.id]\n            );\n\n            if (orderCheck.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou n√£o est√° em tr√¢nsito.' }, 404);\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET delivery_status = 'DELIVERED', delivered_at = NOW(), updated_at = NOW()\n                 WHERE id = $1`,\n                [orderId]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Entrega marcada como conclu√≠da! Aguardando confirma√ß√£o do comprador.',\n                data: { orderId }\n            });\n        } catch (error) {\n            console.error('[LOGISTICS] Erro ao marcar entrega:', error);\n            return c.json({ success: false, message: 'Erro ao marcar entrega como conclu√≠da' }, 500);\n        }\n    }\n\n    /**\n     * Cancelar entrega (antes de coletar)\n     */\n    static async cancelDelivery(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('orderId');\n            const pool = getDbPool(c);\n\n            const orderCheck = await pool.query(\n                `SELECT * FROM marketplace_orders \n                 WHERE id = $1 AND courier_id = $2 AND delivery_status = 'ACCEPTED'`,\n                [orderId, user.id]\n            );\n\n            if (orderCheck.rows.length === 0) {\n                return c.json({\n                    success: false,\n                    message: 'N√£o √© poss√≠vel cancelar. Pedido n√£o encontrado ou j√° foi coletado.'\n                }, 400);\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET courier_id = NULL, \n                     delivery_status = 'AVAILABLE',\n                     status = CASE \n                         WHEN status IN ('PREPARING', 'READY_FOR_PICKUP') THEN 'WAITING_SHIPPING'\n                         ELSE status\n                     END,\n                     previous_couriers = array_append(COALESCE(previous_couriers, '{}'), courier_id),\n                     updated_at = NOW()\n                 WHERE id = $1`,\n                [orderId]\n            );\n\n            // Aplicar Penalidade de 30 minutos\n            await pool.query(\n                `UPDATE users \n                 SET courier_penalty_until = NOW() + INTERVAL '30 minutes' \n                 WHERE id = $1`,\n                [user.id]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Entrega cancelada. Outro entregador poder√° aceitar.',\n            });\n        } catch (error) {\n            console.error('[LOGISTICS] Erro ao cancelar entrega:', error);\n            return c.json({ success: false, message: 'Erro ao cancelar entrega' }, 500);\n        }\n    }\n\n    /**\n     * Listar minhas entregas\n     */\n    static async listMyDeliveries(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const status = c.req.query('status');\n\n            // Filtra se √© o entregador atual OU se j√° foi um dos entregadores (hist√≥rico de cancelamento)\n            let whereClause = 'WHERE (mo.courier_id = $1 OR $1 = ANY(mo.previous_couriers))';\n            if (status === 'active') {\n                whereClause += ` AND mo.delivery_status IN ('ACCEPTED', 'IN_TRANSIT', 'DELIVERED')`;\n            } else if (status === 'completed') {\n                // Hist√≥rico completo: Completadas, Canceladas ou Falhas\n                whereClause += ` AND (mo.status IN ('COMPLETED', 'CANCELLED') OR mo.delivery_status = 'CANCELLED')`;\n            }\n\n            const result = await pool.query(`\n                SELECT \n                    mo.id as order_id,\n                    mo.delivery_fee,\n                    mo.delivery_address,\n                    mo.pickup_address,\n                    mo.delivery_status,\n                    mo.status as order_status,\n                    mo.created_at,\n                    mo.picked_up_at,\n                    mo.delivered_at,\n                    ml.title as item_title,\n                    ml.image_url,\n                    COALESCE(seller.seller_company_name, seller.name) as seller_name,\n                    seller.phone as seller_phone,\n                    buyer.name as buyer_name,\n                    buyer.phone as buyer_phone\n                FROM marketplace_orders mo\n                LEFT JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                LEFT JOIN users seller ON mo.seller_id = seller.id\n                LEFT JOIN users buyer ON mo.buyer_id = buyer.id\n                ${whereClause}\n                ORDER BY mo.created_at DESC\n                LIMIT 100\n            `, [parseInt(user.id.toString())]);\n\n            const totalResult = await pool.query(`\n                SELECT \n                    COUNT(*) as total_deliveries,\n                    COALESCE(SUM(CAST(delivery_fee AS NUMERIC) * (1.0 - CAST($2 AS NUMERIC))), 0) as total_earnings\n                FROM marketplace_orders\n                WHERE courier_id = $1 AND status = 'COMPLETED'\n            `, [parseInt(user.id.toString()), LOGISTICS_SUSTAINABILITY_FEE_RATE]);\n\n            const totals = totalResult.rows[0];\n\n            return c.json({\n                success: true,\n                data: {\n                    deliveries: result.rows.map(row => {\n                        const deliveryFee = parseFloat(row.delivery_fee || '0');\n                        const courierEarnings = deliveryFee * (1 - LOGISTICS_SUSTAINABILITY_FEE_RATE);\n\n                        return {\n                            orderId: row.order_id,\n                            itemTitle: row.item_title,\n                            imageUrl: row.image_url,\n                            deliveryFee: deliveryFee,\n                            courierEarnings: courierEarnings.toFixed(2),\n                            deliveryAddress: row.delivery_address,\n                            pickupAddress: row.pickup_address,\n                            deliveryStatus: row.delivery_status,\n                            orderStatus: row.order_status,\n                            sellerName: row.seller_name,\n                            sellerPhone: row.seller_phone,\n                            buyerName: row.buyer_name,\n                            buyerPhone: row.buyer_phone,\n                            createdAt: row.created_at,\n                            pickedUpAt: row.picked_up_at,\n                            deliveredAt: row.delivered_at,\n                        };\n                    }),\n                    stats: {\n                        totalDeliveries: parseInt(totals.total_deliveries),\n                        totalEarnings: parseFloat(totals.total_earnings).toFixed(2),\n                    }\n                }\n            });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao listar minhas entregas:', error);\n            return c.json({ success: false, message: `Erro ao buscar suas entregas: ${error.message}` }, 500);\n        }\n    }\n\n    /**\n     * Estat√≠sticas do entregador\n     */\n    static async getStats(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT \n                    COUNT(*) FILTER (WHERE status = 'COMPLETED') as completed,\n                    COUNT(*) FILTER (WHERE delivery_status IN ('ACCEPTED', 'IN_TRANSIT', 'DELIVERED')) as in_progress,\n                    COALESCE(SUM(CAST(delivery_fee AS NUMERIC) * (1.0 - CAST($2 AS NUMERIC))) FILTER (WHERE status = 'COMPLETED'), 0) as total_earned,\n                    COALESCE(AVG(CAST(delivery_fee AS NUMERIC) * (1.0 - CAST($2 AS NUMERIC))) FILTER (WHERE status = 'COMPLETED'), 0) as avg_earning\n                FROM marketplace_orders\n                WHERE courier_id = $1\n            `, [parseInt(user.id.toString()), LOGISTICS_SUSTAINABILITY_FEE_RATE]);\n\n            const stats = result.rows[0];\n\n            return c.json({\n                success: true,\n                data: {\n                    completedDeliveries: parseInt(stats.completed) || 0,\n                    inProgressDeliveries: parseInt(stats.in_progress) || 0,\n                    totalEarned: parseFloat(stats.total_earned).toFixed(2),\n                    avgEarningPerDelivery: parseFloat(stats.avg_earning).toFixed(2),\n                }\n            });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao buscar estat√≠sticas:', error);\n            return c.json({ success: false, message: `Erro ao buscar estat√≠sticas: ${error.message}` }, 500);\n        }\n    }\n\n    /**\n     * Verificar status do cadastro de entregador\n     */\n    static async getCourierStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT is_courier, courier_status, courier_vehicle, courier_city, courier_state, courier_created_at, courier_price_per_km \n                 FROM users WHERE id = $1`,\n                [user.id]\n            );\n\n            const userData = result.rows[0];\n\n            return c.json({\n                success: true,\n                isCourier: userData?.is_courier || false,\n                status: userData?.courier_status || null,\n                vehicle: userData?.courier_vehicle || null,\n                city: userData?.courier_city || null,\n                state: userData?.courier_state || null,\n                registeredAt: userData?.courier_created_at || null,\n                pricePerKm: parseFloat(userData?.courier_price_per_km || '2.00'),\n            });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao buscar status do entregador:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar como entregador\n     */\n    static async registerCourier(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const { cpf, phone, city, state, vehicle, idPhoto, vehiclePhoto, docPhoto } = body;\n\n            // Verifica√ß√£o simplificada: n√£o exige mais fotos no body pois j√° foram enviadas via /kyc/upload\n            if (!cpf || !phone || !city || !state || !vehicle) {\n                return c.json({\n                    success: false,\n                    message: 'Preencha todos os campos obrigat√≥rios (CPF, telefone, cidade, estado e ve√≠culo).'\n                }, 400);\n            }\n\n            const validVehicles = ['BIKE', 'MOTO', 'CAR', 'TRUCK'];\n            if (!validVehicles.includes(vehicle)) {\n                return c.json({\n                    success: false,\n                    message: 'Tipo de ve√≠culo inv√°lido. Escolha: BIKE, MOTO, CAR ou TRUCK'\n                }, 400);\n            }\n\n            const existingCheck = await pool.query(`SELECT is_courier, score, courier_id_photo, courier_vehicle_photo, courier_doc_photo FROM users WHERE id = $1`, [user.id]);\n            if (existingCheck.rows[0]?.is_courier) {\n                return c.json({ success: false, message: 'Voc√™ j√° √© um entregador registrado' }, 400);\n            }\n\n            if ((existingCheck.rows[0]?.score || 0) < 300) {\n                return c.json({\n                    success: false,\n                    message: 'Score insuficiente. Voc√™ precisa de no m√≠nimo 300 pontos de Score (obtidos via investimentos/compras) para se candidatar como entregador.'\n                }, 403);\n            }\n\n            // Verificar se as fotos j√° foram carregadas via /kyc/upload\n            const hasPhotos = existingCheck.rows[0]?.courier_id_photo &&\n                existingCheck.rows[0]?.courier_vehicle_photo &&\n                existingCheck.rows[0]?.courier_doc_photo;\n\n            if (!hasPhotos) {\n                return c.json({\n                    success: false,\n                    message: 'Por favor, envie todas as fotos obrigat√≥rias antes de finalizar o cadastro.'\n                }, 400);\n            }\n\n            // Atualizar apenas os campos de texto, as fotos j√° foram salvas pelo endpoint /kyc/upload\n            await pool.query(\n                `UPDATE users SET \n                    is_courier = TRUE,\n                    courier_status = 'pending',\n                    courier_vehicle = $1,\n                    courier_phone = $2,\n                    courier_cpf = $3,\n                    courier_city = $4,\n                    courier_state = $5,\n                    courier_price_per_km = $6,\n                    courier_created_at = CURRENT_TIMESTAMP\n                 WHERE id = $7`,\n                [vehicle, phone, cpf, city, state, body.pricePerKm || 2.00, user.id]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Cadastro enviado para aprova√ß√£o!',\n                courier: { status: 'pending', vehicle: vehicle }\n            });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao registrar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar pre√ßo por KM\n     */\n    static async updateCourierPrice(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const { pricePerKm } = await c.req.json();\n\n            if (!pricePerKm || isNaN(parseFloat(pricePerKm))) {\n                return c.json({ success: false, message: 'Pre√ßo por KM inv√°lido' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE users SET courier_price_per_km = $1 WHERE id = $2 AND is_courier = TRUE RETURNING name`,\n                [parseFloat(pricePerKm), user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Usu√°rio n√£o √© entregador' }, 404);\n            }\n\n            return c.json({ success: true, message: 'Pre√ßo por KM atualizado!' });\n        } catch (error: any) {\n            console.error('[LOGISTICS] Erro ao atualizar pre√ßo:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar localiza√ß√£o do entregador (GPS)\n     */\n    static async updateLocation(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('orderId');\n            const { lat, lng } = await c.req.json();\n\n            if (!lat || !lng) {\n                return c.json({ success: false, message: 'Coordenadas inv√°lidas' }, 400);\n            }\n\n            // Atualiza apenas se for o entregador correto e a entrega estiver em andamento (ACCEPTED ou IN_TRANSIT)\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n                 SET courier_lat = $1, courier_lng = $2, updated_at = NOW()\n                 WHERE id = $3 AND courier_id = $4 AND delivery_status IN ('ACCEPTED', 'IN_TRANSIT')`,\n                [lat, lng, orderId, user.id]\n            );\n\n            if (result.rowCount === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o ativo para este entregador.' }, 403);\n            }\n\n            return c.json({ success: true });\n        } catch (error) {\n            console.error('[LOGISTICS] Erro ao atualizar GPS:', error);\n            return c.json({ success: false, message: 'Erro interno' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/marketplace.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2801,2804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2801,2804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5044,5047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5044,5047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5894,5897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5894,5897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8718,8721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8718,8721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10075,10078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10075,10078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":248,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":248,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":273,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":273,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":305,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":305,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":323,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14499,14502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14499,14502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":409,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18174,18177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18174,18177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":467,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21935,21938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21935,21938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":496,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":496,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23188,23191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23188,23191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":518,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23930,23933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23930,23933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":533,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24461,24464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24461,24464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":543,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":543,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24753,24756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24753,24756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":565,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":565,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25780,25783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25780,25783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":575,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":575,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26040,26043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26040,26043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":597,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":597,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26965,26968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26965,26968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { executeInTransaction, lockUserBalance, updateUserBalance, createTransaction } from '../../../domain/services/transaction.service';\nimport { getWelcomeBenefit } from '../../../application/services/welcome-benefit.service';\nimport { MARKETPLACE_ESCROW_FEE_RATE, MARKETPLACE_NON_VERIFIED_FEE_RATE } from '../../../shared/constants/business.constants';\n\nexport class MarketplaceController {\n\n    /**\n     * Antecipar Recebimento (Vendedor ou Entregador)\n     */\n    static async anticipate(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const ANTICIPATION_FEE_RATE = 0.05; // 5% de taxa\n\n            const orderRes = await pool.query(\n                'SELECT * FROM marketplace_orders WHERE id = $1',\n                [orderId]\n            );\n\n            if (orderRes.rows.length === 0) return c.json({ success: false, message: 'Pedido n√£o encontrado.' }, 404);\n\n            const order = orderRes.rows[0];\n            const metadata = order.metadata || {};\n\n            let amountToAnticipate = 0;\n            let anticipationType = ''; // 'SELLER' ou 'COURIER'\n\n            // 1. Identificar quem est√° pedindo\n            if (order.seller_id === user.id) {\n                if (metadata.anticipated) return c.json({ success: false, message: 'Venda j√° antecipada.' }, 400);\n                if (!['WAITING_SHIPPING', 'IN_TRANSIT'].includes(order.status)) return c.json({ success: false, message: 'Status inv√°lido.' }, 400);\n\n                amountToAnticipate = parseFloat(order.seller_amount);\n                anticipationType = 'SELLER';\n            } else if (order.courier_id === user.id) {\n                if (metadata.courier_anticipated) return c.json({ success: false, message: 'Frete j√° antecipado.' }, 400);\n                if (order.status !== 'IN_TRANSIT') return c.json({ success: false, message: 'A entrega precisa estar em andamento.' }, 400);\n\n                amountToAnticipate = parseFloat(order.courier_fee || '0');\n                anticipationType = 'COURIER';\n            } else {\n                return c.json({ success: false, message: 'Acesso negado para antecipa√ß√£o.' }, 403);\n            }\n\n            if (amountToAnticipate <= 0) return c.json({ success: false, message: 'Valor inv√°lido.' }, 400);\n\n            const anticipationFee = amountToAnticipate * ANTICIPATION_FEE_RATE;\n            const netAmount = amountToAnticipate - anticipationFee;\n\n            // 2. Executar\n            const result = await executeInTransaction(pool, async (client: any) => {\n                if (anticipationType === 'SELLER') {\n                    await client.query(\n                        `UPDATE marketplace_orders \n                        SET seller_amount = $1, \n                            metadata = jsonb_set(COALESCE(metadata, '{}'), '{anticipated}', 'true') \n                        WHERE id = $2`,\n                        [netAmount, orderId]\n                    );\n                } else {\n                    await client.query(\n                        `UPDATE marketplace_orders \n                        SET courier_fee = $1, \n                            metadata = jsonb_set(COALESCE(metadata, '{}'), '{courier_anticipated}', 'true') \n                        WHERE id = $2`,\n                        [netAmount, orderId]\n                    );\n                }\n\n                await updateUserBalance(client, user.id, netAmount, 'credit');\n\n                await client.query('UPDATE system_config SET profit_pool = profit_pool + $1', [anticipationFee]);\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'MARKET_ANTICIPATION',\n                    netAmount,\n                    `Antecipa√ß√£o (${anticipationType === 'SELLER' ? 'Venda' : 'Frete'}) #${orderId} (Taxa R$ ${anticipationFee.toFixed(2)})`,\n                    'APPROVED'\n                );\n\n                return { netAmount, fee: anticipationFee };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: `Antecipado! R$ ${result.data?.netAmount.toFixed(2)} dispon√≠veis.`,\n                data: result.data\n            });\n\n        } catch (error) {\n            console.error('Anticipation Error:', error);\n            return c.json({ success: false, message: 'Erro ao processar antecipa√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Processar Liquida√ß√£o de Saldo (Settlement)\n     */\n    static async processSettlement(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: any) => {\n                const userRes = await client.query('SELECT pending_balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const pending = parseFloat(userRes.rows[0].pending_balance || '0');\n\n                if (pending <= 0) return { success: false, message: 'Nenhum saldo pendente para liquidar.' };\n\n                await client.query('UPDATE users SET balance = balance + pending_balance, pending_balance = 0 WHERE id = $1', [user.id]);\n                await createTransaction(client, user.id, 'SETTLEMENT_RELEASE', pending, 'Liquida√ß√£o de Vendas (Libera√ß√£o de Saldo Pendente)', 'APPROVED');\n\n                return { success: true, amount: pending };\n            });\n\n            if (!result.success || !result.data?.success) {\n                return c.json({ success: false, message: result.error || (result.data as any)?.message || 'Erro no processamento' }, 400);\n            }\n\n            // Type narrowing para o TS parar de reclamar\n            const settlementData = result.data as { success: true, amount: number };\n            return c.json({ success: true, message: `R$ ${settlementData.amount.toFixed(2)} liberados para saque.` });\n\n        } catch (error) {\n            console.error('Settlement Error:', error);\n            return c.json({ success: false, message: 'Erro ao processar liquida√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Listar miss√µes log√≠sticas (Entregas dispon√≠veis)\n     */\n    static async getLogisticMissions(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const { lat, lng, radius } = c.req.query();\n            console.log(`[DEBUG] getLogisticMissions - User: ${user.id}, Lat: ${lat}, Lng: ${lng}, Radius: ${radius}`);\n\n            const hasAdminVision = user.isAdmin === true || user.role === 'ADMIN';\n\n            // Taxas para c√°lculo de ganhos estimados\n            const FEE_VERIFIED = 0.10;\n            const FEE_UNVERIFIED = 0.275;\n\n            // Buscar status de verifica√ß√£o do usu√°rio atual\n            const userCheck = await pool.query('SELECT is_verified_courier FROM users WHERE id = $1', [user.id]);\n            const isVerified = userCheck.rows[0]?.is_verified_courier || false;\n            const feeRate = isVerified ? FEE_VERIFIED : FEE_UNVERIFIED;\n\n            let query = `\n                SELECT o.id as \"orderId\", o.delivery_fee as \"deliveryFee\", \n                       o.delivery_address as \"deliveryAddress\", o.pickup_address as \"pickupAddress\", \n                       o.pickup_lat, o.pickup_lng, o.delivery_lat, o.delivery_lng,\n                       o.created_at as \"createdAt\", o.contact_phone as \"buyerPhone\",\n                       COALESCE(u_seller.phone, u_seller.pix_key) as \"sellerPhone\",\n                       l.title as \"itemTitle\", l.image_url as \"imageUrl\",\n                       COALESCE(u_seller.seller_company_name, u_seller.name) as \"sellerName\", u_buyer.name as \"buyerName\",\n                       (o.delivery_fee * (1 - ${feeRate})) as \"courierEarnings\"\n                FROM marketplace_orders o\n                JOIN marketplace_listings l ON o.listing_id = l.id\n                JOIN users u_seller ON o.seller_id = u_seller.id\n                JOIN users u_buyer ON o.buyer_id = u_buyer.id\n                WHERE o.delivery_status = 'AVAILABLE'\n                  AND o.status IN ('WAITING_SHIPPING', 'PREPARING', 'READY_FOR_PICKUP')\n                  AND ($2 = TRUE OR (o.seller_id::text != $1::text AND o.buyer_id::text != $1::text))\n                  AND (o.invited_courier_id IS NULL OR o.invited_courier_id::text = $1::text)\n            `;\n\n            const params: any[] = [user.id, hasAdminVision];\n            let pIndex = 3;\n\n            // Filtro Geogr√°fico Otimizado (SQL) - Raio em KM (Padr√£o 30km)\n            if (lat && lng) {\n                const searchLat = parseFloat(lat);\n                const searchLng = parseFloat(lng);\n                const r = parseFloat(radius || '30');\n\n                if (!isNaN(searchLat) && !isNaN(searchLng)) {\n                    query += ` AND (\n                        o.pickup_lat IS NULL OR\n                        (6371 * acos(\n                            LEAST(1, GREATEST(-1, \n                                cos(radians($${pIndex})) * cos(radians(o.pickup_lat)) *\n                                cos(radians(o.pickup_lng) - radians($${pIndex + 1})) +\n                                sin(radians($${pIndex})) * sin(radians(o.pickup_lat))\n                            ))\n                        )) <= $${pIndex + 2}\n                    )`;\n                    params.push(searchLat, searchLng, r);\n                    pIndex += 3;\n                }\n            }\n\n            query += ` ORDER BY o.delivery_fee DESC LIMIT 50`;\n\n            const result = await pool.query(query, params);\n            console.log(`[DEBUG] getLogisticMissions - Found ${result.rows.length} missions`);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('Error listing missions:', error);\n            return c.json({ success: false, message: 'Erro ao buscar miss√µes' }, 500);\n        }\n    }\n\n    /**\n     * Aceitar Miss√£o Log√≠stica\n     */\n    static async acceptMission(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n\n            const missionCheck = await pool.query('SELECT invited_courier_id FROM marketplace_orders WHERE id = $1', [orderId]);\n            if (missionCheck.rows.length === 0) return c.json({ success: false, message: 'Miss√£o n√£o encontrada.' }, 404);\n\n            const invitedId = missionCheck.rows[0].invited_courier_id;\n            if (invitedId && invitedId !== user.id) {\n                return c.json({ success: false, message: 'Esta miss√£o foi reservada para outro entregador.' }, 403);\n            }\n\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n                 SET delivery_status = 'ACCEPTED', courier_id = $1, updated_at = NOW()\n                 WHERE id = $2 AND delivery_status = 'AVAILABLE'\n                 RETURNING pickup_code`,\n                [user.id, orderId]\n            );\n\n            if (result.rows.length === 0) return c.json({ success: false, message: 'Miss√£o n√£o dispon√≠vel ou j√° aceita.' }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Miss√£o aceita! Dirija-se ao vendedor.',\n                pickupCode: result.rows[0].pickup_code\n            });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao aceitar miss√£o' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar Coleta de Item (Sair para entrega)\n     */\n    static async pickupMission(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const { pickupCode } = await c.req.json();\n\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n                 SET delivery_status = 'IN_TRANSIT', updated_at = NOW()\n                 WHERE id = $1 AND courier_id = $2 AND pickup_code = $3 AND delivery_status = 'ACCEPTED'`,\n                [orderId, user.id, pickupCode]\n            );\n\n            if (result.rowCount === 0) return c.json({ success: false, message: 'C√≥digo inv√°lido ou miss√£o n√£o encontrada.' }, 400);\n\n            return c.json({ success: true, message: 'Coleta confirmada! Inicie o trajeto.' });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao confirmar coleta' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar localiza√ß√£o GPS do Entregador\n     */\n    static async updateMissionLocation(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const { lat, lng } = await c.req.json();\n\n            if (typeof lat !== 'number' || typeof lng !== 'number') {\n                return c.json({ success: false, message: 'Coordenadas inv√°lidas' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n                 SET courier_lat = $1, courier_lng = $2, updated_at = NOW()\n                 WHERE id = $3 AND courier_id = $4 AND status IN ('WAITING_SHIPPING', 'IN_TRANSIT')\n                 RETURNING id`,\n                [lat, lng, orderId, user.id]\n            );\n\n            if (result.rowCount === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou voc√™ n√£o √© o entregador deste pedido.' }, 403);\n            }\n\n            return c.json({ success: true });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao atualizar localiza√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar Entrega Realizada (Pagamento ao Entregador)\n     */\n    static async confirmDelivered(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n\n            // Taxas\n            const FEE_VERIFIED = 0.10;\n            const FEE_UNVERIFIED = 0.275;\n\n            const result = await executeInTransaction(pool, async (client: any) => {\n                // 1. Buscar Pedido e Status do Entregador\n                const orderRes = await client.query(`\n                    SELECT o.id, o.delivery_fee, o.delivery_status, u.is_verified_courier \n                    FROM marketplace_orders o\n                    JOIN users u ON u.id = $2\n                    WHERE o.id = $1 AND o.courier_id = $2\n                `, [orderId, user.id]);\n\n                if (orderRes.rows.length === 0) throw new Error('Pedido n√£o encontrado ou n√£o pertence a voc√™.');\n\n                const order = orderRes.rows[0];\n                if (order.delivery_status !== 'IN_TRANSIT') throw new Error('Pedido n√£o est√° em tr√¢nsito.');\n\n                // 2. Calcular Pagamento\n                const deliveryVal = parseFloat(order.delivery_fee || '0');\n                if (deliveryVal <= 0) throw new Error('Valor de entrega inv√°lido.');\n\n                const isVerified = !!order.is_verified_courier;\n                const feeRate = isVerified ? FEE_VERIFIED : FEE_UNVERIFIED;\n\n                const platformShare = deliveryVal * feeRate;\n                const courierShare = deliveryVal - platformShare;\n\n                // 3. Atualizar Status e Pagar\n                await client.query(\n                    `UPDATE marketplace_orders \n                     SET delivery_status = 'DELIVERED', status = 'DELIVERED', delivered_at = NOW() \n                     WHERE id = $1`,\n                    [orderId]\n                );\n\n                await updateUserBalance(client, user.id, courierShare, 'credit');\n                await client.query('UPDATE system_config SET profit_pool = profit_pool + $1', [platformShare]);\n\n                await createTransaction(\n                    client, user.id, 'LOGISTIC_EARNING', courierShare,\n                    `Entrega #${orderId} Realizada (${isVerified ? 'Selo Verificado 10%' : 'Sem Selo 27.5%'})`,\n                    'APPROVED'\n                );\n\n                return { courierShare, platformShare };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: `Entrega confirmada! Voc√™ recebeu R$ ${result.data?.courierShare.toFixed(2)}.`,\n                earned: result.data?.courierShare\n            });\n\n        } catch (error) {\n            console.error('Confirm Delivery Error:', error);\n            return c.json({ success: false, message: 'Erro ao confirmar entrega' }, 500);\n        }\n    }\n\n    /**\n     * Sincroniza√ß√£o de Vendas Offline\n     */\n    static async syncOffline(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            // Usando schema local se poss√≠vel ou validando manualmente\n            const { transactions } = body;\n            if (!Array.isArray(transactions)) return c.json({ success: false, message: 'Formato inv√°lido' }, 400);\n\n            const results = [];\n\n            for (const tx of transactions) {\n                const existing = await pool.query('SELECT id FROM marketplace_orders WHERE offline_token = $1', [tx.id]);\n                if (existing.rows.length > 0) {\n                    results.push({ id: tx.id, status: 'ALREADY_PROCESSED' });\n                    continue;\n                }\n\n                if (tx.sellerId !== user.id) {\n                    results.push({ id: tx.id, status: 'SKIPPED', message: 'Seller ID mismatch' });\n                    continue;\n                }\n\n                try {\n                    await executeInTransaction(pool, async (client: any) => {\n                        const balanceCheck = await lockUserBalance(client, tx.buyerId, tx.amount, { skipLockCheck: true });\n                        if (!balanceCheck.success) throw new Error(`Saldo insuficiente no comprador ${tx.buyerId}`);\n\n                        const sellerResult = await client.query('SELECT asaas_wallet_id, is_verified_seller, seller_cpf_cnpj FROM users WHERE id = $1', [tx.sellerId]);\n                        const sellerData = sellerResult.rows[0];\n                        const isVerified = !!sellerData?.is_verified_seller;\n\n                        const sellerDoc = sellerData?.seller_cpf_cnpj;\n                        const docClean = sellerDoc ? sellerDoc.replace(/\\D/g, '') : '';\n                        const isCnpj = docClean.length === 14;\n                        const isCpf = !isCnpj; // Se n√£o √© CNPJ, tratamos como CPF\n\n                        // --- TRAVA DE VENDAS 2k (CPF) ---\n                        // REGRA: CPF trava em 2k. CNPJ ilimitado.\n                        if (isCpf) {\n                            const startOfMonth = new Date();\n                            startOfMonth.setDate(1);\n                            startOfMonth.setHours(0, 0, 0, 0);\n\n                            const salesRes = await client.query(`\n                                SELECT COALESCE(SUM(amount), 0) as total \n                                FROM marketplace_orders \n                                WHERE seller_id = $1 \n                                AND created_at >= $2 \n                                AND status != 'CANCELLED'\n                            `, [tx.sellerId, startOfMonth]);\n\n                            const currentMonthlySales = parseFloat(salesRes.rows[0].total);\n                            if (currentMonthlySales + tx.amount > 2000) {\n                                throw new Error('Limite mensal de vendas para CPF atingido (R$ 2.000,00). Atualize para CNPJ para continuar vendendo.');\n                            }\n                        }\n\n                        const baseFeeRate = isVerified ? MARKETPLACE_ESCROW_FEE_RATE : MARKETPLACE_NON_VERIFIED_FEE_RATE;\n\n                        const welcomeBenefit = await getWelcomeBenefit(client, tx.buyerId);\n                        const effectiveEscrowRate = welcomeBenefit.hasDiscount ? baseFeeRate * 0.5 : baseFeeRate;\n\n                        const fee = tx.amount * effectiveEscrowRate;\n                        const sellerAmount = tx.amount - fee;\n\n                        await updateUserBalance(client, tx.buyerId, tx.amount, 'debit');\n                        await updateUserBalance(client, tx.sellerId, sellerAmount, 'credit');\n\n                        const orderResult = await client.query(\n                            `INSERT INTO marketplace_orders (\n                                listing_id, buyer_id, seller_id, amount, fee_amount, seller_amount, \n                                status, payment_method, offline_token, delivery_status, delivered_at\n                            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW()) RETURNING id`,\n                            [null, tx.buyerId, tx.sellerId, tx.amount, fee, sellerAmount, 'COMPLETED', 'OFFLINE_QR', tx.id, 'DELIVERED']\n                        );\n\n                        const orderId = orderResult.rows[0].id;\n                        await createTransaction(client, tx.buyerId, 'MARKET_PURCHASE', tx.amount, `Compra Presencial: ${tx.itemTitle}`, 'APPROVED', { orderId });\n                        await createTransaction(client, tx.sellerId, 'MARKET_SALE', sellerAmount, `Venda Presencial: ${tx.itemTitle}`, 'APPROVED', { orderId });\n                    });\n                    results.push({ id: tx.id, status: 'SUCCESS' });\n                } catch (err: any) {\n                    console.error(`Error processing offline tx ${tx.id}:`, err);\n                    results.push({ id: tx.id, status: 'FAILED', message: err.message });\n                }\n            }\n\n            return c.json({ success: true, results });\n        } catch (error) {\n            console.error('Offline Sync Error:', error);\n            return c.json({ success: false, message: 'Erro na sincroniza√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Listar estabelecimentos de delivery (Restaurantes/Lojas de Bebida)\n     */\n    static async getDeliveryVenues(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { category, city, state } = c.req.query();\n\n            let query = `\n                SELECT id, name, merchant_name, is_restaurant, is_liquor_store, \n                restaurant_category, seller_address_city as city, seller_address_state as state,\n                seller_address_neighborhood as neighborhood, seller_address_street as street,\n                COALESCE(avatar_url, NULL) as avatar_url, COALESCE(seller_rating, 0) as rating, opening_hours\n                FROM users \n                WHERE (is_restaurant = TRUE OR is_liquor_store = TRUE)\n            `;\n            const params: any[] = [];\n            let pIndex = 1;\n\n            if (category && category !== 'TODOS') {\n                query += ` AND restaurant_category = $${pIndex++}`;\n                params.push(category);\n            }\n\n            if (city) {\n                query += ` AND seller_address_city = $${pIndex++}`;\n                params.push(city);\n            }\n\n            if (state) {\n                query += ` AND seller_address_state = $${pIndex++}`;\n                params.push(state);\n            }\n\n            query += ` ORDER BY seller_rating DESC NULLS LAST, created_at DESC LIMIT 50`;\n\n            const result = await pool.query(query, params);\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar categorias de comida (Para o Carrossel)\n     */\n    static async getFoodCategories(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query(\n                `SELECT * FROM marketplace_food_categories WHERE is_active = TRUE ORDER BY display_order ASC`\n            );\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar perfil da loja (Nome Comercial, Categoria, Hor√°rios)\n     */\n    static async updateStoreProfile(c: Context) {\n        try {\n            const user = c.get('user') as any;\n            const pool = getDbPool(c);\n            const { merchantName, category, openingHours } = await c.req.json();\n\n            // Validar se √© vendedor\n            const sellerRes = await pool.query('SELECT is_restaurant, is_liquor_store FROM users WHERE id = $1', [user.id]);\n            const seller = sellerRes.rows[0];\n\n            if (!user.isAdmin && (!seller || (!seller.is_restaurant && !seller.is_liquor_store))) {\n                return c.json({ success: false, message: 'Apenas administradores ou vendedores de delivery podem configurar este perfil.' }, 403);\n            }\n\n            await pool.query(\n                `UPDATE users SET \n                merchant_name = $1, \n                restaurant_category = $2, \n                opening_hours = $3 \n                WHERE id = $4`,\n                [merchantName, category, JSON.stringify(openingHours), user.id]\n            );\n\n            return c.json({ success: true, message: 'Perfil da loja atualizado com sucesso!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Alternar pausa manual da loja\n     */\n    static async toggleMerchantPause(c: Context) {\n        try {\n            const user = c.get('user') as any;\n            const pool = getDbPool(c);\n            const { isPaused } = await c.req.json();\n\n            // Validar se √© vendedor\n            const sellerRes = await pool.query('SELECT is_restaurant, is_liquor_store FROM users WHERE id = $1', [user.id]);\n            const seller = sellerRes.rows[0];\n\n            if (!user.isAdmin && (!seller || (!seller.is_restaurant && !seller.is_liquor_store))) {\n                return c.json({ success: false, message: 'Apenas administradores ou vendedores de delivery podem pausar a loja.' }, 403);\n            }\n\n            await pool.query(\n                `UPDATE users SET is_paused = $1 WHERE id = $2`,\n                [isPaused, user.id]\n            );\n\n            return c.json({\n                success: true,\n                isPaused,\n                message: isPaused ? 'Loja pausada com sucesso!' : 'Loja aberta com sucesso!'\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/marketplace.enhancements.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1605,1608],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1605,1608],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2446,2449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2446,2449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3870,3873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3870,3873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5468,5471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5468,5471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6227,6230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6227,6230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9793,9796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9793,9796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11344,11347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11344,11347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":341,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13247,13250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13247,13250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n/**\n * Controller para funcionalidades estilo Mercado Livre:\n * - Favoritos (Lista de desejos)\n * - Perguntas e Respostas\n * - Avalia√ß√µes\n */\nexport class MarketplaceEnhancementsController {\n\n    // === FAVORITOS ===\n\n    /**\n     * Adicionar/Remover item dos favoritos (toggle)\n     */\n    static async toggleFavorite(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const listingId = c.req.param('id');\n\n            // Verificar se j√° √© favorito\n            const existing = await pool.query(\n                'SELECT id FROM marketplace_favorites WHERE user_id = $1 AND listing_id = $2',\n                [user.id, listingId]\n            );\n\n            if (existing.rows.length > 0) {\n                // Remover dos favoritos\n                await pool.query('DELETE FROM marketplace_favorites WHERE id = $1', [existing.rows[0].id]);\n                return c.json({ success: true, favorited: false, message: 'Removido dos favoritos' });\n            } else {\n                // Adicionar aos favoritos\n                await pool.query(\n                    'INSERT INTO marketplace_favorites (user_id, listing_id) VALUES ($1, $2)',\n                    [user.id, listingId]\n                );\n                return c.json({ success: true, favorited: true, message: 'Adicionado aos favoritos' });\n            }\n        } catch (error: any) {\n            console.error('[FAVORITES] Erro:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar meus favoritos\n     */\n    static async getMyFavorites(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT l.*, u.name as seller_name, f.created_at as favorited_at\n                FROM marketplace_favorites f\n                JOIN marketplace_listings l ON f.listing_id = l.id\n                JOIN users u ON l.seller_id = u.id\n                WHERE f.user_id = $1\n                ORDER BY f.created_at DESC\n            `, [user.id]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('[FAVORITES] Erro ao listar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // === PERGUNTAS E RESPOSTAS ===\n\n    /**\n     * Fazer uma pergunta sobre um an√∫ncio\n     */\n    static async askQuestion(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const listingId = c.req.param('id');\n            const body = await c.req.json();\n            const { question } = body;\n\n            if (!question || question.trim().length < 5) {\n                return c.json({ success: false, message: 'Pergunta muito curta' }, 400);\n            }\n\n            // Verificar se n√£o √© o pr√≥prio vendedor\n            const listing = await pool.query('SELECT seller_id FROM marketplace_listings WHERE id = $1', [listingId]);\n            if (listing.rows[0]?.seller_id === user.id) {\n                return c.json({ success: false, message: 'Voc√™ n√£o pode perguntar no seu pr√≥prio an√∫ncio' }, 400);\n            }\n\n            const result = await pool.query(\n                'INSERT INTO marketplace_questions (listing_id, user_id, question) VALUES ($1, $2, $3) RETURNING *',\n                [listingId, user.id, question.trim()]\n            );\n\n            return c.json({ success: true, data: result.rows[0], message: 'Pergunta enviada!' });\n        } catch (error: any) {\n            console.error('[QUESTIONS] Erro:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Responder uma pergunta (somente vendedor)\n     */\n    static async answerQuestion(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const questionId = c.req.param('id');\n            const body = await c.req.json();\n            const { answer } = body;\n\n            if (!answer || answer.trim().length < 2) {\n                return c.json({ success: false, message: 'Resposta muito curta' }, 400);\n            }\n\n            // Verificar se √© o vendedor do an√∫ncio\n            const question = await pool.query(`\n                SELECT q.*, l.seller_id \n                FROM marketplace_questions q\n                JOIN marketplace_listings l ON q.listing_id = l.id\n                WHERE q.id = $1\n            `, [questionId]);\n\n            if (question.rows.length === 0) {\n                return c.json({ success: false, message: 'Pergunta n√£o encontrada' }, 404);\n            }\n\n            if (question.rows[0].seller_id !== user.id) {\n                return c.json({ success: false, message: 'Apenas o vendedor pode responder' }, 403);\n            }\n\n            await pool.query(\n                'UPDATE marketplace_questions SET answer = $1, answered_at = NOW() WHERE id = $2',\n                [answer.trim(), questionId]\n            );\n\n            return c.json({ success: true, message: 'Resposta enviada!' });\n        } catch (error: any) {\n            console.error('[QUESTIONS] Erro ao responder:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar perguntas de um an√∫ncio\n     */\n    static async getQuestions(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const listingId = c.req.param('id');\n\n            const result = await pool.query(`\n                SELECT q.*, u.name as user_name\n                FROM marketplace_questions q\n                JOIN users u ON q.user_id = u.id\n                WHERE q.listing_id = $1\n                ORDER BY q.created_at DESC\n            `, [listingId]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            console.error('[QUESTIONS] Erro ao listar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // === AVALIA√á√ïES ===\n\n    /**\n     * Avaliar ap√≥s pedido conclu√≠do\n     */\n    static async rateUser(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const body = await c.req.json();\n            const { rating, comment } = body;\n\n            if (!rating || rating < 1 || rating > 5) {\n                return c.json({ success: false, message: 'Avalia√ß√£o deve ser de 1 a 5 estrelas' }, 400);\n            }\n\n            // Buscar pedido\n            const order = await pool.query(\n                'SELECT * FROM marketplace_orders WHERE id = $1 AND status = $2',\n                [orderId, 'COMPLETED']\n            );\n\n            if (order.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou n√£o finalizado' }, 404);\n            }\n\n            const orderData = order.rows[0];\n            let reviewedUserId: string;\n            let reviewType: string;\n\n            // Determinar quem est√° avaliando quem\n            if (orderData.buyer_id === user.id) {\n                reviewedUserId = orderData.seller_id;\n                reviewType = 'BUYER_TO_SELLER';\n            } else if (orderData.seller_id === user.id) {\n                reviewedUserId = orderData.buyer_id;\n                reviewType = 'SELLER_TO_BUYER';\n            } else {\n                return c.json({ success: false, message: 'Voc√™ n√£o faz parte deste pedido' }, 403);\n            }\n\n            // Verificar se j√° avaliou\n            const existing = await pool.query(\n                'SELECT id FROM marketplace_reviews WHERE order_id = $1 AND reviewer_id = $2',\n                [orderId, user.id]\n            );\n\n            if (existing.rows.length > 0) {\n                return c.json({ success: false, message: 'Voc√™ j√° avaliou este pedido' }, 400);\n            }\n\n            // Inserir avalia√ß√£o\n            await pool.query(\n                `INSERT INTO marketplace_reviews (order_id, reviewer_id, reviewed_user_id, rating, comment, review_type)\n                 VALUES ($1, $2, $3, $4, $5, $6)`,\n                [orderId, user.id, reviewedUserId, rating, comment || null, reviewType]\n            );\n\n            // Atualizar estat√≠sticas do avaliado\n            await pool.query(`\n                UPDATE users SET\n                    seller_total_reviews = seller_total_reviews + 1,\n                    seller_rating = (\n                        SELECT AVG(rating) FROM marketplace_reviews WHERE reviewed_user_id = $1\n                    ),\n                    seller_reputation = CASE\n                        WHEN seller_total_sales >= 100 AND (SELECT AVG(rating) FROM marketplace_reviews WHERE reviewed_user_id = $1) >= 4.5 THEN 'DIAMANTE'\n                        WHEN seller_total_sales >= 50 AND (SELECT AVG(rating) FROM marketplace_reviews WHERE reviewed_user_id = $1) >= 4.0 THEN 'OURO'\n                        WHEN seller_total_sales >= 20 AND (SELECT AVG(rating) FROM marketplace_reviews WHERE reviewed_user_id = $1) >= 3.5 THEN 'PRATA'\n                        WHEN seller_total_sales >= 5 THEN 'BRONZE'\n                        ELSE 'NOVO'\n                    END\n                WHERE id = $1\n            `, [reviewedUserId]);\n\n            return c.json({ success: true, message: 'Avalia√ß√£o enviada!' });\n        } catch (error: any) {\n            console.error('[REVIEWS] Erro:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Buscar avalia√ß√µes de um usu√°rio\n     */\n    static async getUserReviews(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const userId = c.req.param('userId');\n\n            const result = await pool.query(`\n                SELECT r.*, u.name as reviewer_name\n                FROM marketplace_reviews r\n                JOIN users u ON r.reviewer_id = u.id\n                WHERE r.reviewed_user_id = $1\n                ORDER BY r.created_at DESC\n                LIMIT 50\n            `, [userId]);\n\n            // Estat√≠sticas\n            const stats = await pool.query(`\n                SELECT \n                    COUNT(*) as total_reviews,\n                    AVG(rating) as avg_rating,\n                    COUNT(*) FILTER (WHERE rating = 5) as five_stars,\n                    COUNT(*) FILTER (WHERE rating = 4) as four_stars,\n                    COUNT(*) FILTER (WHERE rating = 3) as three_stars,\n                    COUNT(*) FILTER (WHERE rating = 2) as two_stars,\n                    COUNT(*) FILTER (WHERE rating = 1) as one_star\n                FROM marketplace_reviews WHERE reviewed_user_id = $1\n            `, [userId]);\n\n            return c.json({\n                success: true,\n                data: {\n                    reviews: result.rows,\n                    stats: stats.rows[0]\n                }\n            });\n        } catch (error: any) {\n            console.error('[REVIEWS] Erro ao listar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Buscar perfil p√∫blico do vendedor (Loja)\n     */\n    static async getSellerProfile(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const sellerId = c.req.param('id');\n\n            // Dados do Perfil\n            const result = await pool.query(`\n                SELECT \n                    u.id, u.name, \n                    COALESCE(u.seller_company_name, u.name) as store_name,\n                    u.is_verified, u.created_at as member_since,\n                    u.seller_rating, u.seller_total_reviews, u.seller_total_sales, u.seller_reputation,\n                    u.seller_address_city as city, u.seller_address_state as state,\n                    u.avatar_url,\n                    (SELECT COUNT(*) FROM marketplace_listings WHERE seller_id = u.id AND status = 'ACTIVE') as active_listings\n                FROM users u\n                WHERE u.id = $1 AND u.is_seller = true\n            `, [sellerId]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Vendedor n√£o encontrado' }, 404);\n            }\n\n            // An√∫ncios da Loja\n            const listings = await pool.query(`\n                SELECT id, title, description, price, category, image_url, stock, is_boosted, created_at\n                FROM marketplace_listings\n                WHERE seller_id = $1 AND status = 'ACTIVE' AND stock > 0\n                ORDER BY is_boosted DESC, created_at DESC\n                LIMIT 50\n            `, [sellerId]);\n\n            return c.json({\n                success: true,\n                data: {\n                    ...result.rows[0],\n                    listings: listings.rows\n                }\n            });\n        } catch (error: any) {\n            console.error('[SELLER_PROFILE] Erro:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/marketplace.listings.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2700,2703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2700,2703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3949,3952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3949,3952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":368,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":368,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15547,15550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15547,15550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":420,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":420,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17972,17975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17972,17975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, lockUserBalance, updateUserBalance, createTransaction } from '../../../domain/services/transaction.service';\nimport { UserContext } from '../../../shared/types/hono.types';\n\n// Schemas\n// Update Schema to include variants and images\nconst createListingSchema = z.object({\n    title: z.string().min(3),\n    description: z.string().min(10),\n    price: z.coerce.number().min(0.01),\n    category: z.string().optional().default('OUTROS'),\n    imageUrl: z.string().optional(), // Mantido para compatibilidade (ser√° a imagem principal)\n    images: z.array(z.string()).optional(), // Array de URLs (Base64 ou Links)\n    variants: z.array(z.object({\n        name: z.string().optional(),\n        color: z.string().optional(),\n        size: z.string().optional(),\n        stock: z.coerce.number().int().min(0).default(0),\n        price: z.coerce.number().optional()\n    })).optional(),\n    itemType: z.enum(['PHYSICAL', 'DIGITAL']).optional().default('PHYSICAL'),\n    digitalContent: z.string().optional(),\n    requiredVehicle: z.enum(['BIKE', 'MOTO', 'CAR', 'TRUCK']).optional().default('MOTO'),\n    stock: z.coerce.number().int().min(1).optional().default(1), // Estoque total/fallback\n    pickupAddress: z.string().optional(),\n    postalCode: z.string().optional(),\n    weightGrams: z.coerce.number().int().min(0).optional().default(1000),\n    freeShipping: z.coerce.boolean().optional().default(false),\n    shippingPrice: z.coerce.number().min(0).optional().default(0),\n    isFood: z.coerce.boolean().optional().default(false),\n    estimatedPrepTimeMinutes: z.coerce.number().int().min(1).optional().default(20),\n    pickupLat: z.coerce.number().optional(),\n    pickupLng: z.coerce.number().optional()\n});\n\nexport class MarketplaceListingsController {\n\n    /**\n     * Listar todos os an√∫ncios ativos com filtros\n     */\n    static async getListings(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { category, search, city, state, minPrice, maxPrice } = c.req.query();\n\n            let query = `\n                SELECT l.*, COALESCE(u.seller_company_name, u.name) as seller_name, u.is_verified as seller_verified,\n                u.seller_address_city as city, u.seller_address_state as state,\n                u.seller_address_neighborhood as neighborhood,\n                l.pickup_lat, l.pickup_lng\n                FROM marketplace_listings l\n                JOIN users u ON l.seller_id = u.id\n                WHERE l.status = 'ACTIVE' AND l.stock > 0\n            `;\n            const params: any[] = [];\n            let pIndex = 1;\n\n            if (category && category !== 'TODOS') {\n                query += ` AND l.category = $${pIndex++}`;\n                params.push(category);\n            }\n\n            if (search) {\n                query += ` AND (l.title ILIKE $${pIndex} OR l.description ILIKE $${pIndex})`;\n                params.push(`%${search}%`);\n                pIndex++;\n            }\n\n            if (city) {\n                query += ` AND u.seller_address_city = $${pIndex++}`;\n                params.push(city);\n            }\n\n            if (state) {\n                query += ` AND u.seller_address_state = $${pIndex++}`;\n                params.push(state);\n            }\n\n            if (minPrice) {\n                query += ` AND l.price >= $${pIndex++}`;\n                params.push(parseFloat(minPrice));\n            }\n\n            if (maxPrice) {\n                query += ` AND l.price <= $${pIndex++}`;\n                params.push(parseFloat(maxPrice));\n            }\n\n            query += ` ORDER BY l.is_boosted DESC, l.created_at DESC LIMIT 100`;\n\n            const result = await pool.query(query, params);\n            return c.json({ success: true, data: { listings: result.rows } });\n        } catch (error: any) {\n            console.error('Get Listings Error:', error.message, error.stack);\n            return c.json({ success: false, message: error.message || 'Erro ao buscar an√∫ncios' }, 500);\n        }\n    }\n\n    /**\n     * Obter detalhes do an√∫ncio (Publico)\n     */\n    static async getListingDetails(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const id = c.req.param('id');\n\n            const listingRes = await pool.query(`\n                SELECT \n                    l.*, \n                    COALESCE(u.seller_company_name, u.name) as seller_name, \n                    u.is_verified as seller_verified,\n                    u.avatar_url as seller_avatar,\n                    u.is_paused as is_paused,\n                    COALESCE(u.seller_rating, 0) as seller_rating,\n                    (SELECT COUNT(*) FROM marketplace_orders WHERE seller_id = l.seller_id AND status = 'COMPLETED') as sales_count,\n                    COALESCE(\n                        u.address,\n                        CONCAT_WS(', ', \n                            u.seller_address_street, \n                            u.seller_address_number, \n                            u.seller_address_neighborhood, \n                            CONCAT_WS('/', u.seller_address_city, u.seller_address_state)\n                        )\n                    ) as seller_address\n                FROM marketplace_listings l\n                JOIN users u ON l.seller_id = u.id\n                WHERE l.id = $1\n            `, [id]);\n\n            if (listingRes.rows.length === 0) return c.json({ success: false, message: 'An√∫ncio n√£o encontrado' }, 404);\n            const listing = listingRes.rows[0];\n\n            // Buscar imagens\n            const imagesRes = await pool.query(\n                'SELECT image_url, id FROM marketplace_listing_images WHERE listing_id = $1 ORDER BY display_order ASC',\n                [id]\n            );\n\n            // Buscar variantes\n            const variantsRes = await pool.query(\n                'SELECT id, name, color, size, stock, price FROM marketplace_listing_variants WHERE listing_id = $1 ORDER BY id ASC',\n                [id]\n            );\n\n            return c.json({\n                success: true,\n                data: {\n                    ...listing,\n                    images: imagesRes.rows.map(r => r.image_url),\n                    variants: variantsRes.rows\n                }\n            });\n\n        } catch (error) {\n            console.error('Error fetching details:', error);\n            return c.json({ success: false, message: 'Erro ao buscar detalhes' }, 500);\n        }\n    }\n\n\n    /**\n     * Criar novo an√∫ncio\n     */\n    static async createListing(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const parseResult = createListingSchema.safeParse(body);\n\n            if (!parseResult.success) {\n                return c.json({\n                    success: false,\n                    message: 'Dados inv√°lidos',\n                    errors: parseResult.error.errors\n                }, 400);\n            }\n\n            const {\n                title, description, price, category, imageUrl, images, variants,\n                itemType, digitalContent, requiredVehicle, stock, pickupAddress, postalCode,\n                weightGrams, freeShipping, shippingPrice, pickupLat, pickupLng\n            } = parseResult.data;\n\n            // ... (digital check kept)\n            if (itemType === 'DIGITAL' && !digitalContent) {\n                return c.json({\n                    success: false,\n                    message: 'Itens digitais precisam de um link ou c√≥digo para entrega autom√°tica.'\n                }, 400);\n            }\n\n            // Atualizar GPS do vendedor\n            const { city, state, neighborhood, postalCode: bodyPostalCode, houseNumber, contactPhone } = body;\n            if (city && state) {\n                await pool.query(\n                    'UPDATE users SET seller_address_city = $1, seller_address_state = $2, seller_address_neighborhood = $3, seller_address_postal_code = $4 WHERE id = $5',\n                    [city, state, neighborhood || null, bodyPostalCode || postalCode || null, user.id]\n                );\n            }\n\n            // Compor endere√ßo de coleta completo (Rua + N√∫mero + Bairro + Cidade/UF)\n            let finalPickupAddress = pickupAddress;\n            if (!finalPickupAddress && neighborhood) {\n                const addressParts = [neighborhood];\n                if (houseNumber) addressParts.push(`N¬∫ ${houseNumber}`);\n                if (city) addressParts.push(`${city}/${state || 'PA'}`);\n                finalPickupAddress = addressParts.join(', ');\n            }\n\n            // Salvar telefone de contato do vendedor se informado\n            if (contactPhone) {\n                await pool.query(\n                    'UPDATE users SET phone = COALESCE(phone, $1), seller_phone = $1 WHERE id = $2',\n                    [contactPhone, user.id]\n                );\n            }\n\n            // Transaction\n            const client = await pool.connect();\n            try {\n                await client.query('BEGIN');\n\n                // 1. Insert Main Listing\n                // Se variants exist, 'stock' can be sum of variants or just the fallback. \n                // We keep it as is, frontend sends total.\n                const mainImage = imageUrl || (images && images.length > 0 ? images[0] : null);\n\n                const result = await client.query(\n                    `INSERT INTO marketplace_listings (\n                        seller_id, title, description, price, category, image_url, \n                        item_type, digital_content, required_vehicle, stock, pickup_address, pickup_postal_code,\n                        weight_grams, free_shipping, shipping_price, is_food, estimated_prep_time_minutes,\n                        pickup_lat, pickup_lng, seller_phone\n                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20) RETURNING id, *`,\n                    [\n                        user.id, title, description, price, category, mainImage,\n                        itemType, digitalContent || null, requiredVehicle, stock || 1, finalPickupAddress || null, postalCode || null,\n                        weightGrams, freeShipping, shippingPrice, parseResult.data.isFood, parseResult.data.estimatedPrepTimeMinutes,\n                        pickupLat || null, pickupLng || null, contactPhone || null\n                    ]\n                );\n                const listing = result.rows[0];\n                const listingId = listing.id;\n\n                // 2. Insert Images (Gallery)\n                if (images && images.length > 0) {\n                    // Start loop from 0, or 1 if index 0 is used as main? \n                    // Let's insert ALL into gallery for completeness.\n                    let order = 0;\n                    for (const img of images) {\n                        await client.query(\n                            'INSERT INTO marketplace_listing_images (listing_id, image_url, display_order) VALUES ($1, $2, $3)',\n                            [listingId, img, order++]\n                        );\n                    }\n                } else if (imageUrl) {\n                    // Backward compatibility: insert main image into gallery too\n                    await client.query(\n                        'INSERT INTO marketplace_listing_images (listing_id, image_url, display_order) VALUES ($1, $2, 0)',\n                        [listingId, imageUrl]\n                    );\n                }\n\n                // 3. Insert Variants\n                if (variants && variants.length > 0) {\n                    for (const v of variants) {\n                        await client.query(\n                            `INSERT INTO marketplace_listing_variants (listing_id, name, color, size, stock, price) \n                             VALUES ($1, $2, $3, $4, $5, $6)`,\n                            [listingId, v.name || `${v.color || ''} ${v.size || ''}`.trim(), v.color || null, v.size || null, v.stock, v.price || null]\n                        );\n                    }\n                }\n\n                await client.query('COMMIT');\n\n                return c.json({\n                    success: true,\n                    data: listing,\n                    message: 'An√∫ncio publicado com sucesso!'\n                });\n\n            } catch (e) {\n                await client.query('ROLLBACK');\n                throw e;\n            } finally {\n                client.release();\n            }\n\n        } catch (error) {\n            console.error('Erro ao criar an√∫ncio:', error);\n            return c.json({ success: false, message: 'Erro ao publicar an√∫ncio' }, 500);\n        }\n    }\n\n    /**\n     * Meus an√∫ncios\n     */\n    static async getMyListings(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT id, title, description, price, category, image_url, status, is_boosted, created_at, required_vehicle, stock, pickup_address\n         FROM marketplace_listings\n         WHERE seller_id = $1\n         ORDER BY created_at DESC`,\n                [user.id]\n            );\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error) {\n            console.error('My Listings Error:', error);\n            return c.json({ success: false, message: 'Erro ao buscar seus an√∫ncios' }, 500);\n        }\n    }\n\n    /**\n     * Deletar an√∫ncio\n     */\n    static async deleteListing(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const listingId = c.req.param('id');\n\n            const result = await pool.query(\n                \"DELETE FROM marketplace_listings WHERE id = $1 AND seller_id = $2 AND status = 'ACTIVE' RETURNING id\",\n                [listingId, user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'An√∫ncio n√£o encontrado ou n√£o pode ser removido.' }, 404);\n            }\n\n            return c.json({ success: true, message: 'An√∫ncio removido com sucesso!' });\n        } catch (error) {\n            console.error('Delete Listing Error:', error);\n            return c.json({ success: false, message: 'Erro ao remover an√∫ncio' }, 500);\n        }\n    }\n\n    /**\n     * Impulsionar um an√∫ncio (Monetiza√ß√£o)\n     */\n    static async boostListing(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const { listingId, paymentMethod = 'BALANCE' } = body;\n            const BOOST_FEE = 5.00; // R$ 5,00 para impulsionar por 7 dias\n\n            // 1. Buscar an√∫ncio\n            const listingRes = await pool.query(\n                'SELECT * FROM marketplace_listings WHERE id = $1 AND seller_id = $2 AND status = $3',\n                [listingId, user.id, 'ACTIVE']\n            );\n            if (listingRes.rows.length === 0) return c.json({ success: false, message: 'An√∫ncio n√£o encontrado ou inv√°lido' }, 404);\n            const listing = listingRes.rows[0];\n\n            // PAGAMENTO VIA SALDO\n            if (paymentMethod === 'BALANCE') {\n                const result = await executeInTransaction(pool, async (client: any) => {\n                    const balanceCheck = await lockUserBalance(client, user.id, BOOST_FEE, { skipLockCheck: true });\n                    if (!balanceCheck.success) throw new Error('Saldo insuficiente para impulsionar');\n\n                    await updateUserBalance(client, user.id, BOOST_FEE, 'debit');\n\n                    const expiresAt = new Date();\n                    expiresAt.setDate(expiresAt.getDate() + 7);\n\n                    await client.query(\n                        'UPDATE marketplace_listings SET is_boosted = TRUE, boost_expires_at = $1 WHERE id = $2',\n                        [expiresAt, listingId]\n                    );\n\n                    const taxPart = BOOST_FEE * 0.25;\n                    const operPart = BOOST_FEE * 0.25;\n                    const ownerPart = BOOST_FEE * 0.25;\n                    const investPart = BOOST_FEE * 0.25;\n\n                    await client.query(\n                        `UPDATE system_config SET \n                            total_tax_reserve = total_tax_reserve + $1,\n                            total_operational_reserve = total_operational_reserve + $2,\n                            total_owner_profit = total_owner_profit + $3,\n                            investment_reserve = investment_reserve + $4,\n                            profit_pool = profit_pool + $5`,\n                        [taxPart, operPart, ownerPart, investPart, 0]\n                    );\n\n                    await createTransaction(\n                        client,\n                        user.id,\n                        'MARKET_BOOST',\n                        BOOST_FEE,\n                        `Impulsionamento de An√∫ncio: ${listing.title}`,\n                        'APPROVED',\n                        { listingId, useBalance: true }\n                    );\n\n                    return { success: true };\n                });\n\n                if (!result.success) return c.json({ success: false, message: result.error }, 400);\n                return c.json({ success: true, message: 'Seu an√∫ncio foi impulsionado!' });\n            }\n\n            // PAGAMENTO EXTERNO (PIX/CART√ÉO) - Temporariamente desativado\n            return c.json({\n                success: false,\n                message: 'Pagamentos PIX/Cart√£o externos est√£o temporariamente indispon√≠veis. Por favor, deposite saldo na sua conta e use o saldo para impulsionar.'\n            }, 400);\n\n        } catch (error: any) {\n            console.error('Error boosting listing:', error);\n            return c.json({ success: false, message: error.message || 'Erro ao impulsionar an√∫ncio' }, 500);\n        }\n    }\n\n    /**\n     * Obter contato do vendedor (consome pontos de farm)\n     */\n    static async getSellerContact(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const listingId = c.req.param('listingId');\n\n            // Buscar an√∫ncio e dados do vendedor\n            const result = await pool.query(`\n                SELECT \n                    l.id, l.title, l.price, l.description, l.image_url, l.seller_id,\n                    COALESCE(u.seller_company_name, u.name) as seller_name, \n                    COALESCE(u.phone, u.pix_key) as seller_phone, \n                    COALESCE(\n                        u.address,\n                        CONCAT_WS(', ', \n                            u.seller_address_street, \n                            u.seller_address_number, \n                            u.seller_address_neighborhood, \n                            CONCAT_WS('/', u.seller_address_city, u.seller_address_state)\n                        )\n                    ) as seller_address,\n                    u.is_verified as seller_verified,\n                    l.stock,\n                    COALESCE(l.pickup_address, CONCAT_WS(', ', \n                        u.seller_address_neighborhood, \n                        u.seller_address_city, \n                        u.seller_address_state\n                    )) as pickup_address\n                FROM marketplace_listings l\n                JOIN users u ON l.seller_id = u.id\n                WHERE l.id = $1 AND l.status = 'ACTIVE'\n            `, [listingId]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'An√∫ncio n√£o encontrado ou j√° vendido.' }, 404);\n            }\n\n            const listing = result.rows[0];\n\n            // N√£o pode contatar a si mesmo\n            if (listing.seller_id === user.id) {\n                return c.json({ success: false, message: 'Este √© seu pr√≥prio an√∫ncio.' }, 400);\n            }\n\n            // --- L√ìGICA DE CONSUMO DE PONTOS (FARM) ---\n            // Verificamos se o usu√°rio j√° desbloqueou este contato antes para n√£o cobrar duas vezes\n            const alreadyContacted = await pool.query(\n                'SELECT 1 FROM marketplace_contacts WHERE listing_id = $1 AND buyer_id = $2',\n                [listingId, user.id]\n            );\n\n            const POINT_COST = 3;\n\n            if (alreadyContacted.rows.length === 0) {\n                // Verificar se tem pontos suficientes (ad_points)\n                const userPointsRes = await pool.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n                const currentPoints = userPointsRes.rows[0]?.ad_points || 0;\n\n                if (currentPoints < POINT_COST) {\n                    return c.json({\n                        success: false,\n                        message: `Saldo insuficiente. Voc√™ precisa de ${POINT_COST} pontos de farm para ver o contato. Fa√ßa check-in di√°rio ou assista v√≠deos para ganhar mais!`,\n                        data: { currentPoints, required: POINT_COST }\n                    }, 403);\n                }\n\n                // Deduzir pontos\n                await pool.query(\n                    'UPDATE users SET ad_points = ad_points - $1 WHERE id = $2',\n                    [POINT_COST, user.id]\n                );\n\n                // Registrar interesse (para n√£o cobrar novamente e analytics)\n                await pool.query(\n                    'INSERT INTO marketplace_contacts (listing_id, buyer_id, points_spent, created_at) VALUES ($1, $2, $3, NOW()) ON CONFLICT DO NOTHING',\n                    [listingId, user.id, POINT_COST]\n                ).catch(() => {\n                    // Caso a coluna points_spent n√£o exista ainda, tentamos sem ela\n                    pool.query('INSERT INTO marketplace_contacts (listing_id, buyer_id, created_at) VALUES ($1, $2, NOW()) ON CONFLICT DO NOTHING', [listingId, user.id]);\n                });\n            }\n\n            // Formatar telefone para link do WhatsApp\n            const phoneClean = listing.seller_phone?.replace(/\\D/g, '') || '';\n            const whatsappLink = phoneClean ? `https://wa.me/55${phoneClean}?text=Ol√°! Vi seu an√∫ncio \"${listing.title}\" no Cred30 por R$ ${parseFloat(listing.price).toFixed(2)}. Ainda est√° dispon√≠vel?` : null;\n\n            return c.json({\n                success: true,\n                data: {\n                    listing: {\n                        id: listing.id,\n                        title: listing.title,\n                        price: parseFloat(listing.price),\n                        description: listing.description,\n                        image: listing.image_url\n                    },\n                    seller: {\n                        name: listing.seller_name,\n                        phone: listing.seller_phone,\n                        address: listing.seller_address,\n                        isVerified: listing.seller_verified || false\n                    },\n                    whatsapp: whatsappLink,\n                    disclaimer: '‚ö†Ô∏è Esta √© uma negocia√ß√£o P2P direta. A Cred30 n√£o intermedia esta transa√ß√£o e n√£o oferece garantias. Combine pagamento e entrega diretamente com o vendedor.'\n                }\n            });\n        } catch (error) {\n            console.error('Contact Route Error:', error);\n            return c.json({ success: false, message: 'Erro ao obter contato' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/marketplace.orders.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MARKET_CREDIT_INTEREST_RATE' is defined but never used.","line":12,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":32,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"MARKET_CREDIT_INTEREST_RATE"},"fix":{"range":[692,725],"text":""},"desc":"Remove unused variable \"MARKET_CREDIT_INTEREST_RATE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MARKET_CREDIT_MAX_INSTALLMENTS' is defined but never used.","line":13,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":35,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"MARKET_CREDIT_MAX_INSTALLMENTS"},"fix":{"range":[725,761],"text":""},"desc":"Remove unused variable \"MARKET_CREDIT_MAX_INSTALLMENTS\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'QUOTA_FEE_TAX_SHARE' is defined but never used.","line":16,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"QUOTA_FEE_TAX_SHARE"},"fix":{"range":[820,845],"text":""},"desc":"Remove unused variable \"QUOTA_FEE_TAX_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'QUOTA_FEE_OPERATIONAL_SHARE' is defined but never used.","line":17,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":32,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"QUOTA_FEE_OPERATIONAL_SHARE"},"fix":{"range":[845,878],"text":""},"desc":"Remove unused variable \"QUOTA_FEE_OPERATIONAL_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'QUOTA_FEE_OWNER_SHARE' is defined but never used.","line":18,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":26,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"QUOTA_FEE_OWNER_SHARE"},"fix":{"range":[878,905],"text":""},"desc":"Remove unused variable \"QUOTA_FEE_OWNER_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'QUOTA_FEE_INVESTMENT_SHARE' is defined but never used.","line":19,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"QUOTA_FEE_INVESTMENT_SHARE"},"fix":{"range":[905,937],"text":""},"desc":"Remove unused variable \"QUOTA_FEE_INVESTMENT_SHARE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'calculateLoanOffer' is defined but never used.","line":32,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"calculateLoanOffer"},"fix":{"range":[1306,1325],"text":""},"desc":"Remove unused variable \"calculateLoanOffer\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCreditAnalysis' is defined but never used.","line":33,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getCreditAnalysis"},"fix":{"range":[1324,1347],"text":""},"desc":"Remove unused variable \"getCreditAnalysis\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5876,5879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5876,5879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8369,8372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8369,8372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9314,9317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9314,9317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12561,12564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12561,12564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'finalPickupAddress' is never reassigned. Use 'const' instead.","line":285,"column":21,"nodeType":"Identifier","messageId":"useConst","endLine":285,"endColumn":39,"fix":{"range":[13857,13972],"text":"const finalPickupAddress = pickupAddress || listings[0].pickup_address || 'Endere√ßo informado pelo vendedor no chat';"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14083,14086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14083,14086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19680,19683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19680,19683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":422,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22838,22841],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22838,22841],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":427,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":427,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23060,23063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23060,23063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":455,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25487,25490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25487,25490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":456,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25570,25573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25570,25573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":506,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":506,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29033,29036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29033,29036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":534,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":534,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30236,30239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30236,30239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":566,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":566,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31667,31670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31667,31670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":635,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":635,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35453,35456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35453,35456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":650,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":650,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36398,36401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36398,36401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":706,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":706,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39537,39540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39537,39540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":755,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41978,41981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41978,41981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sellerRes' is assigned a value but never used.","line":782,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":782,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":846,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":846,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47889,47892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47889,47892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'installmentAmount' is assigned a value but never used.","line":881,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":881,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":889,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":889,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50639,50642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50639,50642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":894,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":894,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50845,50848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50845,50848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":925,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":925,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53116,53119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53116,53119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":925,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":925,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53150,53153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53150,53153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":926,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":926,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53221,53224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53221,53224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":926,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":926,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53255,53258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53255,53258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":927,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":927,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53326,53329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53326,53329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":927,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":927,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53373,53376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53373,53376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":994,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":994,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[57248,57251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[57248,57251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1004,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1004,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[57804,57807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[57804,57807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1228,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1228,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[67607,67610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[67607,67610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":1410,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1410,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":1446,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1446,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":1477,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1477,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1515,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1515,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[81911,81914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[81911,81914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1582,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1582,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[84576,84579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[84576,84579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1593,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1593,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[84893,84896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[84893,84896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1618,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1618,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[85946,85949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[85946,85949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":46,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { calculateShippingQuote } from '../../../shared/utils/logistics.utils';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, lockUserBalance, updateUserBalance, createTransaction, lockSystemConfig } from '../../../domain/services/transaction.service';\nimport { updateScore } from '../../../application/services/score.service';\nimport { notificationService } from '../../../application/services/notification.service';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport {\n    MARKETPLACE_ESCROW_FEE_RATE,\n    MARKETPLACE_NON_VERIFIED_FEE_RATE,\n    MARKET_CREDIT_INTEREST_RATE,\n    MARKET_CREDIT_MAX_INSTALLMENTS,\n    MARKET_CREDIT_MIN_SCORE,\n    MARKET_CREDIT_MIN_QUOTAS,\n    QUOTA_FEE_TAX_SHARE,\n    QUOTA_FEE_OPERATIONAL_SHARE,\n    QUOTA_FEE_OWNER_SHARE,\n    QUOTA_FEE_INVESTMENT_SHARE,\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE,\n    PLATFORM_FEE_CORPORATE_SHARE,\n    DELIVERY_MIN_FEES,\n    LOAN_GFC_FEE_RATE,\n    SELLER_MONTHLY_LIMIT_CPF,\n    SELLER_MONTHLY_LIMIT_MEI,\n    SELLER_MONTHLY_LIMIT_CNPJ\n} from '../../../shared/constants/business.constants';\nimport {\n    calculateLoanOffer,\n    getCreditAnalysis,\n    calculateUserLoanLimit,\n    calculateMonthlyInterestRate\n} from '../../../application/services/credit-analysis.service';\nimport { getWelcomeBenefit, consumeWelcomeBenefitUse } from '../../../application/services/welcome-benefit.service';\n\n// Schemas\nconst buyListingSchema = z.object({\n    listingId: z.any().optional(), // Aceita UUID ou Inteiro (SERIAL)\n    listingIds: z.array(z.any()).optional(), // Novo campo para m√∫ltiplos itens\n    selectedVariantId: z.number().optional(), // ID da variante (NOVO)\n    deliveryAddress: z.string().min(3),\n    contactPhone: z.string(),\n    offlineToken: z.string().optional(),\n    payerCpfCnpj: z.string().optional(),\n    deliveryType: z.enum(['SELF_PICKUP', 'COURIER_REQUEST', 'EXTERNAL_SHIPPING']).optional().default('SELF_PICKUP'),\n    offeredDeliveryFee: z.coerce.number().min(0).optional().default(0),\n    pickupAddress: z.string().optional(),\n    invitedCourierId: z.string().uuid().optional().or(z.literal('')),\n    paymentMethod: z.enum(['BALANCE', 'PIX', 'CARD']).default('BALANCE'),\n    quantity: z.coerce.number().int().min(1).optional().default(1),\n    deliveryLat: z.coerce.number().optional(),\n    deliveryLng: z.coerce.number().optional(),\n    pickupLat: z.coerce.number().optional(),\n    pickupLng: z.coerce.number().optional(),\n    creditCard: z.object({\n        holderName: z.string(),\n        number: z.string(),\n        expiryMonth: z.string(),\n        expiryYear: z.string(),\n        ccv: z.string(),\n        cpf: z.string(),\n    }).optional(),\n    selectedOptions: z.array(z.object({\n        name: z.string(),\n        price: z.number()\n    })).optional().default([]),\n}).refine(data => {\n    if (data.deliveryType !== 'SELF_PICKUP' && !/\\d/.test(data.deliveryAddress)) {\n        return false;\n    }\n    return true;\n}, {\n    message: \"O endere√ßo deve incluir o n√∫mero da casa/local para entregas.\",\n    path: ['deliveryAddress']\n});\n\nconst buyOnCreditSchema = z.object({\n    listingId: z.any().optional(), // Aceita UUID ou Inteiro (SERIAL)\n    listingIds: z.array(z.any()).optional(), // Novo campo para m√∫ltiplos itens\n    selectedVariantId: z.number().optional(), // ID da variante (NOVO)\n    installments: z.number().int().min(1).max(24),\n    deliveryAddress: z.string().min(3),\n    contactPhone: z.string(),\n    deliveryType: z.enum(['SELF_PICKUP', 'COURIER_REQUEST', 'EXTERNAL_SHIPPING']).optional().default('SELF_PICKUP'),\n    offeredDeliveryFee: z.coerce.number().min(0).optional().default(0),\n    pickupAddress: z.string().optional(),\n    invitedCourierId: z.string().uuid().optional().or(z.literal('')),\n    quantity: z.coerce.number().int().min(1).optional().default(1),\n    deliveryLat: z.coerce.number().optional(),\n    deliveryLng: z.coerce.number().optional(),\n    pickupLat: z.coerce.number().optional(),\n    pickupLng: z.coerce.number().optional(),\n    selectedOptions: z.array(z.object({\n        name: z.string(),\n        price: z.number()\n    })).optional().default([]),\n}).refine(data => {\n    if (data.deliveryType !== 'SELF_PICKUP' && !/\\d/.test(data.deliveryAddress)) {\n        return false;\n    }\n    return true;\n}, {\n    message: \"O endere√ßo deve incluir o n√∫mero da casa/local para entregas.\",\n    path: ['deliveryAddress']\n});\n\nexport class MarketplaceOrdersController {\n\n    /**\n     * Comprar an√∫ncio com saldo\n     */\n    static async buyListing(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = buyListingSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({\n                    success: false,\n                    message: parseResult.error.errors[0]?.message || 'Dados inv√°lidos.'\n                }, 400);\n            }\n\n            const {\n                paymentMethod, deliveryType, offeredDeliveryFee, invitedCourierId,\n                deliveryLat, deliveryLng, pickupLat, pickupLng, pickupAddress, selectedOptions,\n                listingId, listingIds, quantity, selectedVariantId, deliveryAddress, contactPhone, offlineToken\n            } = parseResult.data;\n\n            const idsToProcess = listingIds || (listingId ? [listingId] : []);\n            if (idsToProcess.length === 0) return c.json({ success: false, message: 'Nenhum item selecionado.' }, 400);\n\n            // Iniciar transa√ß√£o no in√≠cio para garantir consist√™ncia de leitura do estoque\n            const result = await executeInTransaction(pool, async (client: any) => {\n                const buyerRes = await client.query('SELECT is_verified FROM users WHERE id = $1', [user.id]);\n                const buyerData = buyerRes.rows[0];\n\n                const listingsResult = await client.query('SELECT *, COALESCE(stock, 1) as current_stock, required_vehicle FROM marketplace_listings WHERE id = ANY($1) AND status = $2 FOR UPDATE', [idsToProcess, 'ACTIVE']);\n\n                if (listingsResult.rows.length === 0) throw new Error('Itens indispon√≠veis ou n√£o encontrados.');\n\n                const listings = listingsResult.rows;\n                const sellerId = listings[0].seller_id;\n                const finalQuantity = quantity || 1;\n\n                // ==================================================\n                // VERIFICA√á√ÉO DE LIMITE MENSAL DE VENDAS (COMPLIANCE FISCAL)\n                // CPF: R$ 2.000/m√™s | MEI: R$ 6.750/m√™s | Outros: Sem limite\n                // ==================================================\n                const sellerInfoRes = await client.query(\n                    `SELECT seller_cpf_cnpj, seller_company_type, is_verified FROM users WHERE id = $1`,\n                    [sellerId]\n                );\n                const sellerInfo = sellerInfoRes.rows[0];\n\n                // Calcular vendas do m√™s atual do vendedor\n                const monthlySalesRes = await client.query(`\n                    SELECT COALESCE(SUM(total_price), 0)::numeric as total_sales\n                    FROM marketplace_orders\n                    WHERE seller_id = $1\n                    AND status NOT IN ('CANCELLED', 'REFUNDED')\n                    AND created_at >= DATE_TRUNC('month', CURRENT_TIMESTAMP)\n                `, [sellerId]);\n\n                const currentMonthlySales = parseFloat(monthlySalesRes.rows[0]?.total_sales || 0);\n\n                // Determinar limite baseado no tipo de empresa\n                const companyType = sellerInfo?.seller_company_type || 'INDIVIDUAL';\n                let monthlyLimit = SELLER_MONTHLY_LIMIT_CPF; // Default: CPF = R$ 2.000\n\n                if (companyType === 'MEI') {\n                    monthlyLimit = SELLER_MONTHLY_LIMIT_MEI; // MEI = R$ 6.750 (81k/ano)\n                } else if (['ME', 'LTDA', 'SA', 'EIRELI'].includes(companyType)) {\n                    monthlyLimit = SELLER_MONTHLY_LIMIT_CNPJ; // 0 = Sem limite\n                }\n\n                // Calcular quanto seria o total ap√≥s esta venda\n                const saleTotal = listings.reduce((sum: number, l: any) => sum + parseFloat(l.price) * finalQuantity, 0);\n                const projectedTotal = currentMonthlySales + saleTotal;\n\n                // Verificar se ultrapassaria o limite (0 = sem limite)\n                if (monthlyLimit > 0 && projectedTotal > monthlyLimit) {\n                    const remaining = Math.max(0, monthlyLimit - currentMonthlySales);\n                    const companyTypeName = companyType === 'INDIVIDUAL' ? 'CPF' : companyType;\n                    throw new Error(\n                        `O vendedor atingiu o limite mensal de vendas para ${companyTypeName} (R$ ${monthlyLimit.toFixed(2)}). ` +\n                        `Vendas este m√™s: R$ ${currentMonthlySales.toFixed(2)}. ` +\n                        `Dispon√≠vel: R$ ${remaining.toFixed(2)}.`\n                    );\n                }\n\n                // VALIDAR HOR√ÅRIO DE FUNCIONAMENTO (Se for comida/delivery)\n                const isAnyFood = listings.some((l: any) => l.is_food);\n                if (isAnyFood) {\n                    const sellerDataRes = await client.query('SELECT opening_hours, is_restaurant, is_liquor_store, is_paused FROM users WHERE id = $1', [sellerId]);\n                    const sellerRow = sellerDataRes.rows[0];\n\n                    if (sellerRow && sellerRow.is_paused) {\n                        throw new Error('Este estabelecimento est√° temporariamente fechado para novos pedidos.');\n                    }\n\n                    if (sellerRow && sellerRow.opening_hours) {\n                        const now = new Date();\n                        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n                        const currentDay = dayNames[now.getDay()];\n                        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();\n\n                        const hours = sellerRow.opening_hours[currentDay];\n                        if (!hours || !hours.open || !hours.close) {\n                            throw new Error('Este estabelecimento est√° fechado hoje.');\n                        }\n\n                        const [openH, openM] = hours.open.split(':').map(Number);\n                        const [closeH, closeM] = hours.close.split(':').map(Number);\n                        const openMin = openH * 60 + openM;\n                        const closeMin = closeH * 60 + closeM;\n\n                        let isOpen = false;\n                        if (closeMin < openMin) { // Caso vire a noite (ex: 18:00 √†s 02:00)\n                            isOpen = currentTimeMinutes >= openMin || currentTimeMinutes <= closeMin;\n                        } else {\n                            isOpen = currentTimeMinutes >= openMin && currentTimeMinutes <= closeMin;\n                        }\n\n                        if (!isOpen) {\n                            throw new Error(`Este estabelecimento est√° fechado no momento. Abre √†s ${hours.open} e fecha √†s ${hours.close}.`);\n                        }\n                    }\n                }\n\n                // Check Variants\n                let variantPrice = null;\n                if (selectedVariantId) {\n                    const variantRes = await client.query('SELECT * FROM marketplace_listing_variants WHERE id = $1 AND listing_id = $2 FOR UPDATE', [selectedVariantId, listings[0].id]);\n                    if (variantRes.rows.length === 0) throw new Error('Varia√ß√£o n√£o encontrada.');\n\n                    const variant = variantRes.rows[0];\n                    if (variant.stock < quantity) {\n                        throw new Error(`Estoque da varia√ß√£o insuficiente: ${variant.stock} dispon√≠veis.`);\n                    }\n                    if (variant.price) variantPrice = parseFloat(variant.price);\n                } else {\n                    // Validar Estoque Geral se n√£o for variante\n                    if (listings.length === 1 && listings[0].current_stock < quantity) {\n                        throw new Error(`Quantidade solicitada (${quantity}) excede o estoque dispon√≠vel (${listings[0].current_stock}).`);\n                    }\n                }\n\n                // Validar se todos s√£o do mesmo vendedor\n                if (listings.some((l: any) => l.seller_id !== sellerId)) {\n                    throw new Error('Todos os itens de um lote devem ser do mesmo vendedor.');\n                }\n\n\n\n                /* REMOVED\n                    const startOfMonth = new Date();\n                    startOfMonth.setDate(1);\n                    startOfMonth.setHours(0, 0, 0, 0);\n \n                    const salesRes = await client.query(`\n                        SELECT COALESCE(SUM(amount), 0) as total \n                        FROM marketplace_orders \n                        WHERE seller_id = $1 \n                        AND created_at >= $2 \n                        AND status != 'CANCELLED'\n                    `, [sellerId, startOfMonth]);\n \n                    const currentMonthlySales = parseFloat(salesRes.rows[0].total);\n \n \n                */\n                // --------------------------------------------------\n\n                const sellerRes = await client.query('SELECT address, asaas_wallet_id, is_verified_seller, seller_cpf_cnpj FROM users WHERE id = $1', [sellerId]);\n                const sellerData = sellerRes.rows[0];\n                const isVerified = !!sellerData?.is_verified_seller; // Agora baseado no Selo\n\n                // Usar pickup_address do an√∫ncio se for retirada e o vendedor informou\n                let finalPickupAddress = pickupAddress || listings[0].pickup_address || 'Endere√ßo informado pelo vendedor no chat';\n\n                // C√°lculos Agregados\n                const baseAmount = listings.reduce((acc: number, item: any) => {\n                    let price = parseFloat(item.price);\n                    if (selectedVariantId && variantPrice) price = variantPrice;\n                    return acc + (price * (listings.length === 1 ? quantity : 1));\n                }, 0);\n\n                // NOTA: Verifica√ß√£o de limite mensal foi movida para o in√≠cio da transa√ß√£o (linhas 151-195)\n                // --------------------------------------------------\n\n                // Somar opcionais (SE FOR COMIDA)\n                let optionsTotal = 0;\n                if (isAnyFood && selectedOptions && selectedOptions.length > 0) {\n                    optionsTotal = selectedOptions.reduce((acc, opt) => acc + (Number(opt.price) || 0), 0);\n                }\n                const totalPrice = baseAmount + optionsTotal;\n                let maxVehicleRank = -1;\n                const vehicleRank: Record<string, number> = { 'BIKE': 0, 'MOTO': 1, 'CAR': 2, 'TRUCK': 3 };\n                let requiredVehicle = 'MOTO';\n                let containsDigital = false;\n\n                for (const l of listings) {\n                    const vRank = vehicleRank[l.required_vehicle || 'MOTO'] || 1;\n                    if (vRank > maxVehicleRank) {\n                        maxVehicleRank = vRank;\n                        requiredVehicle = l.required_vehicle || 'MOTO';\n                    }\n                    if (l.item_type === 'DIGITAL') containsDigital = true;\n                }\n\n                const minFee = DELIVERY_MIN_FEES[requiredVehicle] || 5.00;\n\n                // --- C√ÅLCULO DE FRETE DIN√ÇMICO (NOVO) ---\n                let calculatedDeliveryFee = offeredDeliveryFee;\n                if (deliveryType === 'COURIER_REQUEST') {\n                    if (deliveryLat && deliveryLng && pickupLat && pickupLng) {\n                        // Haversine no Backend para C√°lculo de Frete\n                        const R = 6371; // km\n                        const dLat = (deliveryLat - pickupLat) * Math.PI / 180;\n                        const dLon = (deliveryLng - pickupLng) * Math.PI / 180;\n                        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                            Math.cos(pickupLat * Math.PI / 180) * Math.cos(deliveryLat * Math.PI / 180) *\n                            Math.sin(dLon / 2) * Math.sin(dLon / 2);\n                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                        const distanceKm = R * c;\n\n                        // --- TRAVA DE SEGURAN√áA GEOGR√ÅFICA ---\n                        const isBike = requiredVehicle === 'BIKE';\n                        const MAX_COURIER_DISTANCE = isBike ? 7 : 60;\n                        if (distanceKm > MAX_COURIER_DISTANCE) {\n                            throw new Error(`Dist√¢ncia de ${distanceKm.toFixed(1)}km excede o limite para ${isBike ? 'Bike' : 'entregadores'} (M√°x: ${MAX_COURIER_DISTANCE}km).`);\n                        }\n\n                        // Verificar se √© interestadual (se tivermos os dados de endere√ßo)\n                        const sellerLocation = await client.query('SELECT seller_address_state FROM users WHERE id = $1', [sellerId]);\n                        const sellerState = sellerLocation.rows[0]?.seller_address_state;\n\n                        // O comprador pode enviar as coordenadas mas o estado pode ser inferido pelo endere√ßo\n                        // Para simplificar, focamos na dist√¢ncia primeiro, mas se o estado for informado no body:\n                        const destState = (body.deliveryAddress || '').split(',').pop()?.trim().toUpperCase();\n                        if (sellerState && destState && destState.length === 2 && sellerState !== destState) {\n                            throw new Error(`Entregadores parceiros n√£o realizam viagens entre estados (${sellerState} -> ${destState}).`);\n                        }\n\n                        // Pegar pre√ßo por KM (Bike R$ 1,50 / Outros R$ 2,50)\n                        const configRes = await client.query('SELECT courier_price_per_km FROM system_config LIMIT 1');\n                        const basePriceKm = parseFloat(configRes.rows[0]?.courier_price_per_km || '2.50');\n                        const effectiveKmPrice = isBike ? 1.50 : basePriceKm;\n\n                        // F√ìRMULA: Base + (Dist√¢ncia * Km)\n                        calculatedDeliveryFee = (minFee + (distanceKm * effectiveKmPrice)) * 1.275;\n                        console.log(`[LOGISTICS] ${requiredVehicle} | Dist√¢ncia: ${distanceKm.toFixed(2)}km | Frete: R$ ${calculatedDeliveryFee.toFixed(2)}`);\n                    } else {\n                        calculatedDeliveryFee = Math.max(minFee, offeredDeliveryFee);\n                    }\n                } else if (deliveryType === 'EXTERNAL_SHIPPING') {\n                    // --- C√ÅLCULO SEDEX BLINDADO ---\n                    const listing = listings[0];\n                    let originCep = listing.pickup_postal_code;\n                    if (!originCep) {\n                        const sellerRes = await client.query('SELECT seller_address_postal_code, seller_address_cep FROM users WHERE id = $1', [sellerId]);\n                        originCep = sellerRes.rows[0]?.seller_address_cep || sellerRes.rows[0]?.seller_address_postal_code || '00000000';\n                    }\n\n                    // Extrair CEP do endere√ßo de destino (√∫ltimos d√≠gitos)\n                    const destCepMatch = (deliveryAddress || '').match(/\\d{5}-?\\d{3}/);\n                    const destCep = destCepMatch ? destCepMatch[0] : '00000000';\n\n                    const totalWeight = listings.reduce((acc: number, l: any) => acc + (l.weight_grams || 1000), 0);\n                    const quote = calculateShippingQuote(originCep, destCep, totalWeight, listing.free_shipping);\n\n                    // Se o vendedor definiu um frete fixo no an√∫ncio e n√£o for gr√°tis\n                    if (listing.shipping_price > 0 && !listing.free_shipping) {\n                        calculatedDeliveryFee = parseFloat(listing.shipping_price);\n                    } else {\n                        calculatedDeliveryFee = quote.fee;\n                    }\n                    console.log(`[EXTERNAL_LOGISTICS] ${originCep} -> ${destCep} | Peso: ${totalWeight}g | Frete: R$ ${calculatedDeliveryFee}`);\n                }\n\n                const isDigitalLote = containsDigital && listings.length === 1;\n                const baseAmountToCharge = isDigitalLote ? totalPrice : totalPrice + calculatedDeliveryFee;\n\n                // Se o pagamento for via saldo\n                if (paymentMethod === 'BALANCE') {\n                    // Determinar taxa base (Verificado vs N√£o Verificado)\n                    // isVerified j√° foi calculado no in√≠cio da transa√ß√£o baseado no Selo\n                    const baseFeeRate = isVerified ? MARKETPLACE_ESCROW_FEE_RATE : MARKETPLACE_NON_VERIFIED_FEE_RATE;\n\n                    // ===== SISTEMA DE BENEF√çCIO DE BOAS-VINDAS =====\n                    const welcomeBenefit = await getWelcomeBenefit(client, user.id);\n                    // Se o comprador tem benef√≠cio, aplica taxa especial do marketplace\n                    const effectiveEscrowRate = welcomeBenefit.hasDiscount ? welcomeBenefit.marketplaceEscrowFeeRate : baseFeeRate;\n\n                    console.log(`[MARKETPLACE] ${isDigitalLote ? 'DIGITAL' : 'F√çSICO'} | Vendedor ${isVerified ? 'VERIFICADO' : 'N√ÉO VERIFICADO'}. Comprador ${user.id} - Benef√≠cio: ${welcomeBenefit.hasDiscount ? 'ATIVO' : 'INATIVO'}, Taxa Escrow Final: ${(effectiveEscrowRate * 100).toFixed(1)}%`);\n\n                    const fee = totalPrice * effectiveEscrowRate;\n                    const sellerAmount = totalPrice - fee;\n\n\n                    console.log(`[DEBUG_BUY] baseAmount: ${baseAmount}, optionsTotal: ${optionsTotal}, deliveryFee: ${calculatedDeliveryFee}, totalToCharge: ${baseAmountToCharge}`);\n                    const balanceCheck = await lockUserBalance(client, user.id, baseAmountToCharge, { skipLockCheck: true });\n                    if (!balanceCheck.success) {\n                        console.error(`[DEBUG_BUY] Falha no saldo: ${balanceCheck.error}. Requisitado: ${baseAmountToCharge}, Dispon√≠vel: ${balanceCheck.currentBalance}`);\n                        throw new Error(balanceCheck.error || 'Saldo insuficiente.');\n                    }\n\n\n                    await updateUserBalance(client, user.id, baseAmountToCharge, 'debit');\n\n                    // --- REGRAS DE DELIVERY DE COMIDA ---\n                    // Itens digitais s√£o completados instantaneamente\n                    let orderStatus = isDigitalLote ? 'COMPLETED' : 'WAITING_SHIPPING';\n\n                    // Se for comida, status inicial √© PREPARING (Cozinha preparando)\n                    if (!isDigitalLote && listings.some((l: any) => l.is_food)) {\n                        orderStatus = 'PREPARING';\n                    }\n\n                    // --- TRAVA DE BEBIDAS ALCO√ìLICAS (+18 / KYC) ---\n                    const isLiquor = listings.some((l: any) => l.category === 'Bebidas' || l.category === 'Bebidas Alco√≥licas');\n                    if (isLiquor && !buyerData?.is_verified) {\n                        throw new Error('Voc√™ precisa ter o Selo de Verifica√ß√£o (KYC) aprovado para comprar bebidas alco√≥licas.');\n                    }\n\n                    const deliveryStatus = isDigitalLote ? 'DELIVERED' : (deliveryType === 'COURIER_REQUEST' ? 'AVAILABLE' : 'NONE');\n                    const pickupCode = Math.random().toString(36).substring(2, 8).toUpperCase();\n\n                    console.log(`[MARKETPLACE_BUY] Inserindo pedido: listing_id=${listings[0].id}, buyer=${user.id}, seller=${sellerId}, invitedCourier=${invitedCourierId || 'null'}`);\n\n                    const orderResult = await client.query(\n                        `INSERT INTO marketplace_orders (\n                            listing_id, listing_ids, is_lote, buyer_id, seller_id, amount, fee_amount, seller_amount, \n                            status, payment_method, delivery_address, pickup_address, contact_phone, \n                            offline_token, delivery_status, delivery_fee, pickup_code, delivery_confirmation_code, invited_courier_id,\n                            pickup_lat, pickup_lng, delivery_lat, delivery_lng, quantity, variant_id, selected_options\n                        ) VALUES (\n                            $1::INTEGER, $2::INTEGER[], $3::BOOLEAN, $4::INTEGER, $5::INTEGER, $6::NUMERIC, $7::NUMERIC, $8::NUMERIC,\n                            $9, $10, $11, $12, $13,\n                            $14, $15, $16::NUMERIC, $17, $18, $19,\n                            $20::NUMERIC, $21::NUMERIC, $22::NUMERIC, $23::NUMERIC, $24::INTEGER, $25::INTEGER, $26::JSONB\n                        ) RETURNING id`,\n                        [\n                            listings[0].id, idsToProcess, listings.length > 1, user.id, sellerId, totalPrice, fee, sellerAmount,\n                            orderStatus, 'BALANCE', deliveryAddress, isDigitalLote ? null : finalPickupAddress, contactPhone,\n                            offlineToken, deliveryStatus, isDigitalLote ? 0 : calculatedDeliveryFee, pickupCode, pickupCode,\n                            (invitedCourierId && invitedCourierId.length > 30) ? invitedCourierId : null,\n                            // Se n√£o houver coordenadas enviadas, tentar pegar as que est√£o no an√∫ncio\n                            pickupLat || (listings[0] as any)?.pickup_lat || null,\n                            pickupLng || (listings[0] as any)?.pickup_lng || null,\n                            deliveryLat || null, deliveryLng || null,\n                            quantity, selectedVariantId || null, JSON.stringify(selectedOptions)\n                        ]\n                    );\n                    const orderId = orderResult.rows[0].id;\n                    console.log(`[DEBUG_BUY] Pedido criado: ${orderId} `);\n\n                    // Se usou benef√≠cio, consumir um uso\n                    if (welcomeBenefit.hasDiscount) {\n                        await consumeWelcomeBenefitUse(client, user.id, 'MARKETPLACE');\n                    }\n\n                    await updateUserBalance(client, sellerId, sellerAmount, 'credit');\n                    await createTransaction(client, sellerId, 'MARKET_SALE', sellerAmount, `Venda Digital: ${listings[0].title} `, 'APPROVED', { orderId });\n\n                    // RESERVAR ESTOQUE AGORA (F√çSICO)\n                    if (!isDigitalLote) {\n                        // RESERVAR ESTOQUE AGORA (F√çSICO)\n                        if (selectedVariantId) {\n                            await client.query('UPDATE marketplace_listing_variants SET stock = GREATEST(0, stock - $1) WHERE id = $2', [quantity, selectedVariantId]);\n                        }\n                        // Sempre decrementar estoque principal\n                        for (const l of listings) {\n                            await client.query('UPDATE marketplace_listings SET stock = GREATEST(0, stock - $1) WHERE id = $2', [quantity, l.id]);\n                            await client.query(\"UPDATE marketplace_listings SET status = 'PAUSED' WHERE id = $1 AND stock <= 0\", [l.id]);\n                        }\n                    }\n\n                    // ADICIONAR TAXA AO PROFIT POOL DO CLUBE\n                    if (fee > 0) {\n                        await client.query('UPDATE system_config SET profit_pool = profit_pool + $1', [fee]);\n                    }\n\n                    await createTransaction(client, user.id, 'MARKET_PURCHASE', totalPrice, `Compra${isDigitalLote ? ' Digital' : ''}: ${listings.length > 1 ? `Lote (${listings.length} itens)` : listings[0].title}${welcomeBenefit.hasDiscount ? ' (üéÅ Taxa reduzida)' : ''} `, 'APPROVED', { orderId, listingId: listings[0].id, welcomeBenefitApplied: welcomeBenefit.hasDiscount, isDigital: isDigitalLote, useBalance: true });\n\n                    return { orderId, sellerId, welcomeBenefitApplied: welcomeBenefit.hasDiscount, usesRemaining: welcomeBenefit.hasDiscount ? welcomeBenefit.usesRemaining - 1 : 0, isDigitalItem: isDigitalLote, digitalContent: isDigitalLote ? listings[0].digital_content : null };\n                }\n\n                // Pagamento Externo (PIX ou CART√ÉO)\n                throw new Error('Pagamentos PIX/Cart√£o externos est√£o temporariamente indispon√≠veis. Por favor, deposite saldo na sua conta e use o saldo para comprar.');\n            });\n\n            if (!result.success && !result.data) { // executeInTransaction retorna success true se nao throw error\n                // mas se o operation retornar algo, ele vem em result.data\n                // Se o operation falhar com throw, cai no catch do executeInTransaction e retorna success: false\n                if (result.success === false) return c.json({ success: false, message: result.error || 'Erro ao processar pedido' }, 400);\n            }\n\n            // O result.data cont√©m o retorno da fun√ß√£o executada\n            const data = (result.data || {}) as any;\n\n            let successMessage = data.isDigitalItem ? 'Compra realizada! O conte√∫do digital est√° dispon√≠vel em Seus Pedidos.' : 'Compra realizada! Aguarde o envio/retirada.';\n            if (data.welcomeBenefitApplied) {\n                successMessage += ` üéÅ Taxa de base aplicada(Benef√≠cio de Boas - Vindas).Usos restantes: ${data.usesRemaining}/3`;\n            }\n\n            // Notificar VENDEDOR sobre a nova venda (antes de retornar)\n            if (data.orderId && data.sellerId) {\n                notificationService.notifyUser(\n                    data.sellerId,\n                    'üõí Nova Venda!',\n                    `Voc√™ tem uma nova venda aguardando envio/retirada.`\n                ).catch(() => { });\n            }\n\n            return c.json({\n                success: true,\n                message: successMessage,\n                data: {\n                    orderId: data.orderId,\n                    welcomeBenefitApplied: data.welcomeBenefitApplied,\n                    usesRemaining: data.usesRemaining,\n                    digitalContent: data.digitalContent,\n                    isDigitalLote: data.isDigitalItem\n                }\n            });\n\n        } catch (error: any) {\n            console.error('Buy Route Error:', error);\n            // Se o erro vier do executeInTransaction (que j√° captura e retorna success:false), n√£o chegaria aqui se usarmos o result\n            // Mas se for erro fora da transa√ß√£o ou de parsing\n            return c.json({ success: false, message: error.message || 'Erro ao processar compra' }, 500);\n        }\n    }\n\n\n    /**\n     * Comprar no Credi√°rio\n     */\n    static async buyOnCredit(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = buyOnCreditSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({\n                    success: false,\n                    message: parseResult.error.errors[0]?.message || 'Dados inv√°lidos.'\n                }, 400);\n            }\n\n            const { listingId, listingIds, selectedVariantId, installments, deliveryAddress, contactPhone, invitedCourierId, quantity, pickupAddress, selectedOptions } = parseResult.data;\n\n            const idsToProcess = listingIds || (listingId ? [listingId] : []);\n            if (idsToProcess.length === 0) return c.json({ success: false, message: 'Nenhum item selecionado.' }, 400);\n\n            // Transa√ß√£o √önica e At√¥mica\n            const result = await executeInTransaction(pool, async (client: any) => {\n                // 1. Lock e Busca Listings - SERIALIZA√á√ÉO DO ESTOQUE\n                const listingsResult = await client.query('SELECT *, COALESCE(stock, 1) as current_stock, required_vehicle FROM marketplace_listings WHERE id = ANY($1) AND status = $2 FOR UPDATE', [idsToProcess, 'ACTIVE']);\n\n                if (listingsResult.rows.length === 0) throw new Error('Itens indispon√≠veis ou n√£o encontrados.');\n\n                const listings = listingsResult.rows;\n                const sellerId = listings[0].seller_id;\n                const finalQuantity = quantity || 1;\n\n                // ==================================================\n                // RESTRI√á√ÉO DE CREDI√ÅRIO: COTAS + KYC OBRIGAT√ìRIOS\n                // Usu√°rio precisa ter cotas ativas E ser verificado\n                // ==================================================\n                const buyerDataRes = await client.query(\n                    'SELECT is_verified FROM users WHERE id = $1',\n                    [user.id]\n                );\n                const buyerData = buyerDataRes.rows[0];\n\n                // Verificar se usu√°rio √© verificado (KYC)\n                if (!buyerData?.is_verified) {\n                    throw new Error('Voc√™ precisa completar a verifica√ß√£o de identidade (KYC) para comprar no credi√°rio. Acesse Configura√ß√µes > Verifica√ß√£o.');\n                }\n\n                // Verificar se usu√°rio tem cotas ativas\n                const quotasRes = await client.query(\n                    'SELECT COUNT(*) as total FROM quotas WHERE user_id = $1 AND status = $2',\n                    [user.id, 'ACTIVE']\n                );\n                const userQuotas = parseInt(quotasRes.rows[0].total);\n\n                if (userQuotas < MARKET_CREDIT_MIN_QUOTAS) {\n                    throw new Error(`Voc√™ precisa ter pelo menos ${MARKET_CREDIT_MIN_QUOTAS} cota(s) ativa(s) para comprar no credi√°rio. Adquira cotas para liberar o cr√©dito.`);\n                }\n\n                // ==================================================\n                // VERIFICA√á√ÉO DE LIMITE MENSAL DE VENDAS (COMPLIANCE FISCAL)\n                // CPF: R$ 2.000/m√™s | MEI: R$ 6.750/m√™s | Outros: Sem limite\n\n                // ==================================================\n                const sellerInfoRes = await client.query(\n                    `SELECT seller_cpf_cnpj, seller_company_type, is_verified FROM users WHERE id = $1`,\n                    [sellerId]\n                );\n                const sellerInfo = sellerInfoRes.rows[0];\n\n                // Calcular vendas do m√™s atual do vendedor\n                const monthlySalesRes = await client.query(`\n                    SELECT COALESCE(SUM(total_price), 0)::numeric as total_sales\n                    FROM marketplace_orders\n                    WHERE seller_id = $1\n                    AND status NOT IN ('CANCELLED', 'REFUNDED')\n                    AND created_at >= DATE_TRUNC('month', CURRENT_TIMESTAMP)\n                `, [sellerId]);\n\n                const currentMonthlySales = parseFloat(monthlySalesRes.rows[0]?.total_sales || 0);\n\n                // Determinar limite baseado no tipo de empresa\n                const companyType = sellerInfo?.seller_company_type || 'INDIVIDUAL';\n                let monthlyLimit = SELLER_MONTHLY_LIMIT_CPF; // Default: CPF = R$ 2.000\n\n                if (companyType === 'MEI') {\n                    monthlyLimit = SELLER_MONTHLY_LIMIT_MEI; // MEI = R$ 6.750 (81k/ano)\n                } else if (['ME', 'LTDA', 'SA', 'EIRELI'].includes(companyType)) {\n                    monthlyLimit = SELLER_MONTHLY_LIMIT_CNPJ; // 0 = Sem limite\n                }\n\n                // Calcular quanto seria o total ap√≥s esta venda\n                const saleTotal = listings.reduce((sum: number, l: any) => sum + parseFloat(l.price) * finalQuantity, 0);\n                const projectedTotal = currentMonthlySales + saleTotal;\n\n                // Verificar se ultrapassaria o limite (0 = sem limite)\n                if (monthlyLimit > 0 && projectedTotal > monthlyLimit) {\n                    const remaining = Math.max(0, monthlyLimit - currentMonthlySales);\n                    const companyTypeName = companyType === 'INDIVIDUAL' ? 'CPF' : companyType;\n                    throw new Error(\n                        `O vendedor atingiu o limite mensal de vendas para ${companyTypeName} (R$ ${monthlyLimit.toFixed(2)}). ` +\n                        `Vendas este m√™s: R$ ${currentMonthlySales.toFixed(2)}. ` +\n                        `Dispon√≠vel: R$ ${remaining.toFixed(2)}.`\n                    );\n                }\n\n                // VALIDAR HOR√ÅRIO DE FUNCIONAMENTO (Se for comida/delivery)\n                const isAnyFood = listings.some((l: any) => l.is_food);\n                if (isAnyFood) {\n                    const sellerDataRes = await client.query('SELECT opening_hours, is_restaurant, is_liquor_store, is_paused FROM users WHERE id = $1', [sellerId]);\n                    const sellerRow = sellerDataRes.rows[0];\n\n                    if (sellerRow && sellerRow.is_paused) {\n                        throw new Error('Este estabelecimento est√° temporariamente fechado para novos pedidos.');\n                    }\n\n                    if (sellerRow && sellerRow.opening_hours) {\n                        const now = new Date();\n                        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n                        const currentDay = dayNames[now.getDay()];\n                        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();\n\n                        const hours = sellerRow.opening_hours[currentDay];\n                        if (!hours || !hours.open || !hours.close) {\n                            throw new Error('Este estabelecimento est√° fechado hoje.');\n                        }\n\n                        const [openH, openM] = hours.open.split(':').map(Number);\n                        const [closeH, closeM] = hours.close.split(':').map(Number);\n                        const openMin = openH * 60 + openM;\n                        const closeMin = closeH * 60 + closeM;\n\n                        let isOpen = false;\n                        if (closeMin < openMin) {\n                            isOpen = currentTimeMinutes >= openMin || currentTimeMinutes <= closeMin;\n                        } else {\n                            isOpen = currentTimeMinutes >= openMin && currentTimeMinutes <= closeMin;\n                        }\n\n                        if (!isOpen) {\n                            throw new Error(`Este estabelecimento est√° fechado no momento. Abre √†s ${hours.open} e fecha √†s ${hours.close}.`);\n                        }\n                    }\n                }\n\n                // 2. Check Variants com Lock\n                let variantPrice = null;\n                if (selectedVariantId) {\n                    const variantRes = await client.query('SELECT * FROM marketplace_listing_variants WHERE id = $1 AND listing_id = $2 FOR UPDATE', [selectedVariantId, listings[0].id]);\n                    if (variantRes.rows.length === 0) throw new Error('Varia√ß√£o n√£o encontrada.');\n\n                    const variant = variantRes.rows[0];\n                    if (variant.stock < quantity) {\n                        throw new Error(`Estoque da varia√ß√£o insuficiente: ${variant.stock} dispon√≠veis.`);\n                    }\n                    if (variant.price) variantPrice = parseFloat(variant.price);\n                } else {\n                    // Validar Estoque Geral\n                    if (listings.length === 1 && listings[0].current_stock < quantity) {\n                        throw new Error(`Quantidade solicitada (${quantity}) excede o estoque dispon√≠vel (${listings[0].current_stock}).`);\n                    }\n                }\n\n                if (listings.some((l: any) => l.seller_id !== sellerId)) {\n                    throw new Error('Todos os itens de um lote devem ser do mesmo vendedor.');\n                }\n                if (sellerId === user.id) throw new Error('Voc√™ n√£o pode comprar de si mesmo.');\n\n\n\n                /* REMOVED\n                    const startOfMonth = new Date();\n                    startOfMonth.setDate(1);\n                    startOfMonth.setHours(0, 0, 0, 0);\n    \n                    const salesRes = await client.query(`\n                        SELECT COALESCE(SUM(amount), 0) as total \n                        FROM marketplace_orders \n                        WHERE seller_id = $1 \n                        AND created_at >= $2 \n                        AND status != 'CANCELLED'\n                    `, [sellerId, startOfMonth]);\n    \n                    const currentMonthlySales = parseFloat(salesRes.rows[0].total);\n    \n                */\n                // --------------------------------------------------\n\n                // 3. Valida√ß√µes de Score e Cotas do Usu√°rio\n                const userResult = await client.query(`\n                    SELECT u.score, COUNT(q.id) as quota_count, u.is_verified, u.cpf, u.pix_key \n                    FROM users u \n                    LEFT JOIN quotas q ON q.user_id = u.id AND q.status = 'ACTIVE'\n                    WHERE u.id = $1\n                    GROUP BY u.id\n                `, [user.id]);\n\n                const userStats = userResult.rows[0];\n                const userScore = userStats?.score || 0;\n                const quotaCount = parseInt(userStats?.quota_count || '0');\n\n                if (userScore < MARKET_CREDIT_MIN_SCORE) throw new Error(`Score insuficiente (${userScore}). M√≠nimo: ${MARKET_CREDIT_MIN_SCORE}.`);\n                if (quotaCount < MARKET_CREDIT_MIN_QUOTAS) throw new Error(`Voc√™ precisa ter ao menos ${MARKET_CREDIT_MIN_QUOTAS} cota ativa para comprar parcelado.`);\n\n                if (!userStats?.is_verified || !userStats?.cpf || !userStats?.pix_key) {\n                    throw new Error('Para comprar parcelado, voc√™ precisa completar a verifica√ß√£o do seu perfil (CPF, PIX e Telefone).');\n                }\n\n                // 4. Limite de Cr√©dito UNIFICADO (Subtrai d√≠vida ativa automaticamente)\n                const availableLimit = await calculateUserLoanLimit(pool, user.id);\n\n                // C√°lculos\n                const baseAmount = listings.reduce((acc: number, item: any) => {\n                    let price = parseFloat(item.price);\n                    if (selectedVariantId && variantPrice) price = variantPrice;\n                    return acc + (price * (listings.length === 1 ? quantity : 1));\n                }, 0);\n\n                // Somar opcionais (SE FOR COMIDA - CREDIT)\n                let optionsTotal = 0;\n                // No buyOnCredit, selectedOptions tamb√©m deve vir do body.\n                // Vou adicionar ao desestrutura√ß√£o do body no buyOnCredit tamb√©m.\n                if (isAnyFood && selectedOptions && selectedOptions.length > 0) {\n                    optionsTotal = selectedOptions.reduce((acc, opt) => acc + (Number(opt.price) || 0), 0);\n                }\n\n                const totalPrice = baseAmount + optionsTotal;\n\n                // NOTA: Verifica√ß√£o de limite mensal foi movida para o in√≠cio da transa√ß√£o (linhas 604-648)\n\n                // Buscar dados do vendedor para verifica√ß√£o de selo\n                const sellerFullRes = await client.query('SELECT address, asaas_wallet_id, is_verified_seller, seller_cpf_cnpj FROM users WHERE id = $1', [sellerId]);\n                const sellerFullData = sellerFullRes.rows[0];\n                const isVerified = !!sellerFullData?.is_verified_seller;\n                // --------------------------------------------------\n\n                if (totalPrice > availableLimit) throw new Error(`O valor do lote (R$ ${totalPrice.toFixed(2)}) excede seu limite de cr√©dito (R$ ${availableLimit.toFixed(2)}).`);\n\n                // Buscar Vendedor\n                const sellerRes = await client.query('SELECT address, asaas_wallet_id FROM users WHERE id = $1', [sellerId]);\n                const finalPickupAddress = pickupAddress || listings[0].pickup_address || 'Endere√ßo informado pelo vendedor no chat';\n\n                // Log√≠stica\n                let maxVehicleRank = -1;\n                const vehicleRank: Record<string, number> = { 'BIKE': 0, 'MOTO': 1, 'CAR': 2, 'TRUCK': 3 };\n                let requiredVehicle = 'MOTO';\n                for (const l of listings) {\n                    const vRank = vehicleRank[l.required_vehicle || 'MOTO'] || 1;\n                    if (vRank > maxVehicleRank) {\n                        maxVehicleRank = vRank;\n                        requiredVehicle = l.required_vehicle || 'MOTO';\n                    }\n                }\n\n                const minFee = DELIVERY_MIN_FEES[requiredVehicle] || 5.00;\n                let calculatedDeliveryFee = parseResult.data.offeredDeliveryFee;\n                if (parseResult.data.deliveryType === 'COURIER_REQUEST') {\n                    const { deliveryLat, deliveryLng, pickupLat, pickupLng } = body;\n                    if (deliveryLat && deliveryLng && pickupLat && pickupLng) {\n                        const R = 6371;\n                        const dLat = (deliveryLat - pickupLat) * Math.PI / 180;\n                        const dLon = (deliveryLng - pickupLng) * Math.PI / 180;\n                        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(pickupLat * Math.PI / 180) * Math.cos(deliveryLat * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                        const distanceKm = R * c;\n\n                        // --- TRAVA DE SEGURAN√áA GEOGR√ÅFICA ---\n                        const isBike = requiredVehicle === 'BIKE';\n                        const MAX_COURIER_DISTANCE = isBike ? 7 : 60;\n                        if (distanceKm > MAX_COURIER_DISTANCE) {\n                            throw new Error(`Dist√¢ncia de ${distanceKm.toFixed(1)}km excede o limite para ${isBike ? 'Bike' : 'entregadores'} (M√°x: ${MAX_COURIER_DISTANCE}km).`);\n                        }\n\n                        // Verificar Interestadual\n                        const sellerLocation = await client.query('SELECT seller_address_state FROM users WHERE id = $1', [sellerId]);\n                        const sellerState = sellerLocation.rows[0]?.seller_address_state;\n                        const destState = (deliveryAddress || '').split(',').pop()?.trim().toUpperCase();\n\n                        if (sellerState && destState && destState.length === 2 && sellerState !== destState) {\n                            throw new Error(`Entregadores parceiros n√£o realizam viagens entre estados (${sellerState} -> ${destState}).`);\n                        }\n\n                        const configRes = await client.query('SELECT courier_price_per_km FROM system_config LIMIT 1');\n                        const basePriceKm = parseFloat(configRes.rows[0]?.courier_price_per_km || '2.50');\n                        const effectiveKmPrice = isBike ? 1.50 : basePriceKm;\n\n                        // F√ìRMULA: Base + (Dist√¢ncia * Km)\n                        calculatedDeliveryFee = (minFee + (distanceKm * effectiveKmPrice)) * 1.275;\n                    } else {\n                        calculatedDeliveryFee = Math.max(minFee, calculatedDeliveryFee);\n                    }\n                } else if (parseResult.data.deliveryType === 'EXTERNAL_SHIPPING') {\n                    // --- C√ÅLCULO SEDEX BLINDADO (CREDIT) ---\n                    const listing = listings[0];\n                    let originCep = listing.pickup_postal_code;\n                    if (!originCep) {\n                        const sellerRes = await client.query('SELECT seller_address_postal_code, seller_address_cep FROM users WHERE id = $1', [sellerId]);\n                        originCep = sellerRes.rows[0]?.seller_address_cep || sellerRes.rows[0]?.seller_address_postal_code || '00000000';\n                    }\n\n                    const destCepMatch = (parseResult.data.deliveryAddress || '').match(/\\d{5}-?\\d{3}/);\n                    const destCep = destCepMatch ? destCepMatch[0] : '00000000';\n\n                    const totalWeight = listings.reduce((acc: number, l: any) => acc + (l.weight_grams || 1000), 0);\n                    const quote = calculateShippingQuote(originCep, destCep, totalWeight, listing.free_shipping);\n\n                    if (listing.shipping_price > 0 && !listing.free_shipping) {\n                        calculatedDeliveryFee = parseFloat(listing.shipping_price);\n                    } else {\n                        calculatedDeliveryFee = quote.fee;\n                    }\n                    console.log(`[EXTERNAL_LOGISTICS_CREDIT] ${originCep} -> ${destCep} | Peso: ${totalWeight}g | Frete: R$ ${calculatedDeliveryFee}`);\n                }\n\n                const fee = calculatedDeliveryFee;\n                // isVerified calculado no in√≠cio (baseado no Selo)\n                const baseFeeRate = isVerified ? MARKETPLACE_ESCROW_FEE_RATE : MARKETPLACE_NON_VERIFIED_FEE_RATE;\n\n                const welcomeBenefit = await getWelcomeBenefit(pool, user.id);\n                const effectiveEscrowRate = welcomeBenefit.hasDiscount ? welcomeBenefit.marketplaceEscrowFeeRate : baseFeeRate;\n                const escrowFee = totalPrice * effectiveEscrowRate;\n                const sellerAmount = totalPrice - escrowFee;\n\n                // C√ÅLCULO DE JUROS UNIFICADO (Baseado na Garantia - Marketplace assume 100%)\n                const monthlyRate = calculateMonthlyInterestRate(100);\n                const interestAmount = totalPrice * monthlyRate * installments;\n                // const totalToPay = totalPrice + interestAmount; // Errado na logica original? totalToPay deve ser principal + juros. Sim.\n                // Mas wait, o fee de entrega entra no financiamento?\n                // Na implementa√ß√£o anterior: totalWithFee = totalToPay + fee.\n                // Sim, financia entrega tamb√©m?\n                // L√≥gica anterior: amount no INSERT era totalWithFee.\n                // No loans table: amount = totalPrice + fee. total_payable = totalWithFee.\n\n                // FGC: Taxa de Prote√ß√£o de Cr√©dito (2% sobre o valor financiado)\n                const principalFinanciado = totalPrice + fee;\n                const gfcFee = principalFinanciado * LOAN_GFC_FEE_RATE;\n                const totalWithFee = totalPrice + interestAmount + fee + gfcFee; // Principal + Juros + Entrega + FGC\n\n                const installmentAmount = totalWithFee / installments;\n\n                // 5. Verificar Saldo do Sistema (Lock)\n                const systemConfig = await lockSystemConfig(client);\n                if (parseFloat(systemConfig.system_balance) < totalPrice) throw new Error('Limite di√°rio de financiamento do sistema atingido.');\n\n                // --- REGRAS DE DELIVERY DE COMIDA ---\n                let orderStatus = 'WAITING_SHIPPING';\n                if (listings.some((l: any) => l.is_food)) {\n                    orderStatus = 'PREPARING';\n                }\n\n                // --- TRAVA DE BEBIDAS ALCO√ìLICAS (+18 / KYC) ---\n                const isLiquor = listings.some((l: any) => l.category === 'Bebidas' || l.category === 'Bebidas Alco√≥licas');\n                if (isLiquor && !userStats?.is_verified) {\n                    throw new Error('Voc√™ precisa ter o Selo de Verifica√ß√£o (KYC) aprovado para comprar bebidas alco√≥licas.');\n                }\n\n                const deliveryStatus = (parseResult.data.deliveryType === 'COURIER_REQUEST' ? 'AVAILABLE' : 'NONE');\n                const pickupCode = Math.random().toString(36).substring(2, 8).toUpperCase();\n\n                // ADICIONAR TAXA DE ESCROW AO PROFIT POOL DO CLUBE\n                if (escrowFee > 0) {\n                    await client.query('UPDATE system_config SET profit_pool = profit_pool + $1', [escrowFee]);\n                }\n\n                console.log(`[MARKETPLACE_CREDIT] Inserindo pedido: listing_id=${listings[0].id}, buyer=${user.id}`);\n\n                const orderResult = await client.query(\n                    `INSERT INTO marketplace_orders (\n                        listing_id, listing_ids, is_lote, buyer_id, seller_id, amount, fee_amount, seller_amount, \n                        status, payment_method, delivery_address, pickup_address, contact_phone, \n                        delivery_status, delivery_fee, pickup_code, delivery_confirmation_code, invited_courier_id,\n                        pickup_lat, pickup_lng, delivery_lat, delivery_lng, quantity, variant_id, selected_options\n                    ) VALUES (\n                        $1::INTEGER, $2::INTEGER[], $3::BOOLEAN, $4::INTEGER, $5::INTEGER, $6::NUMERIC, $7::NUMERIC, $8::NUMERIC,\n                        $9, $10, $11, $12, $13,\n                        $14, $15, $16, $17, $18::UUID,\n                        $19::NUMERIC, $20::NUMERIC, $21::NUMERIC, $22::NUMERIC, $23::INTEGER, $24::INTEGER, $25::JSONB\n                    ) RETURNING id`,\n                    [\n                        listings[0].id, idsToProcess, listings.length > 1, user.id, sellerId, totalWithFee, escrowFee, sellerAmount,\n                        orderStatus, 'CRED30_CREDIT', deliveryAddress, finalPickupAddress, contactPhone,\n                        deliveryStatus, fee, pickupCode, pickupCode, (invitedCourierId && invitedCourierId.length > 30) ? invitedCourierId : null,\n                        (parseResult.data as any).pickupLat || (listings[0] as any)?.pickup_lat || null,\n                        (parseResult.data as any).pickupLng || (listings[0] as any)?.pickup_lng || null,\n                        (parseResult.data as any).deliveryLat || null, (parseResult.data as any).deliveryLng || null,\n                        quantity, selectedVariantId || null, JSON.stringify(selectedOptions || [])\n                    ]\n                );\n                const orderId = orderResult.rows[0].id;\n\n                // Criar Contrato de Cr√©dito (Empr√©stimo)\n                const loanResult = await client.query(\n                    `INSERT INTO loans (user_id, amount, total_repayment, total_paid, installments, interest_rate, status, metadata)\n                     VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`,\n                    [user.id, principalFinanciado, totalWithFee, 0, installments, monthlyRate, 'APPROVED', JSON.stringify({ orderId, sellerId, gfcFee, type: 'MARKETPLACE_PURCHASE' })]\n                );\n                const loanId = loanResult.rows[0].id;\n\n                // === CAPITALIZA√á√ÉO DO FGC (Fundo de Garantia de Cr√©dito) ===\n                if (gfcFee > 0) {\n                    await client.query(\n                        'UPDATE system_config SET credit_guarantee_fund = COALESCE(credit_guarantee_fund, 0) + $1',\n                        [gfcFee]\n                    );\n                    console.log(`[FGC-MARKETPLACE] Fundo capitalizado com R$ ${gfcFee.toFixed(2)} para credi√°rio do pedido ${orderId}`);\n                }\n\n                // Gerar Parcelas\n                const standardMarketplaceInstallment = Math.floor((totalWithFee / installments) * 100) / 100;\n                let remainingMarketplaceTotal = totalWithFee;\n\n                for (let i = 1; i <= installments; i++) {\n                    const dueDate = new Date();\n                    dueDate.setMonth(dueDate.getMonth() + i);\n\n                    const currentMarketplaceInstallmentAmount = (i === installments)\n                        ? Math.round(remainingMarketplaceTotal * 100) / 100\n                        : standardMarketplaceInstallment;\n\n                    await client.query(\n                        `INSERT INTO loan_installments (loan_id, installment_number, amount, expected_amount, due_date, status)\n                         VALUES ($1, $2, $3, $3, $4, $5)`,\n                        [loanId, i, currentMarketplaceInstallmentAmount, dueDate, 'PENDING']\n                    );\n\n                    remainingMarketplaceTotal -= currentMarketplaceInstallmentAmount;\n                }\n\n                await createTransaction(client, user.id, 'MARKET_CREDIT_PURCHASE', totalPrice + fee, `Compra Parcelada (${installments}x): ${listings.length > 1 ? `Lote (${listings.length} itens)` : listings[0].title}`, 'APPROVED', { orderId, loanId, useBalance: true });\n\n                if (welcomeBenefit.hasDiscount) {\n                    await consumeWelcomeBenefitUse(client, user.id, 'MARKETPLACE');\n                }\n\n                // DECREMENTAR ESTOQUE (J√° dentro da transa√ß√£o e lockado)\n                if (selectedVariantId) {\n                    await client.query('UPDATE marketplace_listing_variants SET stock = GREATEST(0, stock - $1) WHERE id = $2', [quantity, selectedVariantId]);\n                }\n                for (const l of listings) {\n                    await client.query('UPDATE marketplace_listings SET stock = GREATEST(0, stock - $1) WHERE id = $2', [quantity, l.id]);\n                    // Se estoque zerar, pausar\n                    await client.query(\"UPDATE marketplace_listings SET status = 'PAUSED' WHERE id = $1 AND stock <= 0\", [l.id]);\n                }\n\n                return { orderId, loanId, welcomeBenefitApplied: welcomeBenefit.hasDiscount, usesRemaining: welcomeBenefit.hasDiscount ? welcomeBenefit.usesRemaining - 1 : 0 };\n            });\n\n            if (!result.success && !result.data) {\n                if (result.success === false) return c.json({ success: false, message: result.error || 'Erro ao processar pedido' }, 400);\n            }\n\n            const data = (result.data || {}) as any;\n\n            let successMessage = 'Financiamento Aprovado!';\n            if (data.welcomeBenefitApplied) {\n                successMessage += ` üéÅ Taxa de ${(0.0).toFixed(1)}% aplicada (Benef√≠cio de Boas-Vindas). Usos restantes: ${data.usesRemaining}/3`;\n                // Ops, effectiveEscrowRate n√£o est√° acessivel aqui fora. Mas ok, simplifiquei a msg.\n            }\n\n            return c.json({ success: true, message: successMessage, data: { orderId: data.orderId, welcomeBenefitApplied: data.welcomeBenefitApplied } });\n\n        } catch (error: any) {\n            console.error('Buy Credit Error:', error);\n            return c.json({ success: false, message: error.message || 'Erro ao processar' }, 500);\n        }\n    }\n\n\n    /**\n     * Listar minhas compras e vendas\n     */\n    static async getMyOrders(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const limit = parseInt(c.req.query('limit') || '20');\n            const offset = parseInt(c.req.query('offset') || '0');\n\n            const result = await pool.query(\n                `SELECT o.*, l.title as listing_title, l.image_url as listing_image, \n                  CASE WHEN o.buyer_id = $1 THEN l.digital_content ELSE NULL END as digital_content,\n                  ub.name as buyer_name,\n                  us.name as seller_name,\n                  us.address as seller_address,\n                  COALESCE(us.phone, us.pix_key) as seller_phone,\n                  uc.name as courier_name,\n                  COALESCE(uc.phone, uc.pix_key) as courier_phone,\n                  ln.installments, ln.interest_rate, ln.total_repayment\n           FROM marketplace_orders o\n           JOIN marketplace_listings l ON o.listing_id = l.id\n           JOIN users ub ON o.buyer_id = ub.id\n           JOIN users us ON o.seller_id = us.id\n           LEFT JOIN users uc ON o.courier_id = uc.id\n           LEFT JOIN loans ln ON o.payment_method = 'CRED30_CREDIT' \n                AND ln.metadata->>'orderId' = o.id::text \n                AND ln.user_id = o.buyer_id\n           WHERE o.buyer_id = $1 OR o.seller_id = $1 OR o.courier_id = $1\n           ORDER BY o.created_at DESC\n           LIMIT $2 OFFSET $3`,\n                [user.id, limit, offset]\n            );\n\n            return c.json({\n                success: true,\n                data: {\n                    orders: result.rows,\n                    pagination: { limit, offset }\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao listar pedidos:', error);\n            return c.json({ success: false, message: 'Erro ao buscar seu hist√≥rico' }, 500);\n        }\n    }\n\n    /**\n     * Cancelar Pedido\n     */\n    static async cancelOrder(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n\n            const orderRes = await pool.query(\n                'SELECT * FROM marketplace_orders WHERE id = $1 AND (buyer_id = $2 OR seller_id = $3)',\n                [orderId, user.id, user.id]\n            );\n\n            if (orderRes.rows.length === 0) return c.json({ success: false, message: 'Pedido n√£o encontrado.' }, 404);\n            const order = orderRes.rows[0];\n\n            if (order.status === 'COMPLETED' || order.status === 'CANCELLED') {\n                return c.json({ success: false, message: 'Este pedido n√£o pode mais ser cancelado.' }, 400);\n            }\n\n            const result = await executeInTransaction(pool, async (client) => {\n                await client.query('UPDATE marketplace_orders SET status = $1, updated_at = NOW() WHERE id = $2', ['CANCELLED', orderId]);\n                await client.query('UPDATE marketplace_listings SET status = $1 WHERE id = $2', ['ACTIVE', order.listing_id]);\n\n                if (order.payment_method === 'BALANCE') {\n                    await updateUserBalance(client, order.buyer_id, parseFloat(order.amount), 'credit');\n                    await createTransaction(client, order.buyer_id, 'MARKET_REFUND', parseFloat(order.amount), `Estorno: Pedido #${orderId} cancelado`, 'APPROVED');\n                } else if (order.payment_method === 'CRED30_CREDIT') {\n                    await client.query(\n                        \"UPDATE loans SET status = 'CANCELLED' WHERE status = 'APPROVED' AND metadata->>'orderId' = $1 AND user_id = $2\",\n                        [orderId.toString(), order.buyer_id]\n                    );\n                    await createTransaction(client, order.buyer_id, 'MARKET_REFUND_CREDIT', 0, `Estorno Cr√©dito: Pedido #${orderId} cancelado`, 'APPROVED');\n                }\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n            return c.json({ success: true, message: 'Pedido cancelado e valores estornados com sucesso!' });\n        } catch (error) {\n            console.error('Cancel Order Error:', error);\n            return c.json({ success: false, message: 'Erro ao cancelar pedido' }, 500);\n        }\n    }\n\n    /**\n     * Abrir Disputa\n     */\n    static async openDispute(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const { reason } = await c.req.json();\n\n            if (!reason) return c.json({ success: false, message: 'O motivo da disputa √© obrigat√≥rio.' }, 400);\n\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n         SET status = 'DISPUTE', dispute_reason = $1, disputed_at = NOW(), updated_at = NOW()\n         WHERE id = $2 AND (buyer_id = $3 OR seller_id = $3) AND status IN ('WAITING_SHIPPING', 'IN_TRANSIT', 'DELIVERED')\n         RETURNING *`,\n                [reason, orderId, user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou status n√£o permite disputa.' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: 'Disputa aberta com sucesso. O saldo foi congelado e nossa equipe de suporte ir√° analisar o caso.'\n            });\n        } catch (error) {\n            console.error('Dispute Error:', error);\n            return c.json({ success: false, message: 'Erro ao abrir disputa' }, 500);\n        }\n    }\n\n    /**\n     * Avaliar Parceiro (Score)\n     */\n    static async rateOrder(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n            const { rating, comment } = await c.req.json();\n\n            if (typeof rating !== 'number' || rating < -5 || rating > 5) {\n                return c.json({ success: false, message: 'Nota inv√°lida. Use de -5 a 5.' }, 400);\n            }\n\n            const orderResult = await pool.query(\n                'SELECT * FROM marketplace_orders WHERE id = $1 AND (buyer_id = $2 OR seller_id = $2) AND status = $3',\n                [orderId, user.id, 'COMPLETED']\n            );\n\n            if (orderResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou n√£o finalizado.' }, 404);\n            }\n\n            const order = orderResult.rows[0];\n            const isBuyer = order.buyer_id === user.id;\n            const targetUserId = isBuyer ? order.seller_id : order.buyer_id;\n\n            const existingRating = await pool.query(\n                'SELECT 1 FROM marketplace_ratings WHERE order_id = $1 AND rater_id = $2',\n                [orderId, user.id]\n            );\n            if (existingRating.rows.length > 0) {\n                return c.json({ success: false, message: 'Voc√™ j√° avaliou este pedido.' }, 400);\n            }\n\n            await executeInTransaction(pool, async (client) => {\n                await client.query(\n                    `INSERT INTO marketplace_ratings (order_id, rater_id, rated_user_id, rating, comment, created_at)\n           VALUES ($1, $2, $3, $4, $5, NOW())`,\n                    [orderId, user.id, targetUserId, rating, comment || null]\n                );\n\n                const scoreImpact = rating * 10;\n                const reason = isBuyer ? `Avalia√ß√£o como Vendedor (Pedido #${orderId})` : `Avalia√ß√£o como Comprador (Pedido #${orderId})`;\n                await updateScore(client, targetUserId, scoreImpact, reason);\n\n                return { success: true };\n            });\n\n            return c.json({ success: true, message: 'Avalia√ß√£o registrada com sucesso!' });\n        } catch (error) {\n            console.error('Rate Order Error:', error);\n            return c.json({ success: false, message: 'Erro ao avaliar pedido' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar Recebimento (Finaliza o pedido e libera pagamentos)\n     */\n    static async confirmReceipt(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json().catch(() => ({}));\n            const { verificationCode } = body;\n            const orderId = c.req.param('id');\n\n            // Buscar pedido esperando confirma√ß√£o do comprador\n            // Aceita: WAITING_SHIPPING, IN_TRANSIT, ou quando entregador j√° marcou DELIVERED\n            const orderResult = await pool.query(\n                `SELECT o.*, l.title, l.quota_id FROM marketplace_orders o \n           JOIN marketplace_listings l ON o.listing_id = l.id \n           WHERE o.id = $1 \n           AND (o.status IN ('WAITING_SHIPPING', 'IN_TRANSIT') OR o.delivery_status = 'DELIVERED')\n           AND o.status != 'COMPLETED'\n           AND (\n             o.buyer_id = $2 \n             OR o.pickup_code = $3 \n             OR (o.offline_token IS NOT NULL AND o.offline_token = $3)\n           )`,\n                [orderId, user.id, verificationCode]\n            );\n\n            if (orderResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou j√° finalizado.' }, 404);\n            }\n\n            const order = orderResult.rows[0];\n\n            const result = await executeInTransaction(pool, async (client: any) => {\n                // 1. Finalizar pedido\n                await client.query(\n                    'UPDATE marketplace_orders SET status = $1, delivery_status = $2, updated_at = NOW() WHERE id = $3',\n                    ['COMPLETED', 'DELIVERED', orderId]\n                );\n\n                // 1.0 Baixa de Estoque (REMOVIDO - Agora feito na cria√ß√£o do pedido para reservar)\n                // Mantemos apenas a l√≥gica de transfer√™ncia de Cota se houver\n\n                // 1.1 Se for uma cota, transferir propriedade\n                if (order.quota_id) {\n                    const transferResult = await client.query(\n                        'UPDATE quotas SET user_id = $1 WHERE id = $2 RETURNING id',\n                        [order.buyer_id, order.quota_id]\n                    );\n\n                    if (transferResult.rowCount === 0) {\n                        throw new Error('Falha ao transferir a cota-parte.');\n                    }\n\n                    // Atualizar Score por aquisi√ß√£o\n                    await updateScore(client, order.buyer_id, 50, `Aquisi√ß√£o de cota-parte via mercado secund√°rio #${order.quota_id}`);\n                    await updateScore(client, order.seller_id, 20, `Cess√£o bem-sucedida de cota-parte #${order.quota_id}`);\n                }\n\n                // 2. Liberar saldo para o vendedor (SE AINDA N√ÉO FOI ANTECIPADO)\n                const isAnticipated = order.metadata?.anticipated;\n                const sellerAmount = parseFloat(order.seller_amount);\n                const totalFee = parseFloat(order.fee_amount || '0');\n\n                if (totalFee > 0) {\n                    // DIVIS√ÉO DA TAXA DE VENDA DO MARKETPLACE\n                    // 50% para Cotistas (Profit Pool)\n                    const profitShare = totalFee * 0.5;\n\n                    // 50% para a Empresa (Sistema) dividida em 4 reservas\n                    const systemShare = totalFee * 0.5;\n                    const taxPart = systemShare * PLATFORM_FEE_TAX_SHARE;\n                    const operPart = systemShare * PLATFORM_FEE_OPERATIONAL_SHARE;\n                    const ownerPart = systemShare * PLATFORM_FEE_OWNER_SHARE;\n                    const investPart = systemShare * PLATFORM_FEE_INVESTMENT_SHARE;\n                    const corpPart = systemShare * PLATFORM_FEE_CORPORATE_SHARE;\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            profit_pool = profit_pool + $1,\n                            total_tax_reserve = total_tax_reserve + $2,\n                            total_operational_reserve = total_operational_reserve + $3,\n                            total_owner_profit = total_owner_profit + $4,\n                            investment_reserve = COALESCE(investment_reserve, 0) + $5,\n                            total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6\n                        `, [profitShare, taxPart, operPart, ownerPart, investPart, corpPart]\n                    );\n                }\n\n                if (!isAnticipated) {\n                    // Fluxo Normal: Vendedor recebe no SALDO PENDENTE (Settlement)\n                    // Isso evita que o vendedor saque e suma imediatamente (Risco apontado pelo Josias)\n                    await client.query(\n                        'UPDATE users SET pending_balance = pending_balance + $1 WHERE id = $2',\n                        [sellerAmount, order.seller_id]\n                    );\n                    await createTransaction(client, order.seller_id, 'MARKET_SALE_PENDING', sellerAmount, `Venda Conclu√≠da (Em Liquida√ß√£o): ${order.title}`, 'APPROVED', { orderId, settlementDays: 14 });\n\n                    // Notificar VENDEDOR sobre a venda confirmada\n                    notificationService.notifyUser(\n                        order.seller_id,\n                        'üéâ Venda Confirmada!',\n                        `O comprador confirmou o recebimento. R$ ${sellerAmount.toFixed(2)} ser√° liberado em 14 dias.`\n                    ).catch(() => { });\n                }\n\n                // 3. Pagar entregador se houver\n                const courierFee = parseFloat(order.delivery_fee || '0');\n                const isCourierAnticipated = order.metadata?.courier_anticipated;\n\n                if (order.courier_id && courierFee > 0) {\n                    const courierPart = courierFee * 0.90; // 90% para o entregador\n                    const systemPart = courierFee * 0.10;  // 10% para o sistema\n\n                    if (!isCourierAnticipated) {\n                        await updateUserBalance(client, order.courier_id, courierPart, 'credit');\n                        await createTransaction(client, order.courier_id, 'LOGISTIC_EARN', courierPart, `Entrega realizada: ${order.title}`, 'APPROVED', { orderId });\n\n                        // Bonificar Entregador com Score pela efici√™ncia\n                        await updateScore(client, order.courier_id, 10, `Entrega bem-sucedida #${orderId}`);\n\n                        // Notificar ENTREGADOR\n                        notificationService.notifyUser(\n                            order.courier_id,\n                            'üöö Entrega Conclu√≠da!',\n                            `Voc√™ ganhou R$ ${courierPart.toFixed(2)} pela entrega. Parab√©ns!`\n                        ).catch(() => { });\n                    }\n\n                    // DIVIS√ÉO DA TAXA DE LOG√çSTICA (15% sobre o frete)\n                    // Metade para Cotistas (Profit Pool) e Metade para a Empresa (Reservas)\n                    const profitShare = systemPart / 2;\n                    const companyShare = systemPart / 2;\n\n                    const taxPart = companyShare * PLATFORM_FEE_TAX_SHARE;\n                    const operPart = companyShare * PLATFORM_FEE_OPERATIONAL_SHARE;\n                    const ownerPart = companyShare * PLATFORM_FEE_OWNER_SHARE;\n                    const investPart = companyShare * PLATFORM_FEE_INVESTMENT_SHARE;\n                    const corpPart = companyShare * PLATFORM_FEE_CORPORATE_SHARE;\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            profit_pool = profit_pool + $1,\n                            total_tax_reserve = total_tax_reserve + $2,\n                            total_operational_reserve = total_operational_reserve + $3,\n                            total_owner_profit = total_owner_profit + $4,\n                            investment_reserve = investment_reserve + $5,\n                            total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6,\n                            system_balance = system_balance + $7\n                        `, [profitShare, taxPart, operPart, ownerPart, investPart, corpPart, companyShare]\n                    );\n\n                    // --- LIBERAR SEGURO DE ENTREGA ---\n                    // Entrega bem sucedida: devolve contribui√ß√£o do entregador\n                    const insuranceResult = await client.query(`\n                        UPDATE delivery_insurance_fund \n                        SET status = 'RELEASED', released_at = NOW()\n                        WHERE order_id = $1 AND status = 'RESERVED'\n                        RETURNING courier_contribution\n                    `, [orderId]);\n\n                    if (insuranceResult.rows.length > 0) {\n                        const courierContribution = parseFloat(insuranceResult.rows[0].courier_contribution || '0');\n                        if (courierContribution > 0) {\n                            // Devolve a contribui√ß√£o do entregador\n                            await client.query(\n                                'UPDATE users SET courier_insurance_balance = courier_insurance_balance + $1 WHERE id = $2',\n                                [courierContribution, order.courier_id]\n                            );\n                        }\n                    }\n                }\n\n                // 4. Se foi no credi√°rio, o dinheiro sai do caixa do sistema para o vendedor + courier\n                if (order.payment_method === 'CRED30_CREDIT') {\n                    await client.query('UPDATE system_config SET system_balance = system_balance - $1', [order.amount]);\n                }\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n            return c.json({ success: true, message: 'Entrega confirmada! Saldo liberado ao vendedor.' });\n        } catch (error) {\n            console.error('Receive Order Error:', error);\n            return c.json({ success: false, message: 'Erro ao processar libera√ß√£o de fundos' }, 500);\n        }\n    }\n\n    /**\n     * Rastreio do Pedido (GPS)\n     */\n    static async getOrderTracking(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('id');\n\n            const result = await pool.query(\n                `SELECT o.id, o.status, o.delivery_status, o.courier_id, \n                o.courier_lat, o.courier_lng, \n                o.pickup_lat, o.pickup_lng, o.delivery_lat, o.delivery_lng,\n                o.delivery_address, o.pickup_address,\n                u.name as courier_name, u.phone as courier_phone\n         FROM marketplace_orders o\n         LEFT JOIN users u ON o.courier_id = u.id\n         WHERE o.id = $1 AND (o.buyer_id = $2 OR o.courier_id = $2 OR o.seller_id = $2)`,\n                [orderId, user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Rastreio n√£o dispon√≠vel.' }, 404);\n            }\n\n            return c.json({ success: true, data: result.rows[0] });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao buscar rastreio' }, 500);\n        }\n    }\n    /**\n     * Cota√ß√£o de Frete (Zonas de CEP)\n     */\n    static async getShippingQuote(c: Context) {\n        try {\n            const listingId = c.req.query('listingId');\n            const destCep = c.req.query('destCep');\n            const pool = getDbPool(c);\n\n            if (!listingId || !destCep) {\n                return c.json({ success: false, message: 'ID do an√∫ncio e CEP de destino s√£o obrigat√≥rios.' }, 400);\n            }\n\n            const listingRes = await pool.query('SELECT seller_id, free_shipping, shipping_cost, pickup_postal_code FROM marketplace_listings WHERE id = $1', [listingId]);\n            if (listingRes.rows.length === 0) return c.json({ success: false, message: 'An√∫ncio n√£o encontrado.' }, 404);\n\n            const listing = listingRes.rows[0];\n            let originCep = listing.pickup_postal_code;\n\n            if (!originCep) {\n                const sellerRes = await pool.query('SELECT seller_address_postal_code FROM users WHERE id = $1', [listing.seller_id]);\n                originCep = sellerRes.rows[0]?.seller_address_postal_code || '00000000';\n            }\n\n            const quote = calculateShippingQuote(originCep, destCep, 1000, listing.free_shipping);\n\n            // Se o vendedor definiu um frete fixo no an√∫ncio e n√£o for gr√°tis\n            if (listing.shipping_cost > 0 && !listing.free_shipping) {\n                quote.fee = parseFloat(listing.shipping_cost);\n            }\n\n            return c.json({ success: true, data: quote });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao calcular frete' }, 500);\n        }\n    }\n\n    /**\n     * Solicitar Devolu√ß√£o / Arrependimento\n     */\n    static async requestReturn(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('id');\n            const { reason } = await c.req.json();\n            const pool = getDbPool(c);\n\n            const orderRes = await pool.query('SELECT * FROM marketplace_orders WHERE id = $1 AND buyer_id = $2', [orderId, user.id]);\n            if (orderRes.rows.length === 0) return c.json({ success: false, message: 'Pedido n√£o encontrado.' }, 404);\n\n            const order = orderRes.rows[0];\n            if (['COMPLETED', 'CANCELLED'].includes(order.status)) {\n                return c.json({ success: false, message: 'N√£o √© poss√≠vel devolver um pedido j√° finalizado ou cancelado.' }, 400);\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET status = 'RETURN_REQUESTED', dispute_reason = $1, updated_at = NOW() \n                 WHERE id = $2`,\n                [reason, orderId]\n            );\n\n            return c.json({ success: true, message: 'Solicita√ß√£o de devolu√ß√£o enviada. O saldo est√° bloqueado para sua seguran√ßa.' });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao solicitar devolu√ß√£o' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar C√≥digo de Rastreio (Transportadora)\n     */\n    static async updateTrackingCode(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const orderId = c.req.param('id');\n            const { trackingCode } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (!trackingCode) {\n                return c.json({ success: false, message: 'C√≥digo de rastreio √© obrigat√≥rio.' }, 400);\n            }\n\n            const result = await pool.query(\n                `UPDATE marketplace_orders \n                 SET tracking_code = $1, status = 'IN_TRANSIT', delivery_status = 'SHIPPED', updated_at = NOW()\n                 WHERE id = $2 AND seller_id = $3\n                 RETURNING buyer_id`,\n                [trackingCode, orderId, user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou voc√™ n√£o √© o vendedor.' }, 404);\n            }\n\n            // Notificar Comprador (Simula√ß√£o de notifica√ß√£o interna por enquanto)\n            console.log(`[NOTIFICATION] Comprador ${result.rows[0].buyer_id}: Seu pedido foi postado! C√≥digo: ${trackingCode}`);\n\n            return c.json({\n                success: true,\n                message: 'C√≥digo de rastreio atualizado com sucesso! O comprador foi notificado.'\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Atualizar status de pedido de comida (Restaurante)\n     */\n    static async updateFoodOrderStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const orderId = c.req.param('orderId');\n            const { status } = await c.req.json(); // 'PREPARING', 'READY_FOR_PICKUP'\n\n            if (!['PREPARING', 'READY_FOR_PICKUP'].includes(status)) {\n                return c.json({ success: false, message: 'Status inv√°lido para pedidos de comida.' }, 400);\n            }\n\n            const orderRes = await pool.query(\n                `SELECT mo.*, ml.title, ml.is_food \n                 FROM marketplace_orders mo \n                 JOIN marketplace_listings ml ON mo.listing_id = ml.id\n                 WHERE mo.id = $1 AND mo.seller_id = $2`,\n                [orderId, user.id]\n            );\n\n            if (orderRes.rows.length === 0) {\n                return c.json({ success: false, message: 'Pedido n√£o encontrado ou voc√™ n√£o √© o vendedor.' }, 404);\n            }\n\n            const order = orderRes.rows[0];\n            if (!order.is_food) {\n                return c.json({ success: false, message: 'Este pedido n√£o √© de alimenta√ß√£o.' }, 400);\n            }\n\n            let newOrderStatus = status;\n            let newDeliveryStatus = order.delivery_status;\n\n            // Se marcar como PRONTO, libera para os entregadores\n            if (status === 'READY_FOR_PICKUP') {\n                newOrderStatus = 'WAITING_SHIPPING'; // Status padr√£o para aguardando envio\n                newDeliveryStatus = 'AVAILABLE';   // Libera na log√≠stica\n            }\n\n            await pool.query(\n                `UPDATE marketplace_orders \n                 SET status = $1, delivery_status = $2, updated_at = NOW() \n                 WHERE id = $3`,\n                [newOrderStatus, newDeliveryStatus, orderId]\n            );\n\n            // Notificar Comprador\n            const msg = status === 'PREPARING'\n                ? `Seu pedido de \"${order.title}\" come√ßou a ser preparado! üç≥`\n                : `Seu pedido de \"${order.title}\" est√° pronto e aguardando um entregador! üõµ`;\n\n            await pool.query(`\n                INSERT INTO notifications (user_id, title, message, type)\n                VALUES ($1, $2, $3, $4)\n            `, [order.buyer_id, 'Status do Pedido', msg, 'MARKETPLACE_ORDER']);\n\n            return c.json({\n                success: true,\n                message: `Status atualizado para ${status}.`\n            });\n\n        } catch (error: any) {\n            console.error('Update Food Status Error:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar vendas do vendedor logado\n     */\n    static async getMySales(c: Context) {\n        try {\n            const user = c.get('user') as any;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT \n                    o.*, \n                    l.title as listing_title, \n                    l.image_url as listing_image, \n                    l.is_food,\n                    u.name as courier_name,\n                    u.phone as courier_phone,\n                    u.avatar_url as courier_photo,\n                    u.courier_vehicle as courier_vehicle_type,\n                    NULL as courier_vehicle_plate,\n                    u.courier_vehicle as courier_vehicle_model\n                FROM marketplace_orders o\n                JOIN marketplace_listings l ON o.listing_id = l.id\n                LEFT JOIN users u ON o.courier_id = u.id\n                WHERE o.seller_id = $1\n                ORDER BY o.created_at DESC\n            `, [user.id]);\n\n            console.log('DEBUG: getMySales result for user ' + user.id, result.rows); // DEBUG LOG\n\n            return c.json({ success: true, data: result.rows });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/monetization.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5595,5598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5595,5598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reserveShare' is assigned a value but never used.","line":182,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":182,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":218,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9715,9718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9715,9718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12562,12565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12562,12565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15240,15243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15240,15243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":400,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":400,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17705,17708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17705,17708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":482,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":482,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21209,21212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21209,21212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":563,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":563,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24723,24726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24723,24726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { PoolClient } from 'pg';\nimport { executeInTransaction, createTransaction } from '../../../domain/services/transaction.service';\nimport { updateScore } from '../../../application/services/score.service';\nimport {\n    VERIFIED_BADGE_PRICE,\n    SCORE_BOOST_PRICE,\n    SCORE_BOOST_POINTS,\n    REPUTATION_CHECK_PRICE,\n    MUTUAL_PROTECTION_PRICE,\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE,\n    PLATFORM_FEE_CORPORATE_SHARE\n} from '../../../shared/constants/business.constants';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport {\n    VALUE_PER_1000_POINTS,\n    MIN_POINTS_FOR_CONVERSION,\n    PointsService\n} from '../../../application/services/points.service';\n\nconst PRO_UPGRADE_FEE = 29.90;\n\nconst upgradeProSchema = z.object({\n    method: z.enum(['balance', 'pix', 'card']).default('balance'),\n    installments: z.number().optional()\n});\n\n/**\n * Fun√ß√£o auxiliar para verificar e converter pontos automaticamente\n */\nasync function autoConvertPoints(client: PoolClient, userId: string | number): Promise<{ converted: boolean; pointsConverted: number; moneyCredited: number; remainingPoints: number }> {\n    const userRes = await client.query('SELECT ad_points, balance FROM users WHERE id = $1 FOR UPDATE', [userId]);\n    const currentPoints = Math.floor(userRes.rows[0].ad_points || 0);\n\n    // Usa constante global (atualmente 1000)\n    if (currentPoints < MIN_POINTS_FOR_CONVERSION) {\n        return { converted: false, pointsConverted: 0, moneyCredited: 0, remainingPoints: currentPoints };\n    }\n\n    const lots = Math.floor(currentPoints / MIN_POINTS_FOR_CONVERSION);\n    const pointsToConvert = lots * MIN_POINTS_FOR_CONVERSION; // Ex: 1000, 2000...\n\n    // Nova regra: (Pontos / 1000) * 0.07\n    const moneyToCredit = (pointsToConvert / 1000) * VALUE_PER_1000_POINTS;\n\n    const remainingPoints = currentPoints - pointsToConvert;\n\n    const systemRes = await client.query('SELECT system_balance FROM system_config LIMIT 1 FOR UPDATE');\n    const systemBalance = parseFloat(systemRes.rows[0]?.system_balance || '0');\n\n    if (systemBalance < moneyToCredit) {\n        console.warn(`[POINTS] Caixa insuficiente para convers√£o. Caixa: ${systemBalance}, Necess√°rio: ${moneyToCredit}`);\n        return { converted: false, pointsConverted: 0, moneyCredited: 0, remainingPoints: currentPoints };\n    }\n\n    await client.query(`UPDATE system_config SET system_balance = system_balance - $1`, [moneyToCredit]);\n    await client.query(`UPDATE users SET ad_points = $1, balance = balance + $2 WHERE id = $3`, [remainingPoints, moneyToCredit, userId]);\n\n    await createTransaction(\n        client,\n        String(userId),\n        'BONUS',\n        moneyToCredit,\n        `üéâ Convers√£o Autom√°tica: ${pointsToConvert} pontos`,\n        'APPROVED'\n    );\n\n    return { converted: true, pointsConverted: pointsToConvert, moneyCredited: moneyToCredit, remainingPoints };\n}\n\nexport class MonetizationController {\n    /**\n     * Recompensa de v√≠deo\n     */\n    static async rewardVideo(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const REWARD_POINTS = 50;\n            const REWARD_SCORE = 5;\n            const COOLDOWN_MINUTES = 10;\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // LOCK USER: Previne farming simult√¢neo (abrir 10 abas e clicar ao mesmo tempo)\n                const userRes = await client.query('SELECT last_reward_at, score, ad_points FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const lastReward = userRes.rows[0].last_reward_at;\n\n                if (lastReward) {\n                    const diff = (Date.now() - new Date(lastReward).getTime()) / (1000 * 60);\n                    if (diff < COOLDOWN_MINUTES) {\n                        throw new Error(`Aguarde mais ${Math.ceil(COOLDOWN_MINUTES - diff)} minutos para o pr√≥ximo v√≠deo.`);\n                    }\n                }\n\n                await client.query(\n                    'UPDATE users SET last_reward_at = NOW() WHERE id = $1',\n                    [user.id]\n                );\n\n                await PointsService.addPoints(client, user.id, REWARD_POINTS, 'Recompensa de V√≠deo (Extra)');\n\n                const conversion = await autoConvertPoints(client, user.id);\n                const updatedRes = await client.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n                const newPoints = updatedRes.rows[0].ad_points || 0;\n\n                return { success: true, newPoints, conversion };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            const conversion = result.data?.conversion;\n            let message = `+${REWARD_POINTS} pontos farm e +${REWARD_SCORE} Score!`;\n\n            if (conversion?.converted) {\n                message += ` üéâ +R$ ${conversion.moneyCredited.toFixed(2)} convertidos!`;\n            }\n\n            return c.json({\n                success: true,\n                message,\n                points: result.data?.newPoints || 0,\n                conversion: conversion?.converted ? {\n                    moneyCredited: conversion.moneyCredited,\n                    pointsConverted: conversion.pointsConverted\n                } : null\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Upgrade PRO\n     */\n    static async upgradePro(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { method } = upgradeProSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Adicionar transa√ß√£o para leitura segura\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userCheck = await client.query('SELECT membership_type, balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                if (method !== 'balance') {\n                    throw new Error('Pagamentos PIX/Cart√£o externos est√£o temporariamente indispon√≠veis.');\n                }\n\n                // L√≥gica movida para dentro do executeInTransaction principal para manter o LOCK\n                // const result = await executeInTransaction... ( removido aninhamento desnecess√°rio se j√° estamos em tx, ou adaptar)\n\n                // Na verdade, o c√≥digo original abria uma tx na linha 149.\n                // Como agora abri na linha 137 (virtualmente), preciso ajustar a estrutura.\n                // O c√≥digo original fazia check fora da tx, e depois abria tx.\n                // Vou manter a tx iniciando na 149, mas adicionar o lock logo no inicio dela.\n\n                // RESETANDO bloco incorreto acima para editar corretamente.\n                // O bloco anterior (chunk 2) tentou envolver tudo em tx.\n                // Melhor abordagem: Deixar o userCheck original (leitura suja r√°pida) E adicionar lock dentro da tx existente.\n                if (userCheck.rows[0].membership_type === 'PRO') {\n                    throw new Error('Voc√™ j√° √© um Membro PRO!');\n                }\n\n                if (parseFloat(userCheck.rows[0].balance) < PRO_UPGRADE_FEE) {\n                    throw new Error('Saldo insuficiente para o upgrade PRO.');\n                }\n\n                await client.query('UPDATE users SET balance = balance - $1, membership_type = $2 WHERE id = $3', [PRO_UPGRADE_FEE, 'PRO', user.id]);\n\n                // REGRA 80/20: 80% Cotistas, 20% Sistema\n                const feeForProfit = PRO_UPGRADE_FEE * 0.80;\n                const feeForReserves = PRO_UPGRADE_FEE * 0.20;\n\n                // Dividir a parte do sistema (20%) em 4 partes iguais (5% do total cada)\n                const reserveShare = feeForReserves * 0.25;\n\n                await client.query(\n                    `UPDATE system_config SET \n                        profit_pool = profit_pool + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6`,\n                    [\n                        feeForProfit,\n                        feeForReserves * PLATFORM_FEE_TAX_SHARE,\n                        feeForReserves * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        feeForReserves * PLATFORM_FEE_OWNER_SHARE,\n                        feeForReserves * PLATFORM_FEE_INVESTMENT_SHARE,\n                        feeForReserves * PLATFORM_FEE_CORPORATE_SHARE\n                    ]\n                );\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'MEMBERSHIP_UPGRADE',\n                    PRO_UPGRADE_FEE,\n                    'Upgrade para Plano Cred30 PRO (Saldo)',\n                    'APPROVED',\n                    { useBalance: true }\n                );\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n            return c.json({ success: true, message: 'Parab√©ns! Agora voc√™ √© um MEMBRO PRO!' });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Comprar selo de verificado\n     */\n    static async buyVerifiedBadge(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userRes = await client.query('SELECT is_verified, balance FROM users WHERE id = $1', [user.id]);\n                if (userRes.rows[0].is_verified) {\n                    throw new Error('Voc√™ j√° possui o Selo de Verificado!');\n                }\n\n                if (parseFloat(userRes.rows[0].balance) < VERIFIED_BADGE_PRICE) {\n                    throw new Error(`Saldo insuficiente. Necess√°rio R$ ${VERIFIED_BADGE_PRICE.toFixed(2)}.`);\n                }\n\n                await client.query('UPDATE users SET balance = balance - $1, is_verified = TRUE WHERE id = $2', [VERIFIED_BADGE_PRICE, user.id]);\n                await updateScore(client, user.id, 100, 'Compra de Selo de Verificado (Confian√ßa)');\n\n                const feeForProfit = VERIFIED_BADGE_PRICE * 0.80;\n                const feeForReserves = VERIFIED_BADGE_PRICE * 0.20;\n\n                await client.query(\n                    `UPDATE system_config SET \n                        profit_pool = profit_pool + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6`,\n                    [\n                        feeForProfit,\n                        feeForReserves * PLATFORM_FEE_TAX_SHARE,\n                        feeForReserves * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        feeForReserves * PLATFORM_FEE_OWNER_SHARE,\n                        feeForReserves * PLATFORM_FEE_INVESTMENT_SHARE,\n                        feeForReserves * PLATFORM_FEE_CORPORATE_SHARE\n                    ]\n                );\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'PREMIUM_PURCHASE',\n                    VERIFIED_BADGE_PRICE,\n                    'Compra de Selo de Verificado',\n                    'APPROVED',\n                    { useBalance: true }\n                );\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n            return c.json({ success: true, message: 'Selo de Verificado Adquirido!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Comprar Boost de Score\n     */\n    static async buyScoreBoost(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userRes = await client.query('SELECT balance FROM users WHERE id = $1', [user.id]);\n\n                if (parseFloat(userRes.rows[0].balance) < SCORE_BOOST_PRICE) {\n                    throw new Error(`Saldo insuficiente. Necess√°rio R$ ${SCORE_BOOST_PRICE.toFixed(2)}.`);\n                }\n\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [SCORE_BOOST_PRICE, user.id]);\n                await updateScore(client, user.id, SCORE_BOOST_POINTS, 'Compra de Pacote Score Boost');\n\n                const feeForProfit = SCORE_BOOST_PRICE * 0.80;\n                const feeForReserves = SCORE_BOOST_PRICE * 0.20;\n\n                await client.query(\n                    `UPDATE system_config SET \n                        profit_pool = profit_pool + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6`,\n                    [\n                        feeForProfit,\n                        feeForReserves * PLATFORM_FEE_TAX_SHARE,\n                        feeForReserves * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        feeForReserves * PLATFORM_FEE_OWNER_SHARE,\n                        feeForReserves * PLATFORM_FEE_INVESTMENT_SHARE,\n                        feeForReserves * PLATFORM_FEE_CORPORATE_SHARE\n                    ]\n                );\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'PREMIUM_PURCHASE',\n                    SCORE_BOOST_PRICE,\n                    'Compra de Pacote Score Boost (+100)',\n                    'APPROVED',\n                    { useBalance: true }\n                );\n\n                return { success: true };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n            return c.json({ success: true, message: `Boost Ativado! +${SCORE_BOOST_POINTS} pontos de Score.` });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Check-in di√°rio\n     */\n    static async dailyCheckin(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const CHECKIN_POINTS = 100;\n            const CHECKIN_SCORE = 10;\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                // LOCK USER: Previne check-in duplo\n                const userRes = await client.query('SELECT last_checkin_at, ad_points FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const lastCheckin = userRes.rows[0].last_checkin_at;\n\n                if (lastCheckin) {\n                    const lastDate = new Date(lastCheckin).toLocaleDateString();\n                    const today = new Date().toLocaleDateString();\n                    if (lastDate === today) {\n                        throw new Error('Voc√™ j√° realizou o check-in de hoje!');\n                    }\n                }\n\n                await client.query(\n                    'UPDATE users SET last_checkin_at = NOW() WHERE id = $1',\n                    [user.id]\n                );\n\n                await PointsService.addPoints(client, user.id, CHECKIN_POINTS, 'Check-in Di√°rio');\n\n                const conversion = await autoConvertPoints(client, user.id);\n                const updatedRes = await client.query('SELECT ad_points FROM users WHERE id = $1', [user.id]);\n                const newPoints = updatedRes.rows[0].ad_points || 0;\n\n                return { success: true, newPoints, conversion };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            const conversion = result.data?.conversion;\n            let message = `Check-in realizado! +${CHECKIN_POINTS} pontos farm e +${CHECKIN_SCORE} Score.`;\n\n            if (conversion?.converted) {\n                message += ` üéâ +R$ ${conversion.moneyCredited.toFixed(2)} convertidos!`;\n            }\n\n            return c.json({\n                success: true,\n                message,\n                points: result.data?.newPoints || 0,\n                conversion: conversion?.converted ? {\n                    moneyCredited: conversion.moneyCredited,\n                    pointsConverted: conversion.pointsConverted\n                } : null\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Consulta de reputa√ß√£o\n     */\n    static async reputationCheck(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const targetEmail = c.req.param('email').toLowerCase().trim();\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                if (parseFloat(userRes.rows[0].balance) < REPUTATION_CHECK_PRICE) {\n                    throw new Error(`Saldo insuficiente. A consulta custa R$ ${REPUTATION_CHECK_PRICE.toFixed(2)}.`);\n                }\n\n                // FIX: Debit the user's balance!\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [REPUTATION_CHECK_PRICE, user.id]);\n\n                const targetRes = await client.query(\n                    'SELECT name, score, is_verified, membership_type, created_at, status FROM users WHERE email = $1',\n                    [targetEmail]\n                );\n\n                if (targetRes.rows.length === 0) {\n                    throw new Error('Nenhum associado encontrado.');\n                }\n\n                const target = targetRes.rows[0];\n\n                const feeForProfit = REPUTATION_CHECK_PRICE * 0.80;\n                const feeForReserves = REPUTATION_CHECK_PRICE * 0.20;\n\n                await client.query(\n                    `UPDATE system_config SET \n                        profit_pool = profit_pool + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6`,\n                    [\n                        feeForProfit,\n                        feeForReserves * PLATFORM_FEE_TAX_SHARE,\n                        feeForReserves * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        feeForReserves * PLATFORM_FEE_OWNER_SHARE,\n                        feeForReserves * PLATFORM_FEE_INVESTMENT_SHARE,\n                        feeForReserves * PLATFORM_FEE_CORPORATE_SHARE\n                    ]\n                );\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'REPUTATION_CONSULT',\n                    REPUTATION_CHECK_PRICE,\n                    `Consulta de Idoneidade: ${targetEmail}`,\n                    'APPROVED',\n                    { useBalance: true }\n                );\n\n                return {\n                    name: target.name,\n                    score: target.score,\n                    isVerified: target.is_verified,\n                    membership: target.membership_type,\n                    since: target.created_at,\n                    status: target.status\n                };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Consulta realizada com sucesso!',\n                data: result.data\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Comprar Prote√ß√£o M√∫tua (Seguro Social)\n     */\n    static async buyProtection(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await executeInTransaction(pool, async (client: PoolClient) => {\n                const userRes = await client.query('SELECT balance, is_protected FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n\n                if (userRes.rows[0].is_protected) {\n                    throw new Error('Sua Prote√ß√£o M√∫tua j√° est√° ativa!');\n                }\n\n                if (parseFloat(userRes.rows[0].balance) < MUTUAL_PROTECTION_PRICE) {\n                    throw new Error(`Saldo insuficiente. A prote√ß√£o mensal custa R$ ${MUTUAL_PROTECTION_PRICE.toFixed(2)}.`);\n                }\n\n                // Debita o saldo\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [MUTUAL_PROTECTION_PRICE, user.id]);\n\n                // Ativa prote√ß√£o (+30 dias)\n                const protectionExpiry = new Date();\n                protectionExpiry.setDate(protectionExpiry.getDate() + 30);\n\n                await client.query(\n                    'UPDATE users SET is_protected = TRUE, protection_expires_at = $1 WHERE id = $2',\n                    [protectionExpiry, user.id]\n                );\n\n                // Incrementa o fundo de prote√ß√£o (Regra 80/20)\n                const fundShare = MUTUAL_PROTECTION_PRICE * 0.80;\n                const systemShare = MUTUAL_PROTECTION_PRICE * 0.20;\n\n                await client.query(\n                    `UPDATE system_config SET \n                        mutual_reserve = mutual_reserve + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6`,\n                    [\n                        fundShare,\n                        systemShare * PLATFORM_FEE_TAX_SHARE,\n                        systemShare * PLATFORM_FEE_OPERATIONAL_SHARE,\n                        systemShare * PLATFORM_FEE_OWNER_SHARE,\n                        systemShare * PLATFORM_FEE_INVESTMENT_SHARE,\n                        systemShare * PLATFORM_FEE_CORPORATE_SHARE\n                    ]\n                );\n\n                // Ganho de Score por seguran√ßa\n                await updateScore(client, user.id, 50, 'Ativa√ß√£o de Prote√ß√£o M√∫tua (Preven√ß√£o)');\n\n                await createTransaction(\n                    client,\n                    user.id,\n                    'PROTECTION_PURCHASE',\n                    MUTUAL_PROTECTION_PRICE,\n                    'Ativa√ß√£o de Prote√ß√£o M√∫tua (Mensal)',\n                    'APPROVED',\n                    { useBalance: true }\n                );\n\n                return { success: true, expiry: protectionExpiry };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Voc√™ agora √© um Membro Protegido!',\n                expiry: result.data?.expiry\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/notifications.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1724,1727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1724,1727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":70,"column":20,"nodeType":"Literal","messageId":"unexpected","endLine":70,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":147,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { streamSSE } from 'hono/streaming';\nimport { notificationService } from '../../../application/services/notification.service';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\nexport class NotificationsController {\n    /**\n     * Endpoint para inscri√ß√£o em notifica√ß√µes em tempo real (SSE)\n     */\n    static async streamNotifications(c: Context) {\n        const user = c.get('user') as UserContext;\n\n        // Headers recomendados para SSE e para evitar cache de proxies/Nginx\n        c.header('Content-Type', 'text/event-stream');\n        c.header('Cache-Control', 'no-cache, no-transform');\n        c.header('Connection', 'keep-alive');\n        c.header('X-Accel-Buffering', 'no'); // Cr√≠tico para Nginx/Render\n\n        // Garantia extra de CORS para o Stream SSE\n        const allowedOrigins = [\n            'https://cred30.site',\n            'https://www.cred30.site',\n            'https://cred30-prod-app-2025.web.app',\n            'http://localhost:3000',\n            'http://localhost:3001',\n            'http://localhost:5173'\n        ];\n        const origin = c.req.header('Origin') || allowedOrigins[0];\n\n        if (allowedOrigins.includes(origin) || origin.endsWith('cred30.site')) {\n            c.header('Access-Control-Allow-Origin', origin);\n            c.header('Access-Control-Allow-Credentials', 'true');\n        } else {\n            c.header('Access-Control-Allow-Origin', allowedOrigins[0]);\n        }\n\n        return streamSSE(c, async (stream) => {\n            const connectionId = Math.random().toString(36).substring(7);\n\n            const send = (data: any) => {\n                stream.writeSSE({\n                    data: JSON.stringify(data),\n                    event: data.event || 'message',\n                    id: Date.now().toString(),\n                });\n            };\n\n            notificationService.addClient(user.id, connectionId, send);\n\n            // Evento inicial para abrir o pipe imediatamente e confirmar no frontend\n            stream.writeSSE({\n                data: JSON.stringify({ message: 'SSE_CONNECTED', timestamp: Date.now() }),\n                event: 'status',\n                id: 'init'\n            });\n\n            // Ping para manter a conex√£o ativa em proxies (Render/Heroku/Nginx)\n            const keepAlive = setInterval(() => {\n                stream.writeSSE({ data: 'ping', event: 'ping' });\n            }, 5000); // Reduzido de 15s para 5s\n\n            stream.onAbort(() => {\n                console.log(`üì° [SSE] Conex√£o abortada: ${user.id} (${connectionId})`);\n                notificationService.removeClient(user.id, connectionId);\n                clearInterval(keepAlive);\n            });\n\n            // Loop principal mantendo a conex√£o aberta\n            while (true) {\n                await stream.sleep(1000);\n            }\n        });\n    }\n\n    /**\n     * Endpoint para testar se as notifica√ß√µes est√£o funcionando\n     * Envia uma notifica√ß√£o de teste para o pr√≥prio usu√°rio\n     */\n    static async sendTestNotification(c: Context) {\n        const user = c.get('user') as UserContext;\n\n        await notificationService.notifyUser(\n            user.id,\n            'üîî Teste de Notifica√ß√£o',\n            'Se voc√™ est√° vendo isso, o sistema de notifica√ß√µes est√° funcionando perfeitamente!'\n        );\n\n        return c.json({\n            success: true,\n            message: 'Notifica√ß√£o de teste enviada! Verifique o sino.'\n        });\n    }\n\n    /**\n     * Listar notifica√ß√µes do usu√°rio (Hist√≥rico)\n     */\n    static async listNotifications(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT id, title, message, type, is_read as read, created_at as date \n                 FROM notifications \n                 WHERE user_id = $1 \n                 ORDER BY created_at DESC \n                 LIMIT 50`,\n                [user.id]\n            );\n\n            // Converter date para timestamp num√©rico para compatibilidade com interface do frontend\n            const notifications = result.rows.map(n => ({\n                ...n,\n                date: new Date(n.date).getTime()\n            }));\n\n            return c.json({ success: true, data: notifications });\n        } catch (error) {\n            console.error('Erro ao listar notifica√ß√µes:', error);\n            return c.json({ success: false, message: 'Erro ao buscar notifica√ß√µes' }, 500);\n        }\n    }\n\n    /**\n     * Marcar notifica√ß√£o como lida\n     */\n    static async markAsRead(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { id } = await c.req.json();\n            const pool = getDbPool(c);\n\n            if (id === 'all') {\n                await pool.query(\n                    'UPDATE notifications SET is_read = TRUE WHERE user_id = $1',\n                    [user.id]\n                );\n            } else {\n                await pool.query(\n                    'UPDATE notifications SET is_read = TRUE WHERE id = $1 AND user_id = $2',\n                    [id, user.id]\n                );\n            }\n\n            return c.json({ success: true, message: 'Notifica√ß√£o marcada como lida' });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao atualizar notifica√ß√£o' }, 500);\n        }\n    }\n    /**\n     * Excluir notifica√ß√£o (Esvaziar lixeira)\n     */\n    static async deleteNotification(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            if (id === 'all') {\n                await pool.query(\n                    'DELETE FROM notifications WHERE user_id = $1',\n                    [user.id]\n                );\n            } else {\n                await pool.query(\n                    'DELETE FROM notifications WHERE id = $1 AND user_id = $2',\n                    [id, user.id]\n                );\n            }\n\n            return c.json({ success: true, message: 'Notifica√ß√£o exclu√≠da permanentemente' });\n        } catch (error) {\n            console.error('Erro ao excluir notifica√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro ao excluir notifica√ß√£o' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/pdv.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4012,4015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4012,4015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5874,5877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5874,5877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":249,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9924,9927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9924,9927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10944,10947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10944,10947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13714,13717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13714,13717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":387,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14855,14858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14855,14858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15888,15891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15888,15891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17234,17237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17234,17237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":496,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":496,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18638,18641],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18638,18641],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":522,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19509,19512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19509,19512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'deviceId' is never reassigned. Use 'const' instead.","line":549,"column":21,"nodeType":"Identifier","messageId":"useConst","endLine":549,"endColumn":29,"fix":{"range":[20675,20695],"text":"const deviceId = null;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":599,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":599,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22850,22853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22850,22853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":657,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":657,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25051,25054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25051,25054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, updateUserBalance, createTransaction, lockSystemConfig } from '../../../domain/services/transaction.service';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport {\n    PDV_PLANS,\n    PDV_FEE_TAX_SHARE,\n    PDV_FEE_OPERATIONAL_SHARE,\n    PDV_FEE_OWNER_SHARE,\n    PDV_FEE_STABILITY_SHARE,\n    PDV_FEE_COTISTA_SHARE,\n    PDV_FEE_CORPORATE_SHARE\n} from '../../../shared/constants/business.constants';\nimport { v4 as uuidv4 } from 'uuid';\nimport jwt from 'jsonwebtoken';\n\n// Schemas de Valida√ß√£o\nconst subscribePdvSchema = z.object({\n    plan: z.enum(['BASIC', 'PRO', 'ENTERPRISE'])\n});\n\nconst registerDeviceSchema = z.object({\n    deviceName: z.string().min(2).max(100),\n    deviceType: z.enum(['DESKTOP', 'TABLET', 'MOBILE']).optional().default('DESKTOP')\n});\n\nconst createProductSchema = z.object({\n    name: z.string().min(2).max(200),\n    barcode: z.string().optional(),\n    sku: z.string().optional(),\n    price: z.coerce.number().min(0.01),\n    costPrice: z.coerce.number().min(0).optional(),\n    stock: z.coerce.number().min(0).optional().default(0),\n    minStock: z.coerce.number().min(0).optional().default(5),\n    category: z.string().optional(),\n    unit: z.string().optional().default('UN'),\n    taxNcm: z.string().optional(),\n    imageUrl: z.string().optional()\n});\n\nconst createSaleSchema = z.object({\n    items: z.array(z.object({\n        productId: z.string().uuid().optional(),\n        productName: z.string(),\n        productBarcode: z.string().optional(),\n        quantity: z.coerce.number().min(0.001),\n        unitPrice: z.coerce.number().min(0),\n        discount: z.coerce.number().min(0).optional().default(0)\n    })).min(1),\n    discount: z.coerce.number().min(0).optional().default(0),\n    paymentMethod: z.enum(['PIX', 'DINHEIRO', 'CARTAO_CREDITO', 'CARTAO_DEBITO', 'CRED30']),\n    receivedAmount: z.coerce.number().min(0).optional(),\n    customerCpf: z.string().optional(),\n    customerName: z.string().optional(),\n    notes: z.string().optional()\n});\n\nexport class PdvController {\n\n    /**\n     * Listar planos dispon√≠veis\n     */\n    static async getPlans(c: Context) {\n        return c.json({\n            success: true,\n            plans: Object.values(PDV_PLANS)\n        });\n    }\n\n    /**\n     * Verificar status da assinatura do usu√°rio\n     */\n    static async getSubscriptionStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT s.*, \n                       (SELECT COUNT(*) FROM pdv_devices WHERE subscription_id = s.id AND is_active = TRUE) as active_devices\n                FROM pdv_subscriptions s\n                WHERE s.user_id = $1 AND s.status = 'ACTIVE'\n                ORDER BY s.created_at DESC\n                LIMIT 1\n            `, [user.id]);\n\n            if (result.rows.length === 0) {\n                return c.json({\n                    success: true,\n                    hasSubscription: false,\n                    subscription: null\n                });\n            }\n\n            const sub = result.rows[0];\n            const planInfo = Object.values(PDV_PLANS).find(p => p.code === sub.plan);\n\n            return c.json({\n                success: true,\n                hasSubscription: true,\n                subscription: {\n                    id: sub.id,\n                    plan: sub.plan,\n                    planName: planInfo?.name || sub.plan,\n                    maxDevices: sub.max_devices,\n                    activeDevices: parseInt(sub.active_devices),\n                    priceMonthly: parseFloat(sub.price_monthly),\n                    status: sub.status,\n                    expiresAt: sub.expires_at,\n                    autoRenew: sub.auto_renew\n                }\n            });\n        } catch (error: any) {\n            console.error('[PDV] Erro ao buscar assinatura:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Assinar plano PDV\n     */\n    static async subscribe(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = subscribePdvSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({ success: false, message: 'Plano inv√°lido.' }, 400);\n            }\n\n            const { plan } = parseResult.data;\n            const planInfo = PDV_PLANS[plan];\n\n            // Verificar se usu√°rio √© vendedor\n            const sellerCheck = await pool.query(\n                'SELECT is_seller, seller_status FROM users WHERE id = $1',\n                [user.id]\n            );\n\n            if (!sellerCheck.rows[0]?.is_seller || sellerCheck.rows[0]?.seller_status !== 'approved') {\n                return c.json({\n                    success: false,\n                    message: 'Voc√™ precisa ser um vendedor aprovado para assinar o PDV.'\n                }, 403);\n            }\n\n            // Verificar se j√° tem assinatura ativa\n            const existingCheck = await pool.query(\n                'SELECT id FROM pdv_subscriptions WHERE user_id = $1 AND status = $2',\n                [user.id, 'ACTIVE']\n            );\n\n            if (existingCheck.rows.length > 0) {\n                return c.json({\n                    success: false,\n                    message: 'Voc√™ j√° possui uma assinatura PDV ativa. Cancele a atual para trocar de plano.'\n                }, 400);\n            }\n\n            // Processar pagamento e criar assinatura\n            const result = await executeInTransaction(pool, async (client: any) => {\n                // Verificar saldo\n                const balanceRes = await client.query(\n                    'SELECT balance FROM users WHERE id = $1 FOR UPDATE',\n                    [user.id]\n                );\n                const balance = parseFloat(balanceRes.rows[0].balance);\n\n                if (balance < planInfo.price) {\n                    throw new Error(`Saldo insuficiente. Voc√™ tem R$ ${balance.toFixed(2)}, mas precisa de R$ ${planInfo.price.toFixed(2)}.`);\n                }\n\n                // Descontar saldo\n                await updateUserBalance(client, user.id, -planInfo.price);\n\n                // Distribuir para os potes\n                await lockSystemConfig(client);\n\n                const taxAmount = planInfo.price * PDV_FEE_TAX_SHARE;\n                const operationalAmount = planInfo.price * PDV_FEE_OPERATIONAL_SHARE;\n                const ownerAmount = planInfo.price * PDV_FEE_OWNER_SHARE;\n                const stabilityAmount = planInfo.price * PDV_FEE_STABILITY_SHARE;\n                const cotistaAmount = planInfo.price * PDV_FEE_COTISTA_SHARE;\n                const corporateAmount = planInfo.price * PDV_FEE_CORPORATE_SHARE;\n\n                await client.query(`\n                    UPDATE system_config SET\n                        total_tax_reserve = total_tax_reserve + $1,\n                        total_operational_reserve = total_operational_reserve + $2,\n                        total_owner_profit = total_owner_profit + $3,\n                        mutual_reserve = COALESCE(mutual_reserve, 0) + $4,\n                        profit_pool = profit_pool + $5,\n                        total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $6\n                `, [taxAmount, operationalAmount, ownerAmount, stabilityAmount, cotistaAmount, corporateAmount]);\n\n                // Criar assinatura\n                const expiresAt = new Date();\n                expiresAt.setMonth(expiresAt.getMonth() + 1);\n\n                const subResult = await client.query(`\n                    INSERT INTO pdv_subscriptions (user_id, plan, max_devices, price_monthly, expires_at, last_payment_at)\n                    VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)\n                    RETURNING id\n                `, [user.id, planInfo.code, planInfo.maxDevices, planInfo.price, expiresAt]);\n\n                const subscriptionId = subResult.rows[0].id;\n\n                // Registrar pagamento\n                await client.query(`\n                    INSERT INTO pdv_subscription_payments \n                    (subscription_id, amount, tax_amount, operational_amount, owner_amount, stability_amount, cotista_amount, corporate_amount)\n                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                `, [subscriptionId, planInfo.price, taxAmount, operationalAmount, ownerAmount, stabilityAmount, cotistaAmount, corporateAmount]);\n\n                // Registrar transa√ß√£o\n                // Registrar transa√ß√£o\n                await createTransaction(\n                    client,\n                    user.id,\n                    'PDV_SUBSCRIPTION',\n                    -planInfo.price,\n                    `Assinatura PDV - Plano ${planInfo.name}`,\n                    'COMPLETED',\n                    { subscriptionId, plan: planInfo.code }\n                );\n\n                return { subscriptionId, expiresAt };\n            });\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.error || 'Erro ao processar assinatura.' }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `Assinatura ${planInfo.name} ativada com sucesso!`,\n                subscription: {\n                    id: result.data!.subscriptionId,\n                    plan: planInfo.code,\n                    planName: planInfo.name,\n                    maxDevices: planInfo.maxDevices,\n                    expiresAt: result.data!.expiresAt\n                }\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao assinar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Cancelar assinatura\n     */\n    static async cancelSubscription(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                UPDATE pdv_subscriptions \n                SET status = 'CANCELLED', auto_renew = FALSE, updated_at = CURRENT_TIMESTAMP\n                WHERE user_id = $1 AND status = 'ACTIVE'\n                RETURNING id\n            `, [user.id]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Nenhuma assinatura ativa encontrada.' }, 404);\n            }\n\n            return c.json({\n                success: true,\n                message: 'Assinatura cancelada. Voc√™ ainda ter√° acesso at√© o fim do per√≠odo pago.'\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao cancelar:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar novo dispositivo/m√°quina\n     */\n    static async registerDevice(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = registerDeviceSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({ success: false, message: 'Dados inv√°lidos.' }, 400);\n            }\n\n            const { deviceName, deviceType } = parseResult.data;\n\n            // Buscar assinatura ativa\n            const subResult = await pool.query(`\n                SELECT s.*, \n                       (SELECT COUNT(*) FROM pdv_devices WHERE subscription_id = s.id AND is_active = TRUE) as active_devices\n                FROM pdv_subscriptions s\n                WHERE s.user_id = $1 AND s.status = 'ACTIVE'\n            `, [user.id]);\n\n            if (subResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Voc√™ n√£o possui assinatura PDV ativa.' }, 403);\n            }\n\n            const sub = subResult.rows[0];\n            const activeDevices = parseInt(sub.active_devices);\n\n            if (activeDevices >= sub.max_devices) {\n                return c.json({\n                    success: false,\n                    message: `Limite de dispositivos atingido (${sub.max_devices}). Fa√ßa upgrade do plano ou desative um dispositivo.`\n                }, 400);\n            }\n\n            // Gerar token √∫nico para o dispositivo\n            const deviceToken = jwt.sign(\n                {\n                    userId: user.id,\n                    subscriptionId: sub.id,\n                    deviceId: uuidv4(),\n                    type: 'pdv_device'\n                },\n                process.env.JWT_SECRET || 'fallback-secret',\n                { expiresIn: '365d' }\n            );\n\n            // Registrar dispositivo\n            const deviceResult = await pool.query(`\n                INSERT INTO pdv_devices (subscription_id, device_name, device_token, device_type, last_seen_at)\n                VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)\n                RETURNING id\n            `, [sub.id, deviceName, deviceToken, deviceType]);\n\n            return c.json({\n                success: true,\n                message: 'Dispositivo registrado com sucesso!',\n                device: {\n                    id: deviceResult.rows[0].id,\n                    name: deviceName,\n                    type: deviceType,\n                    token: deviceToken\n                }\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao registrar dispositivo:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar dispositivos\n     */\n    static async getDevices(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT d.id, d.device_name, d.device_type, d.last_seen_at, d.is_active, d.created_at\n                FROM pdv_devices d\n                JOIN pdv_subscriptions s ON d.subscription_id = s.id\n                WHERE s.user_id = $1\n                ORDER BY d.created_at DESC\n            `, [user.id]);\n\n            return c.json({\n                success: true,\n                devices: result.rows.map(d => ({\n                    id: d.id,\n                    name: d.device_name,\n                    type: d.device_type,\n                    lastSeen: d.last_seen_at,\n                    isActive: d.is_active,\n                    createdAt: d.created_at\n                }))\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao listar dispositivos:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Desativar dispositivo\n     */\n    static async deactivateDevice(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const deviceId = c.req.param('deviceId');\n\n            const result = await pool.query(`\n                UPDATE pdv_devices d\n                SET is_active = FALSE\n                FROM pdv_subscriptions s\n                WHERE d.subscription_id = s.id\n                AND s.user_id = $1\n                AND d.id = $2\n                RETURNING d.id\n            `, [user.id, deviceId]);\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Dispositivo n√£o encontrado.' }, 404);\n            }\n\n            return c.json({ success: true, message: 'Dispositivo desativado.' });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao desativar dispositivo:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // ========================================\n    // PRODUTOS\n    // ========================================\n\n    /**\n     * Listar produtos do PDV\n     */\n    static async getProducts(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT * FROM pdv_products\n                WHERE user_id = $1 AND is_active = TRUE\n                ORDER BY name ASC\n            `, [user.id]);\n\n            return c.json({\n                success: true,\n                products: result.rows.map(p => ({\n                    id: p.id,\n                    name: p.name,\n                    barcode: p.barcode,\n                    sku: p.sku,\n                    price: parseFloat(p.price),\n                    costPrice: p.cost_price ? parseFloat(p.cost_price) : null,\n                    stock: parseFloat(p.stock),\n                    minStock: parseFloat(p.min_stock),\n                    category: p.category,\n                    unit: p.unit,\n                    imageUrl: p.image_url\n                }))\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao listar produtos:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Criar produto\n     */\n    static async createProduct(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = createProductSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({ success: false, message: 'Dados inv√°lidos.', errors: parseResult.error.errors }, 400);\n            }\n\n            const data = parseResult.data;\n\n            const result = await pool.query(`\n                INSERT INTO pdv_products (user_id, name, barcode, sku, price, cost_price, stock, min_stock, category, unit, tax_ncm, image_url)\n                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n                RETURNING id\n            `, [\n                user.id, data.name, data.barcode, data.sku, data.price, data.costPrice,\n                data.stock, data.minStock, data.category, data.unit, data.taxNcm, data.imageUrl\n            ]);\n\n            return c.json({\n                success: true,\n                message: 'Produto criado com sucesso!',\n                productId: result.rows[0].id\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao criar produto:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    // ========================================\n    // VENDAS\n    // ========================================\n\n    /**\n     * Registrar venda\n     */\n    static async createSale(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const parseResult = createSaleSchema.safeParse(body);\n            if (!parseResult.success) {\n                return c.json({ success: false, message: 'Dados inv√°lidos.', errors: parseResult.error.errors }, 400);\n            }\n\n            const data = parseResult.data;\n\n            const result = await executeInTransaction(pool, async (client: any) => {\n                // Calcular totais\n                let subtotal = 0;\n                const processedItems = [];\n\n                for (const item of data.items) {\n                    const itemTotal = (item.quantity * item.unitPrice) - (item.discount || 0);\n                    subtotal += itemTotal;\n                    processedItems.push({\n                        ...item,\n                        total: itemTotal\n                    });\n\n                    // Baixar estoque se tiver productId\n                    if (item.productId) {\n                        await client.query(`\n                            UPDATE pdv_products \n                            SET stock = stock - $1, updated_at = CURRENT_TIMESTAMP\n                            WHERE id = $2 AND user_id = $3\n                        `, [item.quantity, item.productId, user.id]);\n                    }\n                }\n\n                const total = subtotal - (data.discount || 0);\n                const changeAmount = data.receivedAmount ? Math.max(0, data.receivedAmount - total) : 0;\n\n                // Buscar device_id se estiver autenticado via token de dispositivo\n                let deviceId = null;\n                // TODO: Implementar autentica√ß√£o por device token\n\n                // Obter pr√≥ximo n√∫mero de venda\n                const saleNumberRes = await client.query(\n                    'SELECT get_next_sale_number($1) as num',\n                    [user.id]\n                );\n                const saleNumber = saleNumberRes.rows[0].num;\n\n                // Criar venda\n                const saleResult = await client.query(`\n                    INSERT INTO pdv_sales \n                    (user_id, device_id, sale_number, subtotal, discount, total, payment_method, received_amount, change_amount, customer_cpf, customer_name, notes)\n                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n                    RETURNING id\n                `, [\n                    user.id, deviceId, saleNumber, subtotal, data.discount, total,\n                    data.paymentMethod, data.receivedAmount, changeAmount,\n                    data.customerCpf, data.customerName, data.notes\n                ]);\n\n                const saleId = saleResult.rows[0].id;\n\n                // Inserir itens\n                for (const item of processedItems) {\n                    await client.query(`\n                        INSERT INTO pdv_sale_items \n                        (sale_id, product_id, product_name, product_barcode, quantity, unit_price, discount, total)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                    `, [\n                        saleId, item.productId || null, item.productName, item.productBarcode,\n                        item.quantity, item.unitPrice, item.discount, item.total\n                    ]);\n                }\n\n                return { saleId, saleNumber, total, changeAmount };\n            });\n\n            return c.json({\n                success: true,\n                message: 'Venda registrada!',\n                sale: {\n                    id: result.data!.saleId,\n                    number: result.data!.saleNumber,\n                    total: result.data!.total,\n                    change: result.data!.changeAmount\n                }\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao criar venda:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar vendas do dia\n     */\n    static async getSales(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const startDate = c.req.query('startDate') || new Date().toISOString().split('T')[0];\n            const endDate = c.req.query('endDate') || startDate;\n\n            const result = await pool.query(`\n                SELECT s.*, \n                       (SELECT json_agg(json_build_object(\n                           'productName', i.product_name,\n                           'quantity', i.quantity,\n                           'unitPrice', i.unit_price,\n                           'total', i.total\n                       )) FROM pdv_sale_items i WHERE i.sale_id = s.id) as items\n                FROM pdv_sales s\n                WHERE s.user_id = $1\n                AND s.created_at::date BETWEEN $2 AND $3\n                ORDER BY s.created_at DESC\n            `, [user.id, startDate, endDate]);\n\n            // Totais\n            const totals = {\n                count: result.rows.length,\n                total: result.rows.reduce((sum, s) => sum + parseFloat(s.total), 0),\n                byPaymentMethod: {} as Record<string, number>\n            };\n\n            result.rows.forEach(s => {\n                const method = s.payment_method || 'OUTROS';\n                totals.byPaymentMethod[method] = (totals.byPaymentMethod[method] || 0) + parseFloat(s.total);\n            });\n\n            return c.json({\n                success: true,\n                sales: result.rows.map(s => ({\n                    id: s.id,\n                    number: s.sale_number,\n                    total: parseFloat(s.total),\n                    discount: parseFloat(s.discount),\n                    paymentMethod: s.payment_method,\n                    customerName: s.customer_name,\n                    createdAt: s.created_at,\n                    items: s.items || []\n                })),\n                totals\n            });\n\n        } catch (error: any) {\n            console.error('[PDV] Erro ao listar vendas:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/products.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[886,889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[886,889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":77,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3857,3860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3857,3860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4585,4588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4585,4588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5959,5962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5959,5962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":180,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":180,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":237,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":237,"endColumn":27},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":237,"column":29,"nodeType":"BlockStatement","messageId":"unexpected","endLine":237,"endColumn":32,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9060,9061],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"prefer-const","severity":2,"message":"'title' is never reassigned. Use 'const' instead.","line":242,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":242,"endColumn":22,"fix":{"range":[9121,9195],"text":"const title = getMeta('og:title') || getMeta('twitter:title') || getTitle();"}},{"ruleId":"prefer-const","severity":2,"message":"'description' is never reassigned. Use 'const' instead.","line":243,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":243,"endColumn":28,"fix":{"range":[9208,9312],"text":"const description = getMeta('og:description') || getMeta('description') || getMeta('twitter:description');"}},{"ruleId":"prefer-const","severity":2,"message":"'image' is never reassigned. Use 'const' instead.","line":244,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":244,"endColumn":22,"fix":{"range":[9325,9385],"text":"const image = getMeta('og:image') || getMeta('twitter:image');"}},{"ruleId":"prefer-const","severity":2,"message":"'price' is never reassigned. Use 'const' instead.","line":245,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":245,"endColumn":22,"fix":{"range":[9398,9421],"text":"const price = getPrice();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9760,9763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9760,9763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\n// Schema de valida√ß√£o\nconst productSchema = z.object({\n    title: z.string().min(3, \"T√≠tulo muito curto\"),\n    description: z.string().optional(),\n    imageUrl: z.string().url(\"URL da imagem inv√°lida\").optional().or(z.literal('')),\n    affiliateUrl: z.string().url(\"Link de afiliado inv√°lido\"),\n    price: z.number().optional(),\n    category: z.string().default('geral'),\n    active: z.boolean().default(true),\n});\n\nexport class ProductsController {\n    /**\n     * Listar produtos ativos\n     */\n    static async listProducts(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const { category } = c.req.query();\n\n            let query = 'SELECT * FROM products WHERE active = true';\n            const params: any[] = [];\n\n            if (category) {\n                query += ' AND category = $1';\n                params.push(category);\n            }\n\n            query += ' ORDER BY created_at DESC';\n\n            const result = await pool.query(query, params);\n\n            const products = result.rows.map(row => ({\n                id: row.id,\n                title: row.title,\n                description: row.description,\n                imageUrl: row.image_url,\n                affiliateUrl: row.affiliate_url,\n                price: row.price ? parseFloat(row.price) : null,\n                category: row.category,\n                active: row.active,\n                createdAt: row.created_at\n            }));\n\n            return c.json({ success: true, data: products });\n        } catch (error) {\n            console.error('Erro ao listar produtos:', error);\n            return c.json({ success: false, message: 'Erro interno ao listar produtos' }, 500);\n        }\n    }\n\n    /**\n     * Listar tudo (Admin)\n     */\n    static async listAllAdmin(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const result = await pool.query('SELECT * FROM products ORDER BY created_at DESC');\n\n            const products = result.rows.map(row => ({\n                id: row.id,\n                title: row.title,\n                description: row.description,\n                imageUrl: row.image_url,\n                affiliateUrl: row.affiliate_url,\n                price: row.price ? parseFloat(row.price) : null,\n                category: row.category,\n                active: row.active,\n                createdAt: row.created_at\n            }));\n\n            return c.json({ success: true, data: products });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Criar produto\n     */\n    static async createProduct(c: Context) {\n        try {\n            const body = await c.req.json();\n            const data = productSchema.parse(body);\n            const pool = getDbPool(c);\n\n            const query = `\n                INSERT INTO products (title, description, image_url, affiliate_url, price, category, active)\n                VALUES ($1, $2, $3, $4, $5, $6, $7)\n                RETURNING *\n            `;\n\n            const values = [\n                data.title,\n                data.description || null,\n                data.imageUrl || null,\n                data.affiliateUrl,\n                data.price || null,\n                data.category,\n                data.active\n            ];\n\n            const result = await pool.query(query, values);\n            const newProduct = result.rows[0];\n\n            return c.json({\n                success: true,\n                message: 'Produto criado com sucesso',\n                data: {\n                    id: newProduct.id,\n                    ...data\n                }\n            }, 201);\n\n        } catch (error: any) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            console.error('Erro ao criar produto:', error);\n            return c.json({ success: false, message: 'Erro ao criar produto' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar produto\n     */\n    static async updateProduct(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const body = await c.req.json();\n            const schema = productSchema.partial();\n            const data = schema.parse(body);\n            const pool = getDbPool(c);\n\n            const fields: string[] = [];\n            const values: any[] = [];\n            let idx = 1;\n\n            if (data.title !== undefined) { fields.push(`title = $${idx++}`); values.push(data.title); }\n            if (data.description !== undefined) { fields.push(`description = $${idx++}`); values.push(data.description); }\n            if (data.imageUrl !== undefined) { fields.push(`image_url = $${idx++}`); values.push(data.imageUrl); }\n            if (data.affiliateUrl !== undefined) { fields.push(`affiliate_url = $${idx++}`); values.push(data.affiliateUrl); }\n            if (data.price !== undefined) { fields.push(`price = $${idx++}`); values.push(data.price); }\n            if (data.category !== undefined) { fields.push(`category = $${idx++}`); values.push(data.category); }\n            if (data.active !== undefined) { fields.push(`active = $${idx++}`); values.push(data.active); }\n\n            if (fields.length === 0) return c.json({ success: false, message: 'Nada a atualizar' }, 400);\n\n            values.push(id);\n            const query = `UPDATE products SET ${fields.join(', ')} WHERE id = $${idx} RETURNING *`;\n\n            const result = await pool.query(query, values);\n\n            if (result.rowCount === 0) return c.json({ success: false, message: 'Produto n√£o encontrado' }, 404);\n\n            return c.json({ success: true, message: 'Produto atualizado', data: result.rows[0] });\n\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message || 'Erro ao atualizar' }, 500);\n        }\n    }\n\n    /**\n     * Deletar produto\n     */\n    static async deleteProduct(c: Context) {\n        try {\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const result = await pool.query('DELETE FROM products WHERE id = $1', [id]);\n\n            if (result.rowCount === 0) return c.json({ success: false, message: 'Produto n√£o encontrado' }, 404);\n\n            return c.json({ success: true, message: 'Produto removido' });\n        } catch (error) {\n            return c.json({ success: false, message: 'Erro ao deletar' }, 500);\n        }\n    }\n\n    /**\n     * Buscar metadados de uma URL\n     */\n    static async fetchMetadata(c: Context) {\n        try {\n            const { url } = await c.req.json();\n            if (!url) return c.json({ success: false, message: 'URL is required' }, 400);\n\n            const response = await fetch(url, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'\n                }\n            });\n\n            if (!response.ok) {\n                return c.json({ success: false, message: `Failed to access URL: ${response.status}` }, 400);\n            }\n\n            const html = await response.text();\n\n            const getMeta = (prop: string) => {\n                const regex = new RegExp(`<meta\\\\s+(?:property|name)=[\"']${prop}[\"']\\\\s+content=[\"']([^\"']*)[\"']`, 'i');\n                const match = html.match(regex);\n                return match ? match[1] : '';\n            };\n\n            const getTitle = () => {\n                const match = html.match(/<title>([^<]*)<\\/title>/i);\n                return match ? match[1].trim() : '';\n            }\n\n            const getPrice = () => {\n                const metaPrice = getMeta('product:price:amount') ||\n                    getMeta('og:price:amount') ||\n                    getMeta('product:amount');\n                if (metaPrice) return parseFloat(metaPrice.replace(',', '.'));\n\n                try {\n                    const jsonLdMatch = html.match(/<script type=\"application\\/ld\\+json\">([\\s\\S]*?)<\\/script>/gi);\n                    if (jsonLdMatch) {\n                        for (const script of jsonLdMatch) {\n                            const content = script.replace(/<script.*?>|<\\/script>/gi, '');\n                            const json = JSON.parse(content);\n                            const items = Array.isArray(json) ? json : [json];\n                            for (const item of items) {\n                                if (item['@type'] === 'Product' || item['@type'] === 'Offer') {\n                                    const price = item.offers?.price || item.price;\n                                    if (price) return parseFloat(String(price).replace(',', '.'));\n                                }\n                            }\n                        }\n                    }\n                } catch (e) { }\n\n                return null;\n            };\n\n            let title = getMeta('og:title') || getMeta('twitter:title') || getTitle();\n            let description = getMeta('og:description') || getMeta('description') || getMeta('twitter:description');\n            let image = getMeta('og:image') || getMeta('twitter:image');\n            let price = getPrice();\n\n            return c.json({\n                success: true,\n                data: {\n                    title: (title || '').trim(),\n                    description: (description || '').trim(),\n                    imageUrl: (image || '').trim(),\n                    price: price\n                }\n            });\n\n        } catch (error: any) {\n            console.error('Error fetching metadata:', error);\n            return c.json({ success: false, message: 'Failed to fetch metadata: ' + error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/promo-videos.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ADMIN_PIX_KEY' is defined but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ADMIN_PIX_KEY"},"fix":{"range":[599,618],"text":""},"desc":"Remove unused variable \"ADMIN_PIX_KEY\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11561,11564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11561,11564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12472,12475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12472,12475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18904,18907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18904,18907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction } from '../../../domain/services/transaction.service';\nimport { getYouTubeFullStats } from '../../../infrastructure/gateways/youtube.service';\nimport {\n    VIDEO_VIEWER_SHARE as VIEWER_SHARE,\n    VIDEO_QUOTA_HOLDERS_SHARE as QUOTA_HOLDERS_SHARE,\n    VIDEO_SERVICE_FEE_SHARE as SERVICE_FEE_SHARE,\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE,\n    ADMIN_PIX_KEY\n} from '../../../shared/constants/business.constants';\nimport { PointsService, POINTS_CONVERSION_RATE, MIN_POINTS_FOR_CONVERSION } from '../../../application/services/points.service';\n\n// Constantes\n// Constantes - Sincronizadas com PointsService\nconst POINTS_PER_REAL = POINTS_CONVERSION_RATE;\nconst MIN_CONVERSION_POINTS = MIN_POINTS_FOR_CONVERSION;\nconst VIDEO_TAGS = ['ENTRETENIMENTO', 'MUSICA', 'EDUCACAO', 'GAMES', 'LIFESTYLE', 'TECNOLOGIA', 'NEGOCIOS', 'SAUDE', 'HUMOR', 'OUTROS'] as const;\n\n// Schema de valida√ß√£o\nconst createVideoSchema = z.object({\n    title: z.string().min(5).max(200),\n    description: z.string().max(1000).optional(),\n    videoUrl: z.string().url(),\n    thumbnailUrl: z.string().url().optional(),\n    platform: z.enum(['YOUTUBE', 'TIKTOK', 'INSTAGRAM', 'KWAI', 'OTHER']).default('YOUTUBE'),\n    tag: z.enum(VIDEO_TAGS).default('OUTROS'),\n    durationSeconds: z.number().min(60).max(3600).default(60),\n    minWatchSeconds: z.number().min(20).max(300).default(20),\n    budget: z.number().min(5, 'O or√ßamento m√≠nimo √© R$ 5,00'),\n    pricePerView: z.number().min(0.10).default(0.10),\n    requireLike: z.boolean().default(false),\n    requireComment: z.boolean().default(false),\n    requireSubscribe: z.boolean().default(false),\n    minScoreRequired: z.number().min(0).max(1000).default(0),\n    verifiedOnly: z.boolean().default(false),\n    paymentMethod: z.enum(['BALANCE']).default('BALANCE'),\n});\n\nexport class PromoVideosController {\n\n    /**\n     * Listar tags dispon√≠veis\n     */\n    static async getTags(c: Context) {\n        return c.json({ success: true, data: VIDEO_TAGS });\n    }\n\n    /**\n     * Listar v√≠deos dispon√≠veis para assistir (Feed)\n     */\n    static async getFeed(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const pool = getDbPool(c);\n            const tag = c.req.query('tag');\n\n            const result = await pool.query(`\n        SELECT pv.*, u.name as promoter_name,\n               (SELECT COUNT(*) FROM promo_video_views pvv WHERE pvv.video_id = pv.id AND pvv.completed = TRUE) as completed_views,\n               (pv.user_id = $1) as is_owner,\n               ROW_NUMBER() OVER (ORDER BY pv.total_views DESC, pv.price_per_view DESC) as ranking\n        FROM promo_videos pv\n        JOIN users u ON pv.user_id = u.id\n        WHERE pv.is_active = TRUE \n          AND pv.status = 'ACTIVE'\n          AND pv.budget > pv.spent\n          AND NOT EXISTS (\n              SELECT 1 FROM promo_video_views pvv \n              WHERE pvv.video_id = pv.id AND pvv.viewer_id = $1\n          )\n          ${tag ? 'AND pv.tag = $2' : ''}\n        ORDER BY pv.price_per_view DESC, pv.total_views DESC, pv.created_at DESC\n        LIMIT 50\n      `, tag ? [userPayload.id, tag] : [userPayload.id]);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(v => ({\n                    id: v.id,\n                    title: v.title,\n                    videoUrl: v.video_url,\n                    thumbnailUrl: v.thumbnail_url,\n                    platform: v.platform,\n                    tag: v.tag || 'OUTROS',\n                    pricePerView: parseFloat(v.price_per_view),\n                    durationSeconds: v.duration_seconds || 60,\n                    totalViews: parseInt(v.total_views) || 0,\n                    completedViews: parseInt(v.completed_views) || 0,\n                    minWatchSeconds: v.min_watch_seconds || 20,\n                    viewerEarningPoints: Math.floor(parseFloat(v.price_per_view) * VIEWER_SHARE * POINTS_PER_REAL),\n                    promoterName: v.promoter_name,\n                    isOwner: v.is_owner,\n                    ranking: parseInt(v.ranking),\n                    requireLike: v.require_like,\n                    requireComment: v.require_comment,\n                    requireSubscribe: v.require_subscribe\n                }))\n            });\n        } catch (error) {\n            console.error('[PROMO-VIDEOS] Erro ao buscar feed:', error);\n            return c.json({ success: false, message: 'Erro ao buscar v√≠deos' }, 500);\n        }\n    }\n\n    /**\n     * Farm: Buscar pr√≥ximo v√≠deo dispon√≠vel\n     */\n    static async getNextFarmVideo(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT pv.*, u.name as promoter_name\n        FROM promo_videos pv\n        JOIN users u ON pv.user_id = u.id\n        WHERE pv.is_active = TRUE \n          AND pv.status = 'ACTIVE'\n          AND pv.budget > pv.spent\n          AND pv.user_id != $1\n          AND NOT EXISTS (\n              SELECT 1 FROM promo_video_views pvv \n              WHERE pvv.video_id = pv.id AND pvv.viewer_id = $1\n          )\n        ORDER BY pv.price_per_view DESC, pv.created_at ASC\n        LIMIT 1\n      `, [userPayload.id]);\n\n            if (result.rows.length === 0) {\n                return c.json({\n                    success: false,\n                    message: 'Voc√™ j√° assistiu todos os v√≠deos dispon√≠veis! Volte mais tarde.',\n                    code: 'NO_VIDEOS_AVAILABLE'\n                });\n            }\n\n            const v = result.rows[0];\n            return c.json({\n                success: true,\n                data: {\n                    id: v.id,\n                    title: v.title,\n                    videoUrl: v.video_url,\n                    thumbnailUrl: v.thumbnail_url,\n                    platform: v.platform,\n                    tag: v.tag || 'OUTROS',\n                    pricePerView: parseFloat(v.price_per_view),\n                    durationSeconds: v.duration_seconds || 60,\n                    totalViews: parseInt(v.total_views) || 0,\n                    minWatchSeconds: v.min_watch_seconds || 20,\n                    viewerEarningPoints: Math.floor(parseFloat(v.price_per_view) * VIEWER_SHARE * POINTS_PER_REAL),\n                    promoterName: v.promoter_name,\n                    requireLike: v.require_like,\n                    requireComment: v.require_comment,\n                    requireSubscribe: v.require_subscribe\n                }\n            });\n        } catch (error) {\n            console.error('[FARM] Erro ao buscar pr√≥ximo v√≠deo:', error);\n            return c.json({ success: false, message: 'Erro ao processar farm' }, 500);\n        }\n    }\n\n    /**\n     * Minhas campanhas\n     */\n    static async getMyCampaigns(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        WITH ranked AS (\n            SELECT id, ROW_NUMBER() OVER (ORDER BY total_views DESC, price_per_view DESC) as global_rank\n            FROM promo_videos WHERE is_active = TRUE AND status = 'ACTIVE'\n        )\n        SELECT pv.*, \n               COALESCE(r.global_rank, 0) as ranking,\n               (SELECT COUNT(*) FROM promo_video_views pvv WHERE pvv.video_id = pv.id AND pvv.completed = TRUE) as completed_views\n        FROM promo_videos pv\n        LEFT JOIN ranked r ON pv.id = r.id\n        WHERE pv.user_id = $1 \n        ORDER BY pv.created_at DESC\n      `, [userPayload.id]);\n\n            return c.json({\n                success: true,\n                data: result.rows.map(v => ({\n                    id: v.id,\n                    title: v.title,\n                    videoUrl: v.video_url,\n                    platform: v.platform,\n                    tag: v.tag || 'OUTROS',\n                    pricePerView: parseFloat(v.price_per_view),\n                    minWatchSeconds: v.min_watch_seconds || 20,\n                    budget: parseFloat(v.budget),\n                    spent: parseFloat(v.spent),\n                    remaining: parseFloat(v.budget) - parseFloat(v.spent),\n                    totalViews: parseInt(v.total_views) || 0,\n                    completedViews: parseInt(v.completed_views) || 0,\n                    targetViews: v.target_views,\n                    status: v.status,\n                    isActive: v.is_active,\n                    ranking: parseInt(v.ranking) || null,\n                    createdAt: v.created_at,\n                    requireLike: v.require_like,\n                    requireComment: v.require_comment,\n                    requireSubscribe: v.require_subscribe\n                }))\n            });\n        } catch (error) {\n            console.error('[PROMO-VIDEOS] Erro ao buscar campanhas:', error);\n            return c.json({ success: false, message: 'Erro ao buscar campanhas' }, 500);\n        }\n    }\n\n    /**\n     * Meus ganhos assistindo v√≠deos\n     */\n    static async getMyEarnings(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT \n            COALESCE(SUM(earned), 0) as total_earned,\n            (SELECT ad_points FROM users WHERE id = $1) as current_points,\n            COUNT(*) FILTER (WHERE completed = TRUE) as videos_watched\n        FROM promo_video_views\n        WHERE viewer_id = $1\n      `, [userPayload.id]);\n\n            const { total_earned, current_points, videos_watched } = result.rows[0];\n\n            return c.json({\n                success: true,\n                data: {\n                    totalEarned: parseFloat(total_earned) || 0,\n                    currentPoints: parseInt(current_points) || 0,\n                    videosWatched: parseInt(videos_watched) || 0,\n                    conversionRate: POINTS_PER_REAL,\n                    minConversionPoints: MIN_CONVERSION_POINTS\n                }\n            });\n        } catch (error) {\n            console.error('[PROMO-VIDEOS] Erro ao buscar ganhos:', error);\n            return c.json({ success: false, message: 'Erro ao buscar ganhos' }, 500);\n        }\n    }\n\n    /**\n     * Deletar/Cancelar campanha\n     */\n    static async deleteCampaign(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const id = c.req.param('id');\n            const pool = getDbPool(c);\n\n            const checkResult = await pool.query(\n                'SELECT * FROM promo_videos WHERE id = $1 AND user_id = $2',\n                [id, userPayload.id]\n            );\n\n            if (checkResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Campanha n√£o encontrada.' }, 404);\n            }\n\n            const campaign = checkResult.rows[0];\n\n            if (campaign.status === 'PENDING') {\n                await pool.query('DELETE FROM promo_videos WHERE id = $1', [id]);\n            } else {\n                await pool.query(\n                    'UPDATE promo_videos SET is_active = FALSE, status = $1 WHERE id = $2',\n                    ['CANCELED', id]\n                );\n            }\n\n            return c.json({\n                success: true,\n                message: 'Campanha removida com sucesso.'\n            });\n        } catch (error: any) {\n            console.error('[PROMO-VIDEOS] Erro ao remover campanha:', error);\n            return c.json({ success: false, message: error.message || 'Erro ao remover campanha' }, 500);\n        }\n    }\n\n    /**\n     * Converter pontos em dinheiro - Agora centralizado no PointsService\n     */\n    static async convertPoints(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const pool = getDbPool(c);\n\n            const result = await PointsService.convertPointsToBalance(pool, userPayload.id);\n\n            if (!result.success) {\n                return c.json({ success: false, message: result.message }, 400);\n            }\n\n            return c.json({\n                success: true,\n                message: `Sucesso! R$ ${result.data?.convertedAmount.toFixed(2)} adicionados ao seu saldo.`,\n                data: result.data\n            });\n        } catch (error: any) {\n            console.error('[PROMO-VIDEOS] Erro ao converter pontos:', error);\n            return c.json({ success: false, message: error.message || 'Erro ao converter pontos' }, 500);\n        }\n    }\n\n    /**\n     * Criar nova campanha\n     */\n    static async createCampaign(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const body = await c.req.json();\n            const data = createVideoSchema.parse(body);\n            const pool = getDbPool(c);\n\n            // Valida√ß√£o de Pre√ßo M√≠nimo com Adicionais\n            const minBase = 0.10;\n            const missionsPrice = (data.requireLike ? 0.02 : 0) + (data.requireComment ? 0.05 : 0) + (data.requireSubscribe ? 0.08 : 0);\n            const expectedMinPrice = minBase + missionsPrice;\n\n            if (data.pricePerView < expectedMinPrice) {\n                return c.json({ success: false, message: `Pre√ßo por view insuficiente para os adicionais selecionados. M√≠nimo: R$ ${expectedMinPrice.toFixed(2)}` }, 400);\n            }\n\n            const grossPPV = data.pricePerView;\n            const targetViews = Math.floor((data.budget / grossPPV) * 1.02); // 2% bonus views\n            const viewerPool = data.budget * VIEWER_SHARE;\n\n            // Auditoria Inicial Completa (Likes, Comments, Subs)\n            let initialStats = { likes: 0, comments: 0, subscribers: 0 };\n            if (data.platform === 'YOUTUBE') {\n                const stats = await getYouTubeFullStats(data.videoUrl);\n                if (stats) {\n                    initialStats = {\n                        likes: stats.likes,\n                        comments: stats.comments,\n                        subscribers: stats.subscribers\n                    };\n                }\n            }\n\n            const userResult = await pool.query('SELECT name, email, cpf, balance FROM users WHERE id = $1', [userPayload.id]);\n            const user = userResult.rows[0];\n\n            if (data.paymentMethod === 'BALANCE') {\n                const userBalance = parseFloat(user.balance);\n                if (userBalance < data.budget) return c.json({ success: false, message: 'Saldo insuficiente.' }, 400);\n\n                const result = await executeInTransaction(pool, async (client) => {\n                    await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [data.budget, userPayload.id]);\n\n                    const quotaShare = data.budget * QUOTA_HOLDERS_SHARE;\n                    const platformShare = data.budget * SERVICE_FEE_SHARE;\n\n                    await client.query(\n                        `UPDATE system_config SET \n                            profit_pool = profit_pool + $1, \n                            total_tax_reserve = total_tax_reserve + $2,\n                            total_operational_reserve = total_operational_reserve + $3,\n                            total_owner_profit = total_owner_profit + $4,\n                            investment_reserve = investment_reserve + $5,\n                            system_balance = system_balance + $6`,\n                        [\n                            quotaShare,\n                            platformShare * PLATFORM_FEE_TAX_SHARE,\n                            platformShare * PLATFORM_FEE_OPERATIONAL_SHARE,\n                            platformShare * PLATFORM_FEE_OWNER_SHARE,\n                            platformShare * PLATFORM_FEE_INVESTMENT_SHARE,\n                            data.budget - quotaShare\n                        ]\n                    );\n\n                    const videoResult = await client.query(`\n                        INSERT INTO promo_videos (\n                            user_id, title, description, video_url, thumbnail_url, platform, tag,\n                            duration_seconds, price_per_view, min_watch_seconds, budget, budget_gross, spent, \n                            target_views, status, is_active, is_approved,\n                            require_like, require_comment, require_subscribe,\n                            min_score_required, verified_only,\n                            external_initial_likes, external_current_likes,\n                            external_initial_comments, external_current_comments,\n                            external_initial_subscribers, external_current_subscribers\n                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 0, $13, 'ACTIVE', TRUE, TRUE, $14, $15, $16, $17, $18, $19, $19, $20, $20, $21, $21)\n                        RETURNING id\n                    `, [\n                        userPayload.id, data.title, data.description || null, data.videoUrl,\n                        data.thumbnailUrl || null, data.platform, data.tag || 'OUTROS', data.durationSeconds,\n                        grossPPV, data.minWatchSeconds || 20, viewerPool, data.budget, targetViews,\n                        data.requireLike, data.requireComment, data.requireSubscribe,\n                        data.minScoreRequired, data.verifiedOnly,\n                        initialStats.likes, initialStats.comments, initialStats.subscribers\n                    ]);\n\n                    await client.query(`\n                        INSERT INTO transactions (user_id, type, amount, description, status)\n                        VALUES ($1, 'PROMO_VIDEO_BUDGET', $2, $3, 'COMPLETED')\n                    `, [userPayload.id, -data.budget, `Campanha: ${data.title} (${targetViews} views)`]);\n\n                    return { videoId: videoResult.rows[0].id };\n                });\n\n                if (!result.success) {\n                    return c.json({ success: false, message: result.error || 'Erro ao processar cria√ß√£o da campanha.' }, 500);\n                }\n\n                return c.json({\n                    success: true,\n                    message: `Campanha ativa! Alcance: ${targetViews} views.`,\n                    data: {\n                        targetViews,\n                        viewerEarningPoints: Math.floor(grossPPV * VIEWER_SHARE * POINTS_PER_REAL),\n                        id: result.data?.videoId\n                    }\n                });\n            }\n\n            if (data.paymentMethod === 'PIX') {\n                return c.json({ success: false, message: 'Pagamento via PIX direto descontinuado. Por favor, fa√ßa um dep√≥sito e use seu saldo.' }, 400);\n            }\n\n            return c.json({ success: false, message: 'Op√ß√£o inv√°lida' }, 400);\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar in√≠cio de view\n     */\n    static async startView(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const videoId = c.req.param('videoId');\n            const body = await c.req.json();\n            const deviceFingerprint = body.deviceFingerprint || 'unknown';\n            const pool = getDbPool(c);\n\n            const videoResult = await pool.query(\n                'SELECT * FROM promo_videos WHERE id = $1 AND is_active = TRUE AND status = $2',\n                [videoId, 'ACTIVE']\n            );\n\n            if (videoResult.rows.length === 0) return c.json({ success: false, message: 'V√≠deo n√£o dispon√≠vel' }, 404);\n            const video = videoResult.rows[0];\n\n            // Verificar pr√©-requisitos\n            const userResult = await pool.query('SELECT score, is_verified FROM users WHERE id = $1', [userPayload.id]);\n            const user = userResult.rows[0];\n\n            if (video.verified_only && !user.is_verified) {\n                return c.json({ success: false, message: 'Esta campanha √© exclusiva para Membros Verificados (Selo Azul).' }, 403);\n            }\n\n            if (user.score < video.min_score_required) {\n                return c.json({ success: false, message: `Seu Score (${user.score}) √© insuficiente. Esta campanha exige no m√≠nimo ${video.min_score_required} pontos.` }, 403);\n            }\n\n            // Anti-Fazendinha\n            const deviceViewCheck = await pool.query(\n                'SELECT id FROM promo_video_views WHERE video_id = $1 AND device_fingerprint = $2',\n                [videoId, deviceFingerprint]\n            );\n            if (deviceViewCheck.rows.length > 0) {\n                return c.json({ success: false, message: 'Este aparelho j√° recebeu o b√¥nus por este v√≠deo hoje.' }, 403);\n            }\n\n            const isOwner = Number(video.user_id) === Number(userPayload.id);\n\n            if (isOwner) {\n                return c.json({\n                    success: true,\n                    data: {\n                        viewId: null,\n                        minWatchSeconds: video.min_watch_seconds,\n                        viewerEarning: 0,\n                        isOwner: true,\n                    }\n                });\n            }\n\n            const existingView = await pool.query(\n                'SELECT id FROM promo_video_views WHERE video_id = $1 AND viewer_id = $2',\n                [videoId, userPayload.id]\n            );\n            if (existingView.rows.length > 0) return c.json({ success: false, message: 'J√° assistiu' }, 400);\n\n            if (parseFloat(video.budget) <= parseFloat(video.spent)) return c.json({ success: false, message: 'Esgotado' }, 400);\n\n            const ipAddress = (c.req.header('x-forwarded-for') || '127.0.0.1').split(',')[0].trim();\n            const userAgent = c.req.header('user-agent') || 'Unknown';\n\n            const viewResult = await pool.query(`\n                INSERT INTO promo_video_views (video_id, viewer_id, ip_address, user_agent, device_fingerprint)\n                VALUES ($1, $2, $3, $4, $5)\n                RETURNING id\n            `, [videoId, userPayload.id, ipAddress, userAgent, deviceFingerprint]);\n\n            return c.json({\n                success: true,\n                data: {\n                    viewId: viewResult.rows[0].id,\n                    minWatchSeconds: video.min_watch_seconds,\n                    viewerEarningPoints: Math.floor(parseFloat(video.price_per_view) * VIEWER_SHARE * POINTS_PER_REAL),\n                    isOwner: false,\n                }\n            });\n        } catch (error) {\n            console.error('[PROMO-VIDEOS] Erro ao iniciar view:', error);\n            return c.json({ success: false, message: 'Erro ao iniciar' }, 500);\n        }\n    }\n\n    /**\n     * Completar view e receber pagamento\n     */\n    static async completeView(c: Context) {\n        try {\n            const userPayload = c.get('user');\n            const videoId = c.req.param('videoId');\n            const body = await c.req.json();\n            const watchTime = body.watchTimeSeconds || 0;\n            const pool = getDbPool(c);\n\n            const viewResult = await pool.query(`\n                SELECT pvv.*, pv.price_per_view, pv.min_watch_seconds, pv.budget, pv.spent, pv.total_views, pv.video_url, pv.require_like, pv.require_comment, pv.require_subscribe, pv.external_initial_likes, pv.external_initial_comments, pv.external_initial_subscribers, pv.status\n                FROM promo_video_views pvv\n                JOIN promo_videos pv ON pvv.video_id = pv.id\n                WHERE pvv.video_id = $1 AND pvv.viewer_id = $2 AND pvv.completed = FALSE\n            `, [videoId, userPayload.id]);\n\n            if (viewResult.rows.length === 0) return c.json({ success: false, message: 'N√£o encontrado ou j√° conclu√≠do' }, 404);\n\n            const view = viewResult.rows[0];\n            const viewerEarningAmount = parseFloat(view.price_per_view) * VIEWER_SHARE;\n            const viewerEarningPoints = Math.floor(viewerEarningAmount * POINTS_PER_REAL);\n\n            // Anti-Cheat\n            const startTime = new Date(view.started_at).getTime();\n            const now = Date.now();\n            const elapsedSeconds = (now - startTime) / 1000;\n\n            if (elapsedSeconds < (view.min_watch_seconds - 2)) {\n                return c.json({ success: false, message: 'Seguran√ßa: Voc√™ est√° assistindo r√°pido demais.' }, 400);\n            }\n\n            if (watchTime < view.min_watch_seconds) return c.json({ success: false, message: 'Tempo insuficiente capturado pelo player.' }, 400);\n\n            const missionsCompleted = body.missionsCompleted || [];\n            const liked = missionsCompleted.includes('like');\n            const commented = missionsCompleted.includes('comment');\n            const subscribed = missionsCompleted.includes('subscribe');\n\n            let missionPoints = 0;\n            if (liked) missionPoints += 5;\n            if (commented) missionPoints += 10;\n            if (subscribed) missionPoints += 15;\n\n            const isBot = body.isBot || false;\n\n            if (isBot) {\n                await pool.query('UPDATE users SET status = $1 WHERE id = $2', ['SUSPENDED', userPayload.id]);\n                return c.json({ success: false, message: 'Erro de seguran√ßa: Comportamento suspeito detectado.' }, 403);\n            }\n\n            await executeInTransaction(pool, async (client) => {\n                const viewUpdate = await client.query(`\n                    UPDATE promo_video_views SET \n                        completed = TRUE, \n                        watch_time_seconds = $1, \n                        earned = $2, \n                        finished_at = NOW(),\n                        liked = $5,\n                        commented = $6,\n                        subscribed = $7\n                    WHERE video_id = $3 AND viewer_id = $4\n                    RETURNING id\n                `, [watchTime, viewerEarningAmount, videoId, userPayload.id, liked, commented, subscribed]);\n\n                await client.query(`\n                    UPDATE promo_videos SET total_views = total_views + 1, spent = spent + $1 WHERE id = $2\n                `, [viewerEarningAmount, videoId]);\n\n                await client.query('UPDATE users SET ad_points = ad_points + $1, total_ad_points = total_ad_points + $1 WHERE id = $2', [viewerEarningPoints, userPayload.id]);\n\n                if (missionPoints > 0) {\n                    await client.query(`\n                        INSERT INTO pending_mission_rewards (user_id, video_id, view_id, points, status)\n                        VALUES ($1, $2, $3, $4, 'PENDING')\n                    `, [userPayload.id, videoId, viewUpdate.rows[0].id, missionPoints]);\n\n                    await client.query('UPDATE users SET pending_ad_points = pending_ad_points + $1, total_ad_points = total_ad_points + $1 WHERE id = $2', [missionPoints, userPayload.id]);\n                }\n\n                // Auditoria Triple-Check (A cada 20 views)\n                const currentTotalViews = parseInt(view.total_views) + 1;\n                if (currentTotalViews % 20 === 0 && (view.require_like || view.require_comment || view.require_subscribe)) {\n                    const stats = await getYouTubeFullStats(view.video_url);\n                    if (stats) {\n                        const likesTargetRes = await client.query('SELECT COUNT(*) FROM promo_video_views WHERE video_id = $1 AND liked = TRUE', [videoId]);\n                        const likesTarget = parseInt(likesTargetRes.rows[0].count);\n                        const likesGrowth = stats.likes - view.external_initial_likes;\n\n                        const commentsTargetRes = await client.query('SELECT COUNT(*) FROM promo_video_views WHERE video_id = $1 AND commented = TRUE', [videoId]);\n                        const commentsTarget = parseInt(commentsTargetRes.rows[0].count);\n                        const commentsGrowth = stats.comments - view.external_initial_comments;\n\n                        const subsTargetRes = await client.query('SELECT COUNT(*) FROM promo_video_views WHERE video_id = $1 AND subscribed = TRUE', [videoId]);\n                        const subsTarget = parseInt(subsTargetRes.rows[0].count);\n                        const subsGrowth = stats.subscribers - view.external_initial_subscribers;\n\n                        let totalWeights = 0;\n                        let successScore = 0;\n\n                        if (view.require_like && likesTarget > 0) {\n                            successScore += (likesGrowth / likesTarget) > 0.4 ? 100 : 0;\n                            totalWeights++;\n                        }\n                        if (view.require_comment && commentsTarget > 0) {\n                            successScore += (commentsGrowth / commentsTarget) > 0.4 ? 100 : 0;\n                            totalWeights++;\n                        }\n                        if (view.require_subscribe && subsTarget > 0) {\n                            successScore += (subsGrowth / subsTarget) > 0.4 ? 100 : 0;\n                            totalWeights++;\n                        }\n\n                        const finalHealth = totalWeights > 0 ? (successScore / totalWeights) : 100;\n\n                        let statusUpdate = view.status;\n                        let rejectionReason = null;\n\n                        if (finalHealth < 40) {\n                            statusUpdate = 'PAUSED';\n                            rejectionReason = 'SUSPEITA DE FRAUDE: Baixa taxa de engajamento real detectada.';\n                        }\n\n                        await client.query(`\n                            UPDATE promo_videos SET \n                                external_current_likes = $1, \n                                external_current_comments = $2,\n                                external_current_subscribers = $3,\n                                audit_health_score = $4, \n                                last_audit_at = NOW(),\n                                status = $5,\n                                rejection_reason = $6\n                            WHERE id = $7\n                        `, [stats.likes, stats.comments, stats.subscribers, finalHealth, statusUpdate, rejectionReason, videoId]);\n\n                        if (finalHealth >= 70) {\n                            const pendingToApprove = await client.query(`\n                                SELECT id, user_id, points FROM pending_mission_rewards \n                                WHERE video_id = $1 AND status = 'PENDING'\n                            `, [videoId]);\n\n                            for (const reward of pendingToApprove.rows) {\n                                await client.query('UPDATE users SET ad_points = ad_points + $1, pending_ad_points = pending_ad_points - $1 WHERE id = $2', [reward.points, reward.user_id]);\n                                await client.query('UPDATE pending_mission_rewards SET status = \\'APPROVED\\', processed_at = NOW() WHERE id = $1', [reward.id]);\n                            }\n                        }\n                    }\n                }\n            });\n\n            return c.json({ success: true, message: `Ganhou ${viewerEarningPoints} pontos!` });\n        } catch (error) {\n            console.error('[PROMO-VIDEOS] Erro ao completar view:', error);\n            return c.json({ success: false, message: 'Erro ao processar' }, 500);\n        }\n    }\n\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/quotas.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VESTING_PERIOD_MS' is defined but never used.","line":7,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"VESTING_PERIOD_MS"},"fix":{"range":[263,286],"text":""},"desc":"Remove unused variable \"VESTING_PERIOD_MS\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1123,1126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1123,1126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8140,8143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8140,8143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { AuditService, AuditActionType } from '../../../application/services/audit.service';\nimport {\n    QUOTA_PRICE,\n    VESTING_PERIOD_MS,\n    PENALTY_RATE,\n    QUOTA_SHARE_VALUE,\n    QUOTA_ADM_FEE,\n    QUOTA_FEE_TAX_SHARE,\n    QUOTA_FEE_OPERATIONAL_SHARE,\n    QUOTA_FEE_OWNER_SHARE,\n    QUOTA_FEE_INVESTMENT_SHARE,\n    QUOTA_FEE_CORPORATE_SHARE,\n    ADMIN_PIX_KEY,\n    MAX_QUOTAS_PER_USER\n} from '../../../shared/constants/business.constants';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport {\n    executeInTransaction,\n    lockUserBalance,\n    updateUserBalance,\n    createTransaction\n} from '../../../domain/services/transaction.service';\nimport { updateScore, SCORE_REWARDS } from '../../../application/services/score.service';\nimport { calculateTotalToPay, PaymentMethod } from '../../../shared/utils/financial.utils';\n\n// Fun√ß√£o auxiliar para registrar auditoria financeira\nconst logFinancialAudit = (operation: string, userId: string, details: any) => {\n    console.log(`[AUDIT_FINANCEIRA] ${operation}`, {\n        timestamp: new Date().toISOString(),\n        userId,\n        operation,\n        details: JSON.stringify(details),\n    });\n};\n\n// Esquemas de valida√ß√£o\nconst buyQuotaSchema = z.object({\n    quantity: z.number().int().positive(),\n    useBalance: z.boolean(),\n    paymentMethod: z.enum(['pix']).optional().default('pix'),\n    acceptedTerms: z.boolean().refine(val => val === true, \"Voc√™ deve ler e aceitar o Termo de Ades√£o e Ci√™ncia de Riscos.\"),\n});\n\nconst sellQuotaSchema = z.object({\n    quotaId: z.union([z.string(), z.number()]).transform((val) => String(val)),\n});\n\nexport class QuotasController {\n    /**\n     * Listar cotas do usu√°rio\n     */\n    static async listQuotas(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                'SELECT id, user_id, purchase_price, current_value, purchase_date, status FROM quotas WHERE user_id = $1',\n                [user.id]\n            );\n\n            const formattedQuotas = result.rows.map(quota => ({\n                id: quota.id,\n                userId: quota.user_id,\n                purchasePrice: parseFloat(quota.purchase_price),\n                purchaseDate: new Date(quota.purchase_date).getTime(),\n                currentValue: parseFloat(quota.current_value),\n                yieldRate: 1.001, // Taxa fixa por enquanto\n            }));\n\n            return c.json({\n                success: true,\n                data: {\n                    quotas: formattedQuotas,\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao listar cotas:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Comprar cotas\n     */\n    static async buyQuotas(c: Context) {\n        console.log('============================');\n        console.log('[QUOTAS /buy] REQUEST RECEIVED AT', new Date().toISOString());\n        console.log('============================');\n        try {\n            const body = await c.req.json();\n            console.log('[QUOTAS] Processing /buy request:', JSON.stringify({ ...body, creditCard: 'REDACTED', creditCardHolderInfo: 'REDACTED' }));\n            const { quantity, useBalance, paymentMethod } = buyQuotaSchema.parse(body);\n\n            const baseCost = quantity * QUOTA_PRICE;\n            const totalAdmFee = quantity * QUOTA_ADM_FEE;\n            const totalWithServiceFee = baseCost; // Total √© sempre 50 * quantity\n\n            const method: PaymentMethod = useBalance ? 'balance' : (paymentMethod as PaymentMethod);\n            const { total: finalCost, fee: userFee } = calculateTotalToPay(totalWithServiceFee, method);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // --- PROTE√á√ÉO ANTI-BALEIA (ANTI-WHALE) ---\n            // 1. Verificar estoque atual do usu√°rio\n            const userQuotaCountRes = await pool.query('SELECT COUNT(*) FROM quotas WHERE user_id = $1 AND status = \\'ACTIVE\\'', [user.id]);\n            const currentQuotas = parseInt(userQuotaCountRes.rows[0].count);\n\n            // 2. Bloquear se exceder o limite individual (EXCETO ADMIN)\n            if (!user.isAdmin) {\n                // VERIFICA√á√ÉO KYC (NOVA)\n                const userRes = await pool.query('SELECT is_verified, kyc_status, kyc_notes FROM users WHERE id = $1', [user.id]);\n                const userData = userRes.rows[0];\n\n                if (!userData?.is_verified) {\n                    if (userData?.kyc_status === 'PENDING') {\n                        return c.json({\n                            success: false,\n                            message: 'Sua verifica√ß√£o de identidade (KYC) est√° em an√°lise. Aguarde a aprova√ß√£o administrativa para realizar esta opera√ß√£o.'\n                        }, 403);\n                    }\n\n                    if (userData?.kyc_status === 'REJECTED') {\n                        return c.json({\n                            success: false,\n                            message: `Sua verifica√ß√£o (KYC) foi rejeitada. Motivo: ${userData.kyc_notes}. Por favor, contate o suporte.`\n                        }, 403);\n                    }\n\n                    return c.json({\n                        success: false,\n                        message: 'Esta opera√ß√£o exige valida√ß√£o de seguran√ßa (KYC). Por favor, envie seus documentos no menu lateral.'\n                    }, 403);\n                }\n\n                if (currentQuotas + quantity > MAX_QUOTAS_PER_USER) {\n                    return c.json({\n                        success: false,\n                        message: `Prote√ß√£o Anti-Concentra√ß√£o Ativa: O limite por associado √© de ${MAX_QUOTAS_PER_USER} cotas. Voc√™ j√° possui ${currentQuotas} e tentou comprar mais ${quantity}.`\n                    }, 403); // Forbidden\n                }\n            } else {\n                console.log(`[QUOTAS] üõ°Ô∏è ADMIN BYPASS ACTIVATED: User ${user.email} ignoring Anti-Whale limits.`);\n            }\n\n            // 3. Travas de Volume por Opera√ß√£o (EXCETO ADMIN)\n            if (!user.isAdmin) {\n                if (quantity > 200) { // Trava hardcode operacional (ex: 10k reais)\n                    return c.json({\n                        success: false,\n                        message: 'Volume alto detectado. Para aportes acima de 200 cotas, entre em contato com a administra√ß√£o para KYC refor√ßado.'\n                    }, 400);\n                }\n            }\n\n            // Validar limites antigos (podem ser relaxados se a trava anti-baleia for confi√°vel, mas vamos manter por redund√¢ncia)\n            /*\n            if (quantity > 20) {\n                 // Removido limite de 20 para permitir investidores maiores (at√© o teto da baleia), mas mantendo a l√≥gica Anti-Whale global\n            }\n            */\n\n            /*\n           if (baseCost > 1000) {\n                // Removido tamb√©m\n           }\n            */\n\n\n            const result = await executeInTransaction(pool, async (client) => {\n                console.log(`[QUOTAS] Initiating transaction for user ${user.id}, paymentMethod: ${paymentMethod}`);\n\n                if (useBalance) {\n                    // BYPASS DE SEGURAN√áA: Permitir compra de cotas mesmo com trava de saque (Lock 48h), \n                    // pois investir trava o dinheiro no sistema (Vesting) e √© seguro.\n                    const balanceCheck = await lockUserBalance(client, user.id, totalWithServiceFee, { skipLockCheck: true });\n                    if (!balanceCheck.success) {\n                        throw new Error(balanceCheck.error);\n                    }\n\n                    const updateResult = await updateUserBalance(client, user.id, totalWithServiceFee, 'debit');\n                    if (!updateResult.success) {\n                        throw new Error(updateResult.error);\n                    }\n\n                    const values: any[] = [];\n                    const placeholders: string[] = [];\n                    let pIndex = 1;\n                    const now = new Date();\n\n                    for (let i = 0; i < quantity; i++) {\n                        placeholders.push(`($${pIndex++}, $${pIndex++}, $${pIndex++}, $${pIndex++}, 'ACTIVE')`);\n                        values.push(user.id, QUOTA_PRICE, QUOTA_SHARE_VALUE, now);\n                    }\n\n                    await client.query(\n                        `INSERT INTO quotas (user_id, purchase_price, current_value, purchase_date, status)\n             VALUES ${placeholders.join(', ')}`,\n                        values\n                    );\n\n                    const transactionResult = await createTransaction(\n                        client,\n                        user.id,\n                        'BUY_QUOTA',\n                        totalWithServiceFee,\n                        `Aquisi√ß√£o de ${quantity} participa√ß√£o(√µes) (+ R$ ${totalAdmFee.toFixed(2)} manuten√ß√£o) - APROVADA`,\n                        'APPROVED',\n                        {\n                            quantity,\n                            useBalance,\n                            paymentMethod: 'balance',\n                            serviceFee: totalAdmFee,\n                            legal_context: {\n                                accepted_at: new Date().toISOString(),\n                                accepted_terms: true,\n                                ip_address: c.req.header('x-forwarded-for') || '127.0.0.1',\n                                user_agent: c.req.header('user-agent') || 'Unknown',\n                                contract_version: 'QUOTA_AGREEMENT_V1'\n                            }\n                        }\n                    );\n\n                    if (!transactionResult.success) {\n                        throw new Error(transactionResult.error);\n                    }\n\n                    const currentUserRes = await client.query('SELECT referred_by FROM users WHERE id = $1', [user.id]);\n                    const referredByCode = currentUserRes.rows[0]?.referred_by;\n\n                    if (referredByCode) {\n                        console.log(`[REFERRAL] Usu√°rio ${user.id} foi indicado pelo padrinho ${referredByCode}.`);\n\n                        // Verificar se o padrinho j√° recebeu o b√¥nus de indica√ß√£o ativa para este usu√°rio\n                        const bonusCheck = await client.query(\n                            \"SELECT id FROM transactions WHERE user_id = $1 AND type = 'REFERRAL_BONUS' AND metadata->>'referredUserId' = $2\",\n                            [referredByCode, user.id]\n                        );\n\n                        if (bonusCheck.rows.length === 0) {\n                            // Conceder b√¥nus de Score ao padrinho\n                            await updateScore(client, referredByCode, SCORE_REWARDS.REFERRAL_ACTIVE_USER, `B√¥nus: Indica√ß√£o Ativa (Usu√°rio ${user.id} adquiriu cotas)`);\n\n                            // Registrar transa√ß√£o de b√¥nus (hist√≥rico)\n                            await createTransaction(\n                                client,\n                                referredByCode,\n                                'REFERRAL_BONUS',\n                                0,\n                                `B√¥nus de Indica√ß√£o Ativa: Associado ${user.name.split(' ')[0]} adquiriu participa√ß√µes`,\n                                'APPROVED',\n                                { referredUserId: user.id, points: SCORE_REWARDS.REFERRAL_ACTIVE_USER }\n                            );\n\n                            console.log(`[REFERRAL] Padrinho ${referredByCode} recompensado com ${SCORE_REWARDS.REFERRAL_ACTIVE_USER} pontos de Score.`);\n                        }\n                    }\n\n                    await updateScore(client, user.id, SCORE_REWARDS.QUOTA_PURCHASE * quantity, `Aquisi√ß√£o de ${quantity} participa√ß√µes`);\n\n                    const taxAmount = totalAdmFee * QUOTA_FEE_TAX_SHARE;\n                    const operationalAmount = totalAdmFee * QUOTA_FEE_OPERATIONAL_SHARE;\n                    const ownerAmount = totalAdmFee * QUOTA_FEE_OWNER_SHARE;\n                    const stabilityAmount = totalAdmFee * QUOTA_FEE_INVESTMENT_SHARE;\n                    const corporateAmount = totalAdmFee * QUOTA_FEE_CORPORATE_SHARE;\n                    const principalAmount = quantity * QUOTA_SHARE_VALUE; // R$ 42 por cota\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            total_tax_reserve = total_tax_reserve + $1,\n                            total_operational_reserve = total_operational_reserve + $2,\n                            total_owner_profit = total_owner_profit + $3,\n                            mutual_reserve = COALESCE(mutual_reserve, 0) + $4,\n                            total_corporate_investment_reserve = COALESCE(total_corporate_investment_reserve, 0) + $5,\n                            investment_reserve = COALESCE(investment_reserve, 0) + $6,\n                            system_balance = COALESCE(system_balance, 0) + $7\n                    `, [taxAmount, operationalAmount, ownerAmount, stabilityAmount, corporateAmount, principalAmount, baseCost]);\n\n                    // AUDITORIA FINTECH\n                    try {\n                        const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n                        const userAgent = c.req.header('user-agent') || 'Unknown';\n                        // Executar fora da transa√ß√£o principal se poss√≠vel, ou dentro (aqui √© dentro do callback)\n                        // Como AuditService usa pool, podemos passar client\n                        await AuditService.logSensitiveAction(client, user.id, AuditActionType.BUY_QUOTA, {\n                            quantity,\n                            totalCost: baseCost,\n                            useBalance: true,\n                            userAgent\n                        }, ip);\n                    } catch (auditError) {\n                        console.error('Falha n√£o-bloqueante de auditoria:', auditError);\n                    }\n\n                    return {\n                        transactionId: transactionResult.transactionId,\n                        cost: baseCost,\n                        quantity,\n                        immediateApproval: true\n                    };\n                } else {\n                    const external_reference = `BUY_QUOTA_${user.id}_${Date.now()}`;\n\n                    const transactionResult = await createTransaction(\n                        client,\n                        user.id,\n                        'BUY_QUOTA',\n                        finalCost,\n                        `Aquisi√ß√£o de ${quantity} participa√ß√£o(√µes) - Aguardando PIX Manual`,\n                        'PENDING',\n                        {\n                            quantity,\n                            useBalance,\n                            paymentMethod: 'pix',\n                            external_reference,\n                            baseCost,\n                            userFee,\n                            manualPix: true,\n                            legal_context: {\n                                accepted_at: new Date().toISOString(),\n                                accepted_terms: true,\n                                ip_address: c.req.header('x-forwarded-for') || '127.0.0.1',\n                                user_agent: c.req.header('user-agent') || 'Unknown',\n                                contract_version: 'QUOTA_AGREEMENT_V1'\n                            }\n                        }\n                    );\n\n                    if (!transactionResult.success) {\n                        throw new Error(transactionResult.error);\n                    }\n\n                    return {\n                        transactionId: transactionResult.transactionId,\n                        cost: baseCost,\n                        finalCost: finalCost,\n                        userFee: userFee,\n                        quantity,\n                        immediateApproval: false,\n                        pixData: null,\n                        manualPix: {\n                            key: ADMIN_PIX_KEY,\n                            owner: 'Cred30',\n                            description: `Transferir R$ ${finalCost.toFixed(2)} para ativar ${quantity} participa√ß√µes`\n                        }\n                    };\n                }\n            });\n\n            if (!result.success) {\n                return c.json({\n                    success: false,\n                    message: result.error\n                }, 400);\n            }\n\n            const message = result.data?.immediateApproval\n                ? `Aquisi√ß√£o de ${result.data?.quantity} participa√ß√£o(√µes) aprovada imediatamente!`\n                : 'Solicita√ß√£o de participa√ß√£o enviada! Aguarde a confirma√ß√£o do Clube.';\n\n            return c.json({\n                success: true,\n                message,\n                data: {\n                    transactionId: result.data?.transactionId,\n                    cost: result.data?.cost,\n                    finalCost: result.data?.finalCost,\n                    userFee: result.data?.userFee,\n                    quantity: result.data?.quantity,\n                    immediateApproval: result.data?.immediateApproval,\n                    pixData: result.data?.pixData,\n                    manualPix: result.data?.manualPix\n                },\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            return c.json({\n                success: false,\n                message: error instanceof Error ? error.message : 'Erro interno do servidor'\n            }, 500);\n        }\n    }\n\n    /**\n     * Vender uma cota\n     */\n    static async sellQuota(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { quotaId } = sellQuotaSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Verificar se o usu√°rio tem empr√©stimos ativos OU √© fiador\n            const activeLoansResult = await pool.query(\n                \"SELECT COUNT(*) FROM loans WHERE (user_id = $1 OR metadata->>'guarantorId' = $1) AND status IN ('PENDING', 'APPROVED', 'PAYMENT_PENDING')\",\n                [user.id]\n            );\n\n            const activeLoans = parseInt(activeLoansResult.rows[0].count);\n\n            if (activeLoans > 0) {\n                return c.json({\n                    success: false,\n                    message: 'Opera√ß√£o bloqueada: Voc√™ possui compromissos ativos. Quite seus d√©bitos antes de ceder participa√ß√µes.'\n                }, 400);\n            }\n\n            // Buscar cota\n            const quotaResult = await pool.query(\n                'SELECT * FROM quotas WHERE id = $1 AND user_id = $2',\n                [quotaId, user.id]\n            );\n\n            if (quotaResult.rows.length === 0) {\n                return c.json({ success: false, message: 'Participa√ß√£o n√£o encontrada' }, 404);\n            }\n\n            const quota = quotaResult.rows[0];\n\n            // Verificar marketplace\n            const listingCheck = await pool.query(\n                \"SELECT id FROM marketplace_listings WHERE quota_id = $1 AND status = 'ACTIVE'\",\n                [quotaId]\n            );\n\n            if (listingCheck.rows.length > 0) {\n                return c.json({\n                    success: false,\n                    message: 'Esta cota est√° sendo negociada no Mercado Cred30. Remova o an√∫ncio antes de solicitar o resgate direto.'\n                }, 400);\n            }\n\n            // Nova L√≥gica: Libera√ß√£o anual a partir de 21 de Dezembro\n            const now = new Date();\n            const currentYear = now.getFullYear();\n            const releaseDate = new Date(currentYear, 11, 21); // 21 de Dezembro\n\n            // Liberado se hoje for >= 21 de Dezembro\n            const hasSeniority = now.getTime() >= releaseDate.getTime();\n            const isEarlyExit = !hasSeniority;\n\n            const originalAmount = parseFloat(quota.purchase_price);\n            let finalAmount = originalAmount;\n            let penaltyAmount = 0;\n            let profitAmount = 0;\n\n            if (isEarlyExit) {\n                penaltyAmount = originalAmount * PENALTY_RATE;\n                finalAmount = originalAmount - penaltyAmount;\n                profitAmount = penaltyAmount;\n            }\n\n            const systemStateBefore = await pool.query(`\n        SELECT\n          (SELECT COALESCE(system_balance, 0) FROM system_config LIMIT 1) as system_balance,\n          (SELECT COALESCE(profit_pool, 0) FROM system_config LIMIT 1) as profit_pool,\n          0 as operational_cash\n      `);\n\n            const auditBefore = {\n                quotaId,\n                originalAmount,\n                penaltyAmount,\n                finalAmount,\n                profitAmount,\n                isEarlyExit,\n                systemBalance: systemStateBefore.rows[0]?.system_balance,\n                profitPool: systemStateBefore.rows[0]?.profit_pool,\n                operationalCash: systemStateBefore.rows[0]?.operational_cash\n            };\n            logFinancialAudit('VENDA_COTA_ANTES', user.id, auditBefore);\n\n            const txResult = await executeInTransaction(pool, async (client) => {\n                console.log(`[SELL_QUOTA] Starting transaction for user ${user.id}, quotaId: ${quotaId}, finalAmount: ${finalAmount}`);\n\n                // VERIFICA√á√ÉO DE LIQUIDEZ (TRAVA DE SEGURAN√áA)\n                const liquidityCheck = await client.query('SELECT investment_reserve FROM system_config LIMIT 1 FOR UPDATE');\n                const availableLiquidity = parseFloat(liquidityCheck.rows[0]?.investment_reserve || '0');\n\n                if (availableLiquidity < finalAmount) {\n                    throw new Error('Liquidez momentaneamente indispon√≠vel. Seu capital est√° investido em empr√©stimos ativos. Tente novamente em breve.');\n                }\n\n                const deleteResult = await client.query(\n                    'DELETE FROM quotas WHERE id = $1 AND user_id = $2 RETURNING id',\n                    [quotaId, user.id]\n                );\n\n                if (deleteResult.rowCount === 0) {\n                    throw new Error('Falha ao remover a participa√ß√£o - n√£o encontrada');\n                }\n\n                const updateResult = await client.query(\n                    'UPDATE users SET balance = balance + $1 WHERE id = $2 RETURNING balance',\n                    [finalAmount, user.id]\n                );\n\n                if (updateResult.rowCount === 0) {\n                    throw new Error('Falha ao atualizar saldo do usu√°rio');\n                }\n\n                // DISTRIBUI√á√ÉO DA MULTA DE RESGATE (PENALTY)\n                // 80% para o Sistema (Gestora) e 20% para os Cotistas (Profit Pool)\n                if (profitAmount > 0) {\n                    const profitPoolShare = profitAmount * 0.20;\n                    const systemShare = profitAmount * 0.80;\n\n                    // System Share dividido nas reservas\n                    const taxPart = systemShare * QUOTA_FEE_TAX_SHARE;\n                    const operPart = systemShare * QUOTA_FEE_OPERATIONAL_SHARE;\n                    const ownerPart = systemShare * QUOTA_FEE_OWNER_SHARE;\n                    const investPart = systemShare * QUOTA_FEE_INVESTMENT_SHARE;\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            profit_pool = profit_pool + $1,\n                            total_tax_reserve = total_tax_reserve + $2,\n                            total_operational_reserve = total_operational_reserve + $3,\n                            total_owner_profit = total_owner_profit + $4,\n                            investment_reserve = COALESCE(investment_reserve, 0) + $5\n                        `, [profitPoolShare, taxPart, operPart, ownerPart, investPart]\n                    );\n                }\n\n                // Decrementar do Investment Reserve o valor principal pago ao usu√°rio\n                // Isso garante controle da liquidez\n                await client.query('UPDATE system_config SET investment_reserve = investment_reserve - $1', [finalAmount]);\n\n                await client.query(\n                    `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n           VALUES ($1, 'SELL_QUOTA', $2, $3, 'APPROVED', $4)`,\n                    [\n                        user.id,\n                        finalAmount,\n                        `Cess√£o de participa√ß√£o ${isEarlyExit ? '(Multa 40%)' : '(Integral)'}`,\n                        JSON.stringify({\n                            originalAmount,\n                            penaltyAmount: isEarlyExit ? penaltyAmount : 0,\n                            profitAmount: isEarlyExit ? penaltyAmount : 0,\n                            isEarlyExit,\n                            note: isEarlyExit ? 'Multa de 40% aplicada (direcionada para lucro de juros)' : 'Cess√£o integral sem penalidade'\n                        })\n                    ]\n                );\n\n                return { newBalance: updateResult.rows[0].balance };\n            });\n\n            if (!txResult.success) {\n                return c.json({\n                    success: false,\n                    message: txResult.error || 'Erro ao processar cess√£o de participa√ß√£o'\n                }, 500);\n            }\n\n            const systemStateAfter = await pool.query(`\n        SELECT\n          (SELECT COALESCE(system_balance, 0) FROM system_config LIMIT 1) as system_balance,\n          (SELECT COALESCE(profit_pool, 0) FROM system_config LIMIT 1) as profit_pool,\n          0 as operational_cash\n      `);\n\n            const auditAfter = {\n                ...auditBefore,\n                newSystemBalance: systemStateAfter.rows[0]?.system_balance,\n                newProfitPool: systemStateAfter.rows[0]?.profit_pool,\n                newOperationalCash: systemStateAfter.rows[0]?.operational_cash\n            };\n            logFinancialAudit('VENDA_COTA_APOS', user.id, auditAfter);\n\n            // AUDITORIA FINTECH\n            try {\n                const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n                const userAgent = c.req.header('user-agent') || 'Unknown';\n                await AuditService.logSensitiveAction(pool, user.id, AuditActionType.SELL_QUOTA, {\n                    quotaId,\n                    finalAmount,\n                    userAgent\n                }, ip);\n            } catch (error) { console.error('Audit Error', error); }\n\n            return c.json({\n                success: true,\n                message: 'Participa√ß√£o cedida com sucesso! Valor creditado no saldo.',\n                data: {\n                    finalAmount,\n                    penaltyAmount: isEarlyExit ? penaltyAmount : 0,\n                },\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            console.error('Erro ao vender cota:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Vender todas as cotas\n     */\n    static async sellAllQuotas(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const activeLoansResult = await pool.query(\n                \"SELECT COUNT(*) FROM loans WHERE (user_id = $1 OR metadata->>'guarantorId' = $1) AND status IN ('PENDING', 'APPROVED', 'PAYMENT_PENDING')\",\n                [user.id]\n            );\n\n            const activeLoans = parseInt(activeLoansResult.rows[0].count);\n\n            if (activeLoans > 0) {\n                return c.json({\n                    success: false,\n                    message: 'Opera√ß√£o bloqueada: Voc√™ possui compromissos ativos. Quite seus d√©bitos antes de ceder participa√ß√µes.'\n                }, 400);\n            }\n\n            const userQuotasResult = await pool.query(\n                'SELECT * FROM quotas WHERE user_id = $1',\n                [user.id]\n            );\n\n            const userQuotas = userQuotasResult.rows;\n\n            if (userQuotas.length === 0) {\n                return c.json({ success: false, message: 'Voc√™ n√£o possui participa√ß√µes para cess√£o' }, 400);\n            }\n\n            // Nova L√≥gica: Libera√ß√£o anual a partir de 21 de Dezembro\n            const now = new Date();\n            const currentYear = now.getFullYear();\n            const releaseDate = new Date(currentYear, 11, 21); // 21 de Dezembro\n\n            const hasSeniority = now.getTime() >= releaseDate.getTime();\n\n            let totalReceived = 0;\n            let totalPenalty = 0;\n\n            for (const quota of userQuotas) {\n                const originalAmount = parseFloat(quota.purchase_price);\n                let amount = originalAmount;\n                let penalty = 0;\n\n                if (!hasSeniority) {\n                    penalty = originalAmount * PENALTY_RATE;\n                    amount = originalAmount - penalty;\n                    totalPenalty += penalty;\n                }\n\n                totalReceived += amount;\n            }\n\n            const systemStateBefore = await pool.query(`\n        SELECT\n          (SELECT COALESCE(system_balance, 0) FROM system_config LIMIT 1) as system_balance,\n          (SELECT COALESCE(profit_pool, 0) FROM system_config LIMIT 1) as profit_pool,\n          0 as operational_cash\n      `);\n\n            const auditBefore = {\n                totalReceived,\n                totalPenalty,\n                quotasSold: userQuotas.length,\n                hasEarlyExit: totalPenalty > 0,\n                systemBalance: systemStateBefore.rows[0]?.system_balance,\n                profitPool: systemStateBefore.rows[0]?.profit_pool,\n                operationalCash: systemStateBefore.rows[0]?.operational_cash\n            };\n            logFinancialAudit('VENDA_TODAS_COTAS_ANTES', user.id, auditBefore);\n\n            await executeInTransaction(pool, async (client) => {\n                // VERIFICA√á√ÉO DE LIQUIDEZ (TRAVA DE SEGURAN√áA)\n                const liquidityCheck = await client.query('SELECT investment_reserve FROM system_config LIMIT 1 FOR UPDATE');\n                const availableLiquidity = parseFloat(liquidityCheck.rows[0]?.investment_reserve || '0');\n\n                if (availableLiquidity < totalReceived) {\n                    throw new Error('Liquidez momentaneamente indispon√≠vel. Seu capital est√° investido em empr√©stimos ativos. Tente novamente em breve.');\n                }\n\n                await client.query(\n                    'DELETE FROM quotas WHERE user_id = $1',\n                    [user.id]\n                );\n\n                await client.query(\n                    'UPDATE users SET balance = balance + $1 WHERE id = $2',\n                    [totalReceived, user.id]\n                );\n\n                // DISTRIBUI√á√ÉO DA MULTA DE RESGATE (PENALTY) - SELL ALL\n                // 80% para o Sistema (Gestora) e 20% para os Cotistas (Profit Pool)\n                // DISTRIBUI√á√ÉO DA MULTA DE RESGATE (PENALTY) - SELL ALL\n                // 80% para o Sistema (Gestora) e 20% para os Cotistas (Profit Pool)\n                if (totalPenalty > 0) {\n                    const profitPoolShare = totalPenalty * 0.20;\n                    const systemShare = totalPenalty * 0.80;\n\n                    // System Share dividido nas reservas\n                    const taxPart = systemShare * QUOTA_FEE_TAX_SHARE;\n                    const operPart = systemShare * QUOTA_FEE_OPERATIONAL_SHARE;\n                    const ownerPart = systemShare * QUOTA_FEE_OWNER_SHARE;\n                    const investPart = systemShare * QUOTA_FEE_INVESTMENT_SHARE;\n\n                    await client.query(`\n                        UPDATE system_config SET \n                            profit_pool = profit_pool + $1,\n                            total_tax_reserve = total_tax_reserve + $2,\n                            total_operational_reserve = total_operational_reserve + $3,\n                            total_owner_profit = total_owner_profit + $4,\n                            investment_reserve = COALESCE(investment_reserve, 0) + $5\n                        `, [profitPoolShare, taxPart, operPart, ownerPart, investPart]\n                    );\n                }\n\n                // Decrementar Liquidez Paga\n                await client.query('UPDATE system_config SET investment_reserve = investment_reserve - $1', [totalReceived]);\n\n                await client.query(\n                    `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n           VALUES ($1, 'SELL_QUOTA', $2, $3, 'APPROVED', $4)`,\n                    [\n                        user.id,\n                        totalReceived,\n                        'Resgate total de licen√ßas',\n                        JSON.stringify({\n                            totalPenalty,\n                            totalProfit: 0,\n                            quotasSold: userQuotas.length,\n                            hasEarlyExit: totalPenalty > 0,\n                            note: totalPenalty > 0 ? 'Multas aplicadas (penalidade, n√£o lucro)' : 'Resgate integral sem penalidade'\n                        })\n                    ]\n                );\n            });\n\n            const systemStateAfter = await pool.query(`\n        SELECT\n          (SELECT COALESCE(system_balance, 0) FROM system_config LIMIT 1) as system_balance,\n          (SELECT COALESCE(profit_pool, 0) FROM system_config LIMIT 1) as profit_pool,\n          0 as operational_cash\n      `);\n\n            const auditAfter = {\n                ...auditBefore,\n                newSystemBalance: systemStateAfter.rows[0]?.system_balance,\n                newProfitPool: systemStateAfter.rows[0]?.profit_pool,\n                newOperationalCash: systemStateAfter.rows[0]?.operational_cash\n            };\n            logFinancialAudit('VENDA_TODAS_COTAS_APOS', user.id, auditAfter);\n\n            // AUDITORIA FINTECH\n            try {\n                const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n                const userAgent = c.req.header('user-agent') || 'Unknown';\n                await AuditService.logSensitiveAction(pool, user.id, AuditActionType.SELL_QUOTA, {\n                    action: 'SELL_ALL',\n                    totalReceived,\n                    userAgent\n                }, ip);\n            } catch (error) { console.error('Audit Error', error); }\n\n            return c.json({\n                success: true,\n                message: `Resgate total realizado! R$ ${totalReceived.toFixed(2)} creditados.`,\n                data: {\n                    totalReceived,\n                    totalPenalty,\n                    quotasSold: userQuotas.length,\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao vender todas as cotas:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/seller.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1620,1623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1620,1623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7475,7478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7475,7478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8721,8724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8721,8724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9875,9878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9875,9878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport class SellerController {\n    /**\n     * Verificar status do vendedor\n     */\n    static async getStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT is_seller, seller_status, seller_company_name,\n                 merchant_name, restaurant_category, opening_hours, is_restaurant, is_liquor_store, is_paused \n                 FROM users WHERE id = $1`,\n                [user.id]\n            );\n\n            const userData = result.rows[0];\n\n            return c.json({\n                success: true,\n                isSeller: userData?.is_seller || false,\n                status: userData?.seller_status || null,\n                // hasWallet agora √© derivado de is_seller + seller_status approved\n                hasWallet: userData?.is_seller && userData?.seller_status === 'approved',\n                companyName: userData?.seller_company_name || null,\n                merchantName: userData?.merchant_name || null,\n                restaurantCategory: userData?.restaurant_category || null,\n                openingHours: userData?.opening_hours || null,\n                isRestaurant: userData?.is_restaurant || false,\n                isLiquorStore: userData?.is_liquor_store || false,\n                isPaused: userData?.is_paused || false\n            });\n        } catch (error: any) {\n            console.error('[SELLER] Erro ao buscar status:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Registrar como vendedor\n     */\n    /**\n     * Registrar como vendedor\n     */\n    static async registerSeller(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n\n            const {\n                type, // 'PF' | 'PJ'\n                companyName,\n                cpfCnpj,\n                mobilePhone,\n                address,\n                addressNumber,\n                neighborhood,\n                city,\n                state,\n                postalCode,\n                companyType // 'INDIVIDUAL' | 'MEI' | 'ME' | 'LTDA' | 'SA' | 'EIRELI'\n            } = body;\n\n            // Valida√ß√£o de Campos B√°sicos\n            if (!type || !cpfCnpj || !mobilePhone || !address || !city || !state || !postalCode) {\n                return c.json({\n                    success: false,\n                    message: 'Preencha todos os campos obrigat√≥rios'\n                }, 400);\n            }\n\n            // Normalizar Documento (apenas n√∫meros)\n            const cleanDoc = cpfCnpj.replace(/\\D/g, '');\n\n            // Valida√ß√£o PF vs PJ\n            let finalCompanyName = companyName;\n\n            if (type === 'PF') {\n                if (cleanDoc.length !== 11) return c.json({ success: false, message: 'CPF deve ter 11 d√≠gitos.' }, 400);\n                if (!companyName) {\n                    // Para PF, se n√£o informar nome fantasia, usa o nome do usu√°rio\n                    const userRes = await pool.query('SELECT name FROM users WHERE id = $1', [user.id]);\n                    finalCompanyName = userRes.rows[0]?.name;\n                }\n            } else if (type === 'PJ') {\n                if (cleanDoc.length !== 14) return c.json({ success: false, message: 'CNPJ deve ter 14 d√≠gitos.' }, 400);\n                if (!companyName) return c.json({ success: false, message: 'Nome da Empresa √© obrigat√≥rio para PJ.' }, 400);\n                // Validar tipo de empresa para PJ\n                if (!companyType || !['MEI', 'ME', 'LTDA', 'SA', 'EIRELI'].includes(companyType)) {\n                    return c.json({ success: false, message: 'Tipo de empresa √© obrigat√≥rio para PJ (MEI, ME, LTDA, SA ou EIRELI).' }, 400);\n                }\n            } else {\n                return c.json({ success: false, message: 'Tipo de conta inv√°lido (Use PF ou PJ).' }, 400);\n            }\n\n            // Determinar o tipo de empresa final (INDIVIDUAL para PF, ou o tipo informado para PJ)\n            const finalCompanyType = type === 'PF' ? 'INDIVIDUAL' : companyType;\n\n            // Checar duplicidade de Vendedor (Trava de Unicidade)\n            const uniqueCheck = await pool.query(\n                'SELECT id FROM users WHERE seller_cpf_cnpj = $1 AND id != $2',\n                [cleanDoc, user.id]\n            );\n\n            if (uniqueCheck.rows.length > 0) {\n                return c.json({\n                    success: false,\n                    message: 'Este CPF/CNPJ j√° est√° cadastrado em outra conta de vendedor.'\n                }, 409);\n            }\n\n            const existingCheck = await pool.query(\n                `SELECT is_seller, seller_status, score FROM users WHERE id = $1`,\n                [user.id]\n            );\n\n            // Permitir re-registro se o status for inv√°lido ('none', null) para corrigir contas bugadas\n            if (existingCheck.rows[0]?.is_seller) {\n                const currentStatus = existingCheck.rows[0]?.seller_status;\n                if (currentStatus === 'approved' || currentStatus === 'pending') {\n                    return c.json({\n                        success: false,\n                        message: 'Voc√™ j√° √© um vendedor registrado'\n                    }, 400);\n                }\n            }\n\n            if ((existingCheck.rows[0]?.score || 0) < 0) {\n                return c.json({\n                    success: false,\n                    message: 'Score insuficiente. Voc√™ precisa de no m√≠nimo 300 pontos de Score (obtidos via investimentos/compras) para abrir uma loja.'\n                }, 403);\n            }\n\n            await pool.query(\n                `UPDATE users SET \n                    is_seller = TRUE,\n                    seller_status = 'approved',\n                    seller_company_name = $1,\n                    seller_cpf_cnpj = $2,\n                    seller_phone = $3,\n                    seller_address_street = $4,\n                    seller_address_number = $5,\n                    seller_address_neighborhood = $6,\n                    seller_address_city = $7,\n                    seller_address_state = $8,\n                    seller_address_postal_code = $9,\n                    seller_company_type = $10,\n                    seller_created_at = CURRENT_TIMESTAMP\n                 WHERE id = $11`,\n                [\n                    finalCompanyName,\n                    cleanDoc,\n                    mobilePhone,\n                    address,\n                    addressNumber || 'S/N',\n                    neighborhood || 'Centro',\n                    city,\n                    state,\n                    postalCode,\n                    finalCompanyType, // INDIVIDUAL, MEI, ME, LTDA, etc\n                    user.id\n                ]\n            );\n\n            return c.json({\n                success: true,\n                message: 'Conta de vendedor criada com sucesso! Os pagamentos ser√£o processados manualmente.',\n                seller: {\n                    status: 'approved',\n                    type: type, // Retorna o tipo registrado\n                    paymentMethod: 'MANUAL_PIX'\n                }\n            });\n        } catch (error: any) {\n            console.error('[SELLER] Erro ao registrar vendedor:', error);\n            return c.json({\n                success: false,\n                message: error.message || 'Erro ao criar conta de vendedor'\n            }, 500);\n        }\n    }\n\n    /**\n     * Verificar se vendedor est√° aprovado (usado internamente pelo sistema)\n     */\n    static async getWallet(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT is_seller, seller_status, pix_key FROM users WHERE id = $1 AND is_seller = TRUE`,\n                [user.id]\n            );\n\n            if (!result.rows[0] || result.rows[0].seller_status !== 'approved') {\n                return c.json({\n                    success: false,\n                    message: 'Voc√™ n√£o √© um vendedor aprovado'\n                }, 404);\n            }\n\n            return c.json({\n                success: true,\n                // Retornamos o pix_key do usu√°rio como \"wallet\" para pagamentos manuais\n                walletId: result.rows[0].pix_key || 'MANUAL_PAYMENT',\n                paymentMethod: 'MANUAL_PIX'\n            });\n        } catch (error: any) {\n            console.error('[SELLER] Erro ao buscar wallet:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Verificar se um vendedor espec√≠fico est√° aprovado\n     */\n    static async getSellerWalletById(c: Context) {\n        try {\n            const sellerId = c.req.param('userId');\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT is_seller, seller_status, seller_company_name, pix_key FROM users \n                 WHERE id = $1 AND is_seller = TRUE AND seller_status = 'approved'`,\n                [sellerId]\n            );\n\n            if (!result.rows[0]) {\n                return c.json({\n                    success: false,\n                    message: 'Vendedor n√£o encontrado ou n√£o aprovado'\n                }, 404);\n            }\n\n            return c.json({\n                success: true,\n                walletId: result.rows[0].pix_key || 'MANUAL_PAYMENT',\n                sellerName: result.rows[0].seller_company_name,\n                paymentMethod: 'MANUAL_PIX'\n            });\n        } catch (error: any) {\n            console.error('[SELLER] Erro ao buscar wallet do vendedor:', error);\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/terms.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/transactions.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalQuotaValue' is assigned a value but never used.","line":118,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":34},{"ruleId":"prefer-const","severity":2,"message":"'fee' is never reassigned. Use 'const' instead.","line":120,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":120,"endColumn":20,"fix":{"range":[4638,4653],"text":"const fee = 3.50;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9435,9438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9435,9438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { executeInTransaction, lockUserBalance, updateUserBalance, createTransaction } from '../../../domain/services/transaction.service';\nimport { checkLiquidity } from '../../../application/services/liquidity.service';\n\n// Esquemas de valida√ß√£o\nconst withdrawSchema = z.object({\n    amount: z.number().positive(),\n    pixKey: z.string().min(5),\n});\n\nconst reviewSchema = z.object({\n    transactionId: z.number().int().positive(),\n    rating: z.number().int().min(1).max(5),\n    comment: z.string().max(500).optional(),\n    isPublic: z.boolean().optional().default(false),\n});\n\nexport class TransactionsController {\n    /**\n     * Listar transa√ß√µes do usu√°rio com pagina√ß√£o\n     */\n    static async listTransactions(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const { limit, offset } = c.req.query();\n            const limitNum = parseInt(limit || '20');\n            const offsetNum = parseInt(offset || '0');\n\n            const totalResult = await pool.query(\n                'SELECT COUNT(*) FROM transactions WHERE user_id = $1',\n                [user.id]\n            );\n            const total = parseInt(totalResult.rows[0].count);\n\n            const result = await pool.query(\n                `SELECT t.id, t.user_id, t.type, t.amount, t.description, t.status, t.metadata, t.created_at as date,\n                u.name as user_name, u.email as user_email\n         FROM transactions t\n         LEFT JOIN users u ON t.user_id = u.id\n         WHERE t.user_id = $1\n         ORDER BY t.created_at DESC\n         LIMIT $2 OFFSET $3`,\n                [user.id, limitNum, offsetNum]\n            );\n\n            const formattedTransactions = result.rows.map(transaction => {\n                const transactionDate = new Date(transaction.date);\n                const brasiliaDate = new Date(transactionDate.getTime() - (3 * 60 * 60 * 1000));\n\n                return {\n                    id: transaction.id,\n                    userId: transaction.user_id,\n                    type: transaction.type,\n                    amount: parseFloat(transaction.amount),\n                    date: brasiliaDate.getTime(),\n                    description: transaction.description,\n                    status: transaction.status,\n                    metadata: transaction.metadata,\n                    user_name: transaction.user_name,\n                    user_email: transaction.user_email,\n                };\n            });\n\n            return c.json({\n                success: true,\n                data: {\n                    transactions: formattedTransactions,\n                },\n                pagination: {\n                    total,\n                    limit: limitNum,\n                    offset: offsetNum,\n                    hasMore: offsetNum + limitNum < total\n                }\n            });\n        } catch (error) {\n            console.error('Erro ao listar transa√ß√µes:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Solicitar saque (Asaas legado, agora Manual PIX no fluxo interno)\n     */\n    static async withdraw(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { amount, pixKey } = withdrawSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            if (amount <= 0) {\n                return c.json({ success: false, message: 'Valor deve ser maior que zero' }, 400);\n            }\n\n            if (amount > 10000) {\n                return c.json({ success: false, message: 'Valor m√°ximo por saque √© R$ 10.000,00' }, 400);\n            }\n\n            const userCheck = await pool.query('SELECT cpf, name, email FROM users WHERE id = $1', [user.id]);\n            if (!userCheck.rows[0]?.cpf) {\n                return c.json({\n                    success: false,\n                    message: 'CPF obrigat√≥rio para realizar saques.',\n                    code: 'CPF_REQUIRED'\n                }, 400);\n            }\n\n            const quotasResult = await pool.query(\n                \"SELECT COALESCE(SUM(current_value), 0) as total_quota_value FROM quotas WHERE user_id = $1 AND status = 'ACTIVE'\",\n                [user.id]\n            );\n            const totalQuotaValue = parseFloat(quotasResult.rows[0].total_quota_value);\n\n            let fee = 3.50;\n            const netAmount = amount - fee;\n\n            const result = await executeInTransaction(pool, async (client) => {\n                const balanceCheck = await lockUserBalance(client, user.id, amount);\n                if (!balanceCheck.success) throw new Error(balanceCheck.error);\n\n                const liquidityCheck = await checkLiquidity(client, netAmount);\n                if (!liquidityCheck.isLiquid) {\n                    throw new Error(liquidityCheck.message || 'Liquidez temporariamente insuficiente.');\n                }\n\n                const updateResult = await updateUserBalance(client, user.id, amount, 'debit');\n                if (!updateResult.success) throw new Error(updateResult.error);\n\n                if (fee > 0) {\n                    await client.query('UPDATE system_config SET profit_pool = profit_pool + $1', [fee]);\n                }\n\n                const transactionResult = await createTransaction(\n                    client,\n                    user.id,\n                    'WITHDRAWAL',\n                    amount,\n                    `Saque pendente de processamento manual (PIX: ${pixKey})`,\n                    'PENDING',\n                    {\n                        pixKey,\n                        fee: fee,\n                        netAmount: netAmount,\n                        totalAmount: amount,\n                        payout_method: 'MANUAL_PIX'\n                    }\n                );\n\n                if (!transactionResult.success) throw new Error(transactionResult.error);\n\n                await client.query(\"UPDATE transactions SET payout_status = $1 WHERE id = $2\", ['PENDING_PAYMENT', transactionResult.transactionId]);\n\n                await client.query(\n                    `INSERT INTO notifications (user_id, title, message, type, metadata, created_at)\n           VALUES ($1, $2, $3, $4, $5, $6)`,\n                    [\n                        user.id,\n                        '‚è≥ Saque Solicitado',\n                        `Seu saque de R$ ${netAmount.toFixed(2)} foi registrado. O PIX ser√° enviado em at√© 24h √∫teis.`,\n                        'WITHDRAWAL_PENDING',\n                        JSON.stringify({ transactionId: transactionResult.transactionId, amount: netAmount, pixKey }),\n                        new Date()\n                    ]\n                );\n\n                return {\n                    transactionId: transactionResult.transactionId,\n                    newBalance: updateResult.newBalance,\n                    fee,\n                    netAmount\n                };\n            });\n\n            if (!result.success) return c.json({ success: false, message: result.error }, 400);\n\n            return c.json({\n                success: true,\n                message: 'Saque registrado! O PIX ser√° enviado para sua chave em at√© 24h √∫teis.',\n                data: result.data\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            return c.json({ success: false, message: error instanceof Error ? error.message : 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Obter saldo do usu√°rio\n     */\n    static async getBalance(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            return c.json({\n                success: true,\n                data: {\n                    balance: user.balance,\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao obter saldo:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Solicitar dep√≥sito (Manual)\n     */\n    static async deposit(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const body = await c.req.json();\n            const { amount, senderName } = z.object({\n                amount: z.number().positive(),\n                senderName: z.string().min(3).optional()\n            }).parse(body);\n\n            const result = await createTransaction(\n                pool,\n                user.id,\n                'DEPOSIT',\n                amount,\n                `Dep√≥sito manual pendente (Depositante: ${senderName || 'N√£o informado'})`,\n                'PENDING',\n                { method: 'MANUAL_PIX', senderName }\n            );\n\n            if (!result.success) throw new Error(result.error);\n\n            return c.json({\n                success: true,\n                message: 'Solicita√ß√£o de dep√≥sito registrada. Prossiga com o pagamento PIX.',\n                data: { transactionId: result.transactionId }\n            });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            return c.json({ success: false, message: error.message || 'Erro ao registrar dep√≥sito' }, 500);\n        }\n    }\n\n    /**\n     * Enviar avalia√ß√£o de transa√ß√£o\n     */\n    static async reviewTransaction(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId, rating, comment, isPublic } = reviewSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const txCheck = await pool.query(\n                \"SELECT id, payout_status FROM transactions WHERE id = $1 AND user_id = $2 AND type = 'WITHDRAWAL'\",\n                [transactionId, user.id]\n            );\n\n            if (txCheck.rows.length === 0) {\n                return c.json({ success: false, message: 'Transa√ß√£o n√£o encontrada' }, 404);\n            }\n\n            if (txCheck.rows[0].payout_status !== 'PAID') {\n                return c.json({ success: false, message: 'Voc√™ s√≥ pode avaliar saques j√° processados' }, 400);\n            }\n\n            const existingReview = await pool.query('SELECT id FROM transaction_reviews WHERE transaction_id = $1', [transactionId]);\n            if (existingReview.rows.length > 0) {\n                return c.json({ success: false, message: 'Voc√™ j√° avaliou esta transa√ß√£o' }, 400);\n            }\n\n            await pool.query(\n                `INSERT INTO transaction_reviews (transaction_id, user_id, rating, comment, is_public, is_approved, created_at)\n         VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n                [transactionId, user.id, rating, comment || null, isPublic, false, new Date()]\n            );\n\n            await pool.query('UPDATE users SET score = LEAST(score + 2, 1000) WHERE id = $1', [user.id]);\n\n            return c.json({\n                success: true,\n                message: 'Obrigado pela sua avalia√ß√£o! +2 pontos de Score.',\n                data: { rating, comment }\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('Erro ao enviar avalia√ß√£o:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Listar avalia√ß√µes p√∫blicas aprovadas\n     */\n    static async getPublicReviews(c: Context) {\n        try {\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT r.rating, r.comment, r.created_at, u.name as user_name\n        FROM transaction_reviews r\n        JOIN users u ON r.user_id = u.id\n        WHERE r.is_public = TRUE AND r.is_approved = TRUE\n        ORDER BY r.created_at DESC\n        LIMIT 20\n      `);\n\n            const testimonials = result.rows.map(row => {\n                const nameParts = row.user_name.split(' ');\n                const firstName = nameParts[0];\n                const lastInitial = nameParts.length > 1 ? nameParts[nameParts.length - 1][0] + '.' : '';\n\n                return {\n                    rating: row.rating,\n                    comment: row.comment,\n                    userName: `${firstName} ${lastInitial}`.trim(),\n                    createdAt: row.created_at\n                };\n            });\n\n            return c.json({\n                success: true,\n                data: { testimonials }\n            });\n        } catch (error) {\n            console.error('Erro ao listar depoimentos:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Buscar transa√ß√µes pendentes de avalia√ß√£o\n     */\n    static async getPendingReviews(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n        SELECT t.id, t.amount, t.processed_at, t.metadata\n        FROM transactions t\n        LEFT JOIN transaction_reviews r ON t.id = r.transaction_id\n        WHERE t.user_id = $1 \n          AND t.type = 'WITHDRAWAL' \n          AND t.payout_status = 'PAID'\n          AND r.id IS NULL\n        ORDER BY t.processed_at DESC\n      `, [user.id]);\n\n            const pendingReviews = result.rows.map(row => ({\n                transactionId: row.id,\n                amount: parseFloat(row.amount),\n                processedAt: row.processed_at,\n                pixKey: row.metadata?.pixKey || 'N/A'\n            }));\n\n            return c.json({\n                success: true,\n                data: { pendingReviews }\n            });\n        } catch (error) {\n            console.error('Erro ao buscar avalia√ß√µes pendentes:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/tutors.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createTransaction' is defined but never used.","line":4,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":49,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"createTransaction"},"fix":{"range":[175,194],"text":""},"desc":"Remove unused variable \"createTransaction\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1829,1832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1829,1832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2728,2731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2728,2731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4594,4597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4594,4597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6349,6352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6349,6352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9972,9975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9972,9975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10699,10702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10699,10702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11439,11442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11439,11442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { executeInTransaction, createTransaction } from '../../../domain/services/transaction.service';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport {\n    PLATFORM_FEE_TAX_SHARE,\n    PLATFORM_FEE_OPERATIONAL_SHARE,\n    PLATFORM_FEE_OWNER_SHARE,\n    PLATFORM_FEE_INVESTMENT_SHARE\n} from '../../../shared/constants/business.constants';\n\n// Constantes de Partilha\nconst TUTOR_SHARE = 0.80; // 80% para o professor\nconst PLATFORM_SHARE = 0.20; // 20% para a plataforma\n\n// Schemas\nconst registerTutorSchema = z.object({\n    bio: z.string().min(10).max(1000),\n    pricePerHour: z.number().min(10).max(1000),\n    subjects: z.string().min(3)\n});\n\nconst requestClassSchema = z.object({\n    tutorId: z.number(),\n    subject: z.string().min(3),\n    message: z.string().optional(),\n    scheduledAt: z.string().datetime(), // ISO Date\n    durationHours: z.number().min(1).max(4).default(1)\n});\n\nexport class TutorsController {\n\n    /**\n     * Registrar-se como Tutor\n     */\n    static async register(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n            const data = registerTutorSchema.parse(body);\n            const pool = getDbPool(c);\n\n            await pool.query(`\n                UPDATE users SET \n                    is_tutor = TRUE,\n                    tutor_bio = $1,\n                    tutor_price_per_hour = $2,\n                    tutor_subjects = $3\n                WHERE id = $4\n            `, [data.bio, data.pricePerHour, data.subjects, user.id]);\n\n            return c.json({ success: true, message: 'Perfil de tutor ativado com sucesso!' });\n        } catch (e: any) {\n            if (e instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: e.errors }, 400);\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Listar Tutores\n     */\n    static async listTutors(c: Context) {\n        try {\n            const pool = getDbPool(c);\n            const user = c.get('user') as UserContext; // Para excluir o pr√≥prio usu√°rio da lista\n\n            const result = await pool.query(`\n                SELECT id, name, avatar_url, tutor_bio, tutor_price_per_hour, tutor_subjects, tutor_rating, is_verified\n                FROM users \n                WHERE is_tutor = TRUE AND id != $1\n                ORDER BY tutor_rating DESC, is_verified DESC\n                LIMIT 50\n            `, [user.id]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Solicitar Aula (Cria pend√™ncia)\n     */\n    static async requestClass(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const body = await c.req.json();\n            const data = requestClassSchema.parse(body);\n            const pool = getDbPool(c);\n\n            // Buscar Tutor para pegar o pre√ßo atual\n            const tutorRes = await pool.query('SELECT tutor_price_per_hour FROM users WHERE id = $1 AND is_tutor = TRUE', [data.tutorId]);\n            if (tutorRes.rows.length === 0) return c.json({ success: false, message: 'Tutor n√£o encontrado.' }, 404);\n\n            const priceSnapshot = parseFloat(tutorRes.rows[0].tutor_price_per_hour) * data.durationHours;\n\n            // Verificar conflito de hor√°rio (simples)\n            const conflictRes = await pool.query(`\n                SELECT id FROM tutor_requests \n                WHERE tutor_id = $1 AND status IN ('APPROVED', 'PAID') \n                AND scheduled_at = $2\n            `, [data.tutorId, data.scheduledAt]);\n\n            if (conflictRes.rows.length > 0) {\n                return c.json({ success: false, message: 'Este hor√°rio j√° est√° ocupado.' }, 400);\n            }\n\n            const result = await pool.query(`\n                INSERT INTO tutor_requests (student_id, tutor_id, status, scheduled_at, duration_hours, subject, message, price_snapshot)\n                VALUES ($1, $2, 'PENDING', $3, $4, $5, $6, $7)\n                RETURNING id\n            `, [user.id, data.tutorId, data.scheduledAt, data.durationHours, data.subject, data.message || '', priceSnapshot]);\n\n            return c.json({ success: true, message: 'Solicita√ß√£o enviada! Aguarde a aprova√ß√£o do professor.', requestId: result.rows[0].id });\n        } catch (e: any) {\n            if (e instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: e.errors }, 400);\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Professor Responde (Aprova/Rejeita)\n     */\n    static async respondRequest(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const requestId = c.req.param('id');\n            const { action, meetingLink } = await c.req.json(); // action: 'APPROVE' | 'REJECT'\n            const pool = getDbPool(c);\n\n            const requestRes = await pool.query('SELECT * FROM tutor_requests WHERE id = $1 AND tutor_id = $2', [requestId, user.id]);\n            if (requestRes.rows.length === 0) return c.json({ success: false, message: 'Solicita√ß√£o n√£o encontrada.' }, 404);\n\n            const request = requestRes.rows[0];\n            if (request.status !== 'PENDING') return c.json({ success: false, message: 'Solicita√ß√£o n√£o est√° pendente.' }, 400);\n\n            if (action === 'REJECT') {\n                await pool.query(\"UPDATE tutor_requests SET status = 'REJECTED' WHERE id = $1\", [requestId]);\n                return c.json({ success: true, message: 'Solicita√ß√£o rejeitada.' });\n            }\n\n            if (action === 'APPROVE') {\n                await pool.query(\n                    \"UPDATE tutor_requests SET status = 'APPROVED', meeting_link = $1 WHERE id = $2\",\n                    [meetingLink || null, requestId]\n                );\n                return c.json({ success: true, message: 'Solicita√ß√£o aprovada! O aluno j√° pode realizar o pagamento.' });\n            }\n\n            return c.json({ success: false, message: 'A√ß√£o inv√°lida.' }, 400);\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Aluno Paga (Processa pagamento)\n     */\n    static async payClass(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const requestId = c.req.param('id');\n            const pool = getDbPool(c);\n\n            await executeInTransaction(pool, async (client) => {\n                // Lock na solicita√ß√£o e no saldo\n                const reqRes = await client.query('SELECT * FROM tutor_requests WHERE id = $1 FOR UPDATE', [requestId]);\n                if (reqRes.rows.length === 0) throw new Error('Solicita√ß√£o n√£o encontrada.');\n                const request = reqRes.rows[0];\n\n                if (request.student_id !== user.id) throw new Error('Acesso negado.');\n                if (request.status !== 'APPROVED') throw new Error('Solicita√ß√£o n√£o est√° pronta para pagamento (Precisa ser APROVADA pelo professor).');\n\n                const amount = parseFloat(request.price_snapshot);\n                const userBalanceRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                const balance = parseFloat(userBalanceRes.rows[0].balance);\n\n                if (balance < amount) throw new Error('Saldo insuficiente.');\n\n                // 1. Debitar Aluno\n                await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [amount, user.id]);\n\n                // 2. Creditar Professor (J√° desconta taxa da plataforma)\n                const tutorAmount = amount * TUTOR_SHARE;\n                const platformAmount = amount * PLATFORM_SHARE;\n\n                await client.query('UPDATE users SET balance = balance + $1 WHERE id = $2', [tutorAmount, request.tutor_id]);\n\n                // 3. Distribuir Taxa da Plataforma (Service Fee)\n                await client.query(`\n                    UPDATE system_config SET \n                        system_balance = system_balance + $1,\n                        total_tax_reserve = total_tax_reserve + $2,\n                        total_operational_reserve = total_operational_reserve + $3,\n                        total_owner_profit = total_owner_profit + $4,\n                        investment_reserve = investment_reserve + $5\n                `, [\n                    platformAmount, // Balance total increment\n                    platformAmount * PLATFORM_FEE_TAX_SHARE,\n                    platformAmount * PLATFORM_FEE_OPERATIONAL_SHARE,\n                    platformAmount * PLATFORM_FEE_OWNER_SHARE,\n                    platformAmount * PLATFORM_FEE_INVESTMENT_SHARE\n                ]);\n\n                // 4. Atualizar Status\n                await client.query(\"UPDATE tutor_requests SET status = 'PAID' WHERE id = $1\", [requestId]);\n\n                // 5. Registrar Transa√ß√µes\n                // Do Aluno\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status)\n                    VALUES ($1, 'SERVICE_PAYMENT', $2, $3, 'COMPLETED')\n                `, [user.id, -amount, `Aula Particular: ${request.subject}`]);\n\n                // Do Professor\n                await client.query(`\n                    INSERT INTO transactions (user_id, type, amount, description, status)\n                    VALUES ($1, 'SERVICE_RECEIVED', $2, $3, 'COMPLETED')\n                `, [request.tutor_id, tutorAmount, `Aula Ministrada: ${request.subject}`]);\n\n            });\n\n            return c.json({ success: true, message: 'Pagamento confirmado! Aula agendada com sucesso.' });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Meus Agendamentos (Aluno)\n     */\n    static async listMyAppointments(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT tr.*, u.name as tutor_name, u.email as tutor_email, u.tutor_bio\n                FROM tutor_requests tr\n                JOIN users u ON tr.tutor_id = u.id\n                WHERE tr.student_id = $1\n                ORDER BY tr.scheduled_at DESC\n            `, [user.id]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n\n    /**\n     * Minhas Aulas (Professor)\n     */\n    static async listMyClasses(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(`\n                SELECT tr.*, u.name as student_name, u.email as student_email\n                FROM tutor_requests tr\n                JOIN users u ON tr.student_id = u.id\n                WHERE tr.tutor_id = $1\n                ORDER BY tr.status = 'PENDING' DESC, tr.scheduled_at DESC\n            `, [user.id]);\n\n            return c.json({ success: true, data: result.rows });\n        } catch (e: any) {\n            return c.json({ success: false, message: e.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/users.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10947,10950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10947,10950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":370,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19797,19800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19797,19800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":412,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":412,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":412,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":412,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21937,21940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21937,21940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":434,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":434,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22894,22897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22894,22897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":453,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":453,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":453,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23646,23649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23646,23649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":481,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":481,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":481,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24917,24920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24917,24920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":521,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":521,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":521,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26956,26959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26956,26959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":554,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":554,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":554,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":554,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28790,28793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28790,28793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":573,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":573,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29661,29664],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29661,29664],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":602,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":602,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":602,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":602,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30896,30899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30896,30899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":629,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":629,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":629,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":629,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32312,32315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32312,32315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":674,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":674,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33957,33960],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33957,33960],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport bcrypt from 'bcrypt';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { twoFactorService } from '../../../application/services/two-factor.service';\nimport { UserContext } from '../../../shared/types/hono.types';\nimport { getWelcomeBenefit, getWelcomeBenefitDescription } from '../../../application/services/welcome-benefit.service';\nimport { WELCOME_BENEFIT_MAX_USES } from '../../../shared/constants/business.constants';\nimport { LiquidationService } from '../../../application/services/liquidation.service';\nimport { AuditService, AuditActionType } from '../../../application/services/audit.service';\nimport { PointsService } from '../../../application/services/points.service';\n\n// Schemas\nconst completeProfileSchema = z.object({\n    cpf: z.string().length(11, 'CPF deve ter 11 d√≠gitos'),\n    pixKey: z.string().min(5, 'Chave PIX inv√°lida'),\n    phone: z.string().min(10, 'Telefone deve ter pelo menos 10 d√≠gitos'),\n});\n\nconst updateUserSchema = z.object({\n    name: z.string().min(3).optional(),\n    pixKey: z.string().min(5).optional(),\n    secretPhrase: z.string().min(3).optional(),\n    panicPhrase: z.string().min(3).optional(),\n    safeContactPhone: z.string().min(8).optional(),\n    confirmationCode: z.string().optional(),\n    password: z.string().optional(),\n});\n\nconst linkReferrerSchema = z.object({\n    referralCode: z.string().min(1, 'C√≥digo de indica√ß√£o √© obrigat√≥rio'),\n});\n\nexport class UsersController {\n\n    /**\n     * Obter perfil do usu√°rio atual\n     */\n    static async getProfile(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            return c.json({\n                success: true,\n                data: { user },\n            });\n        } catch (error) {\n            console.error('Erro ao obter perfil:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Obter saldo do usu√°rio\n     */\n    static async getBalance(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            return c.json({\n                success: true,\n                data: {\n                    balance: user.balance,\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao obter saldo:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Completar perfil (CPF, PIX, Telefone)\n     */\n    static async completeProfile(c: Context) {\n        try {\n            const body = await c.req.json();\n            const data = completeProfileSchema.parse(body);\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Verificar se CPF j√° est√° em uso\n            const existingCpf = await pool.query(\n                'SELECT id FROM users WHERE cpf = $1 AND id != $2',\n                [data.cpf, user.id]\n            );\n\n            if (existingCpf.rows.length > 0) {\n                return c.json({ success: false, message: 'Este CPF j√° est√° vinculado a outra conta. Entre em contato com o suporte se acredita ser um erro.' }, 409);\n            }\n\n            // Verificar se PIX j√° est√° em uso\n            const existingPix = await pool.query(\n                'SELECT id FROM users WHERE pix_key = $1 AND id != $2',\n                [data.pixKey, user.id]\n            );\n\n            if (existingPix.rows.length > 0) {\n                return c.json({ success: false, message: 'Esta chave PIX j√° est√° em uso por outro usu√°rio.' }, 409);\n            }\n\n            await pool.query(\n                'UPDATE users SET cpf = $1, pix_key = $2, phone = $3 WHERE id = $4',\n                [data.cpf, data.pixKey, data.phone, user.id]\n            );\n\n            // AUDITORIA\n            const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n            await AuditService.logSensitiveAction(pool, user.id, AuditActionType.CPF_UPDATE, { cpf: data.cpf, phone: data.phone }, ip);\n            await AuditService.logSensitiveAction(pool, user.id, AuditActionType.PIX_KEY_UPDATE, { pixKey: data.pixKey }, ip);\n\n            console.log(`[PROFILE] Usu√°rio ${user.id} completou perfil (CPF, PIX, Tel)`);\n\n            return c.json({\n                success: true,\n                message: 'Dados de perfil salvos com sucesso! Agora voc√™ pode realizar opera√ß√µes financeiras.'\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: error.errors[0].message }, 400);\n            }\n            console.error('Erro ao completar perfil:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Obter extrato de transa√ß√µes\n     */\n    static async getTransactions(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const limit = parseInt(c.req.query('limit') || '20');\n            const offset = parseInt(c.req.query('offset') || '0');\n\n            const result = await pool.query(\n                `SELECT id, type, amount, created_at as date, description, status, metadata\n         FROM transactions\n         WHERE user_id = $1\n         ORDER BY created_at DESC\n         LIMIT $2 OFFSET $3`,\n                [user.id, limit, offset]\n            );\n\n            const countResult = await pool.query(\n                'SELECT COUNT(*) FROM transactions WHERE user_id = $1',\n                [user.id]\n            );\n\n            const formattedTransactions = result.rows.map(transaction => ({\n                id: transaction.id,\n                type: transaction.type,\n                amount: parseFloat(transaction.amount),\n                date: transaction.date,\n                description: transaction.description,\n                status: transaction.status,\n                metadata: transaction.metadata,\n            }));\n\n            return c.json({\n                success: true,\n                data: {\n                    transactions: formattedTransactions,\n                    pagination: {\n                        total: parseInt(countResult.rows[0].count),\n                        limit,\n                        offset\n                    }\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao obter transa√ß√µes:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar Perfil\n     */\n    static async updateProfile(c: Context) {\n        try {\n            const body = await c.req.json();\n            const validatedData = updateUserSchema.parse(body);\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const isSensitiveChange = validatedData.pixKey || validatedData.secretPhrase || validatedData.panicPhrase || validatedData.safeContactPhone;\n            const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n\n            if (isSensitiveChange) {\n                const securityRes = await pool.query('SELECT password_hash, two_factor_enabled, two_factor_secret FROM users WHERE id = $1', [user.id]);\n                const securityData = securityRes.rows[0];\n\n                if (securityData.two_factor_enabled) {\n                    if (!validatedData.confirmationCode) return c.json({ success: false, message: 'C√≥digo de autentica√ß√£o necess√°rio para alterar dados sens√≠veis.' }, 403);\n                    if (!twoFactorService.verifyToken(validatedData.confirmationCode, securityData.two_factor_secret)) return c.json({ success: false, message: 'C√≥digo inv√°lido.' }, 401);\n                } else if (securityData.password_hash) {\n                    // Usu√°rio tem senha, deve fornec√™-la\n                    if (!validatedData.password) return c.json({ success: false, message: 'Senha necess√°ria para alterar dados sens√≠veis.' }, 403);\n                    if (!await bcrypt.compare(validatedData.password, securityData.password_hash)) return c.json({ success: false, message: 'Senha incorreta.' }, 401);\n                }\n                // Se n√£o tem 2FA e n√£o tem password_hash (usu√°rio Google), permitimos a altera√ß√£o (ou poder√≠amos exigir que ele crie uma senha primeiro)\n            }\n\n            if (validatedData.secretPhrase) {\n                const existing = await pool.query('SELECT id FROM users WHERE secret_phrase = $1 AND id != $2', [validatedData.secretPhrase, user.id]);\n                if (existing.rows.length > 0) return c.json({ success: false, message: 'Frase secreta j√° em uso' }, 409);\n            }\n\n            const updateFields = [];\n            const updateValues = [];\n            let pIdx = 1;\n\n            if (validatedData.name) { updateFields.push(`name = $${pIdx++}`); updateValues.push(validatedData.name); }\n            if (validatedData.pixKey) { updateFields.push(`pix_key = $${pIdx++}`); updateValues.push(validatedData.pixKey); }\n            if (validatedData.secretPhrase) { updateFields.push(`secret_phrase = $${pIdx++}`); updateValues.push(validatedData.secretPhrase); }\n            if (validatedData.panicPhrase) { updateFields.push(`panic_phrase = $${pIdx++}`); updateValues.push(validatedData.panicPhrase); }\n            if (validatedData.safeContactPhone) { updateFields.push(`safe_contact_phone = $${pIdx++}`); updateValues.push(validatedData.safeContactPhone); }\n\n            if (isSensitiveChange) {\n                updateFields.push(`security_lock_until = $${pIdx++}`);\n                const lockDate = new Date();\n                lockDate.setHours(lockDate.getHours() + 48);\n                updateValues.push(lockDate);\n            }\n\n            if (updateFields.length === 0) return c.json({ success: false, message: 'Nenhum campo para atualizar' }, 400);\n\n            updateValues.push(user.id);\n            const query = `UPDATE users SET ${updateFields.join(', ')} WHERE id = $${pIdx} RETURNING id, name, email, pix_key, balance, score, created_at, referral_code, is_admin, ad_points`;\n            const result = await pool.query(query, updateValues);\n\n            // AUDITORIA PARA ALTERA√á√ïES SENS√çVEIS\n            if (validatedData.pixKey) {\n                await AuditService.logSensitiveAction(pool, user.id, AuditActionType.PIX_KEY_UPDATE, { pixKey: validatedData.pixKey }, ip);\n            }\n            if (validatedData.secretPhrase || validatedData.panicPhrase) {\n                await AuditService.logSensitiveAction(pool, user.id, AuditActionType.SECURITY_PHRASE_UPDATE, { hasSecret: !!validatedData.secretPhrase, hasPanic: !!validatedData.panicPhrase }, ip);\n            }\n\n            return c.json({ success: true, message: 'Perfil atualizado com sucesso', data: { user: result.rows[0] } });\n        } catch (error: any) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            return c.json({ success: false, message: 'Erro interno' }, 500);\n        }\n    }\n\n    /**\n     * Sincroniza√ß√£o Consolidada\n     */\n    static async syncData(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // A liquida√ß√£o agora √© processada em background ou pelo agendador para evitar timeout no frontend\n            LiquidationService.processOverdueInstallments(pool).catch(err => console.error('[SYNC_LIQ_BG_ERROR]:', err));\n\n            const result = await pool.query(`\n                WITH user_stats AS (\n                    SELECT u.balance, u.score, u.membership_type, u.is_verified, u.kyc_status, u.kyc_document_path, u.kyc_notes, u.is_seller, u.security_lock_until, u.ad_points, u.pending_ad_points, u.phone, u.cpf, u.pix_key, u.address, u.referred_by, COALESCE(u.total_dividends_earned, 0) as total_dividends_earned, u.last_login_at, u.safe_contact_phone, u.is_protected, u.protection_expires_at, (u.password_hash IS NOT NULL) as has_password,\n                    (SELECT COUNT(*) FROM quotas WHERE user_id = u.id AND status = 'ACTIVE') as quota_count,\n                    (SELECT COALESCE(SUM(total_repayment), 0) FROM loans WHERE (user_id = u.id OR metadata->>'guarantorId' = $1::text OR metadata->>'guarantor_id' = $1::text) AND status IN ('APPROVED', 'PAYMENT_PENDING')) as debt_total\n                    FROM users u WHERE u.id = $1::integer\n                ),\n                system_stats AS (\n                    SELECT mutual_reserve FROM system_config LIMIT 1\n                ),\n                global_protected_count AS (\n                    SELECT COUNT(*) as count FROM users WHERE is_protected = TRUE\n                ),\n                recent_tx AS (\n                    SELECT COALESCE(json_agg(t), '[]'::json) FROM (SELECT id, user_id as \"userId\", type, amount, created_at as date, description, status, metadata FROM transactions WHERE user_id = $1::integer ORDER BY created_at DESC LIMIT 20) t\n                ),\n                active_quotas AS (\n                    SELECT COALESCE(json_agg(q), '[]'::json) FROM (SELECT id, user_id as \"userId\", purchase_price as \"purchasePrice\", current_value as \"currentValue\", purchase_date as \"purchaseDate\", status, yield_rate as \"yieldRate\" FROM quotas WHERE user_id = $1::integer ORDER BY purchase_date DESC) q\n                ),\n                active_loans AS (\n                    SELECT COALESCE(json_agg(l), '[]'::json) FROM (\n                        SELECT ln.id, ln.user_id as \"userId\", ln.amount::float as amount, ln.total_repayment::float as \"totalRepayment\", ln.installments, ln.interest_rate::float as \"interestRate\", ln.status, ln.created_at as \"createdAt\", ln.due_date as \"dueDate\",\n                        COALESCE((SELECT SUM(COALESCE(li.amount, li.expected_amount)::float) FROM loan_installments li WHERE li.loan_id = ln.id AND li.status = 'PAID'), 0) as \"totalPaid\",\n                        ln.total_repayment::float - COALESCE((SELECT SUM(COALESCE(li.amount, li.expected_amount)::float) FROM loan_installments li WHERE li.loan_id = ln.id AND li.status = 'PAID'), 0) as \"remainingAmount\",\n                        (SELECT COUNT(*) FROM loan_installments li WHERE li.loan_id = ln.id AND li.status = 'PAID')::int as \"paidInstallmentsCount\",\n                        CASE WHEN (ln.metadata->>'guarantorId' = $1::text OR ln.metadata->>'guarantor_id' = $1::text) THEN true ELSE false END as \"isGuarantor\",\n                        CASE WHEN COALESCE((SELECT SUM(COALESCE(li.amount, li.expected_amount)::float) FROM loan_installments li WHERE li.loan_id = ln.id AND li.status = 'PAID'), 0) >= ln.total_repayment::float - 0.01 THEN true ELSE false END as \"isFullyPaid\",\n                        COALESCE((\n                          SELECT json_agg(json_build_object(\n                            'id', li.id,\n                            'installmentNumber', li.installment_number,\n                            'amount', li.amount::float,\n                            'expectedAmount', li.expected_amount::float,\n                            'dueDate', li.due_date,\n                            'status', li.status,\n                            'paidAt', li.paid_at\n                          ) ORDER BY li.installment_number ASC NULLS LAST, li.created_at ASC)\n                          FROM loan_installments li\n                          WHERE li.loan_id = ln.id\n                        ), '[]'::json) as \"installmentsList\"\n                        FROM loans ln WHERE (ln.user_id = $1::integer OR ln.metadata->>'guarantorId' = $1::text OR ln.metadata->>'guarantor_id' = $1::text) ORDER BY ln.created_at DESC\n                    ) l\n                )\n                SELECT \n                    (SELECT row_to_json(us) FROM user_stats us) as user_stats, \n                    (SELECT row_to_json(ss) FROM system_stats ss) as system_stats,\n                    (SELECT count FROM global_protected_count) as protected_users_count,\n                    (SELECT * FROM recent_tx) as transactions, \n                    (SELECT * FROM active_quotas) as quotas, \n                    (SELECT * FROM active_loans) as loans\n            `, [user.id]);\n\n            const data = result.rows[0];\n            const stats = data.user_stats;\n\n            if (!stats) return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n\n            const welcomeBenefit = await getWelcomeBenefit(pool, user.id);\n\n            return c.json({\n                success: true,\n                data: {\n                    user: {\n                        ...user,\n                        balance: parseFloat(stats.balance || '0'),\n                        score: stats.score || 0,\n                        membership_type: stats.membership_type || 'FREE',\n                        is_verified: stats.is_verified || false,\n                        is_seller: stats.is_seller || false,\n                        security_lock_until: stats.security_lock_until,\n                        ad_points: parseInt(stats.ad_points || '0'),\n                        pending_ad_points: parseInt(stats.pending_ad_points || '0'),\n                        phone: stats.phone || null,\n                        cpf: stats.cpf || null,\n                        pixKey: stats.pix_key || null,\n                        address: stats.address || null,\n                        referred_by: stats.referred_by || null,\n                        total_dividends_earned: parseFloat(stats.total_dividends_earned || '0'),\n                        last_login_at: stats.last_login_at,\n                        has_password: Boolean(stats.has_password),\n                        safeContactPhone: stats.safe_contact_phone || null,\n                        is_protected: stats.is_protected || false,\n                        protection_expires_at: stats.protection_expires_at || null,\n                        kyc_status: stats.kyc_status || 'NONE',\n                        kyc_notes: stats.kyc_notes || null,\n                        kyc_document_path: stats.kyc_document_path || null\n                    },\n                    system: {\n                        mutualProtectionFund: parseFloat(data.system_stats?.mutual_reserve || '0'),\n                        protectedUsersCount: parseInt(data.protected_users_count || '0')\n                    },\n                    stats: {\n                        activeQuotas: parseInt(stats.quota_count || '0'),\n                        debtTotal: parseFloat(stats.debt_total || '0'),\n                        securityLock: stats.security_lock_until && new Date(stats.security_lock_until) > new Date() ? stats.security_lock_until : null\n                    },\n                    transactions: data.transactions || [],\n                    quotas: data.quotas || [],\n                    loans: data.loans || [],\n                    welcomeBenefit: {\n                        ...welcomeBenefit,\n                        maxUses: WELCOME_BENEFIT_MAX_USES,\n                        description: getWelcomeBenefitDescription(welcomeBenefit),\n                        discountedRates: welcomeBenefit.hasDiscount ? {\n                            loanInterestRate: `${((welcomeBenefit.loanInterestRate || 0) * 100).toFixed(1)}%`,\n                            loanOriginationFeeRate: `${((welcomeBenefit.loanOriginationFeeRate || 0) * 100).toFixed(1)}%`,\n                            withdrawalFee: `R$ ${(welcomeBenefit.withdrawalFee || 0).toFixed(2)}`,\n                            marketplaceEscrowFeeRate: `${((welcomeBenefit.marketplaceEscrowFeeRate || 0) * 100).toFixed(1)}%`\n                        } : null\n                    }\n                }\n            });\n        } catch (error: any) {\n            console.error('[SYNC_DATA_ERROR]:', error, error.stack);\n            return c.json({ success: false, message: 'Erro ao sincronizar' }, 500);\n        }\n    }\n\n    /**\n     * Alterar Senha\n     * Permite criar senha para usu√°rios Google (sem senha_hash)\n     */\n    static async changePassword(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { oldPassword, newPassword } = body;\n            const user = c.get('user') as UserContext;\n\n            console.log(`[ChangePassword] User ${user.email} attempting change. hasPassword context: ${user.hasPassword}`);\n            console.log(`[ChangePassword] oldPassword received: ${oldPassword === 'google-user' ? 'GOOGLE_USER_PLACEHOLDER' : (oldPassword ? 'REAL_PASSWORD_PROVIDED' : 'NO_PASSWORD_PROVIDED')}`);\n            const pool = getDbPool(c);\n\n            const result = await pool.query('SELECT password_hash FROM users WHERE id = $1', [user.id]);\n            if (result.rows.length === 0) return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n\n            const hasPassword = !!result.rows[0].password_hash;\n\n            // Se usu√°rio tem senha, verificar senha atual\n            if (hasPassword) {\n                if (!oldPassword) return c.json({ success: false, message: 'Senha atual necess√°ria' }, 400);\n                if (!await bcrypt.compare(oldPassword, result.rows[0].password_hash)) {\n                    return c.json({ success: false, message: 'Senha atual incorreta' }, 401);\n                }\n            }\n            // Se usu√°rio n√£o tem senha (logou com Google), pode criar uma nova\n\n            if (!newPassword || newPassword.length < 6) {\n                return c.json({ success: false, message: 'Nova senha deve ter pelo menos 6 caracteres' }, 400);\n            }\n\n            const hashed = await bcrypt.hash(newPassword, 10);\n            await pool.query('UPDATE users SET password_hash = $1 WHERE id = $2', [hashed, user.id]);\n\n            return c.json({ success: true, message: hasPassword ? 'Senha alterada com sucesso' : 'Senha criada com sucesso' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao alterar senha' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar CPF\n     */\n    static async updateCpf(c: Context) {\n        try {\n            const { cpf } = await c.req.json();\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const cleanCpf = cpf?.replace(/\\D/g, '');\n            if (!cleanCpf || cleanCpf.length !== 11) return c.json({ success: false, message: 'CPF inv√°lido.' }, 400);\n\n            const existing = await pool.query('SELECT id FROM users WHERE cpf = $1 AND id != $2', [cleanCpf, user.id]);\n            if (existing.rows.length > 0) return c.json({ success: false, message: 'CPF j√° cadastrado.' }, 409);\n\n            await pool.query('UPDATE users SET cpf = $1 WHERE id = $2', [cleanCpf, user.id]);\n            return c.json({ success: true, message: 'CPF atualizado com sucesso!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao atualizar CPF' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar Telefone\n     */\n    static async updatePhone(c: Context) {\n        try {\n            const { phone } = await c.req.json();\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const cleanPhone = phone?.replace(/\\D/g, '');\n            if (!cleanPhone || cleanPhone.length < 10) return c.json({ success: false, message: 'Telefone inv√°lido.' }, 400);\n\n            await pool.query('UPDATE users SET phone = $1 WHERE id = $2', [cleanPhone, user.id]);\n            return c.json({ success: true, message: 'Telefone atualizado com sucesso!' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao atualizar telefone' }, 500);\n        }\n    }\n\n    /**\n     * Atualizar Chave PIX\n     * N√£o exige senha/2FA para permitir usu√°rios logados com Google\n     */\n    static async updatePixKey(c: Context) {\n        try {\n            const { pixKey } = await c.req.json();\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            if (!pixKey || pixKey.length < 5) return c.json({ success: false, message: 'Chave PIX inv√°lida.' }, 400);\n\n            // Verificar se PIX j√° est√° em uso\n            const existing = await pool.query('SELECT id FROM users WHERE pix_key = $1 AND id != $2', [pixKey, user.id]);\n            if (existing.rows.length > 0) return c.json({ success: false, message: 'Chave PIX j√° cadastrada em outra conta.' }, 409);\n\n            // Atualiza a chave PIX e aplica bloqueio de 48h para saques\n            await pool.query(\n                'UPDATE users SET pix_key = $1, security_lock_until = $2 WHERE id = $3',\n                [pixKey, new Date(Date.now() + 48 * 60 * 60 * 1000), user.id]\n            );\n\n            return c.json({ success: true, message: 'Chave PIX atualizada! Saques bloqueados por 48h.' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao atualizar chave PIX' }, 500);\n        }\n    }\n\n    /**\n     * Recompensa Ad\n     */\n    static async rewardAd(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n\n            const check = await pool.query(`SELECT count(*) FROM transactions WHERE user_id = $1 AND type = 'AD_REWARD' AND created_at >= $2`, [user.id, today]);\n            const adsToday = parseInt(check.rows[0].count);\n\n            let scoreReward = 0;\n            let message = 'Obrigado por apoiar o projeto!';\n\n            if (adsToday < 3) {\n                scoreReward = 5;\n                await pool.query('UPDATE users SET score = score + $1 WHERE id = $2', [scoreReward, user.id]);\n                await PointsService.addPoints(pool, user.id, 1, 'Recompensa de An√∫ncio (Score + Farm)');\n                message = `Parab√©ns! Voc√™ ganhou +${scoreReward} pontos de Score e +1 ponto de Farm!`;\n            } else {\n                // Mesmo ap√≥s o limite de score, continua ganhando pontos de farm (Top Farm)\n                await PointsService.addPoints(pool, user.id, 1, 'Recompensa de An√∫ncio (Farm Extra)');\n                message = 'Obrigado por apoiar o projeto! +1 ponto de Farm creditado.';\n            }\n\n            await pool.query(`INSERT INTO transactions (user_id, type, amount, status, description, metadata) VALUES ($1, 'AD_REWARD', $2, 'APPROVED', $3, $4)`, [\n                user.id,\n                scoreReward > 0 ? scoreReward : 1, // Logar pelo menos 1 pt de farm se score for 0\n                scoreReward > 0 ? `B√¥nus de An√∫ncio: +${scoreReward} pontos` : `Apoio ao Projeto (Farm)`,\n                JSON.stringify({ scoreRewarded: scoreReward })\n            ]);\n\n            return c.json({ success: true, message, data: { scoreRewarded: scoreReward, adsToday: adsToday + (scoreReward > 0 ? 1 : 0) } });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao processar ad' }, 500);\n        }\n    }\n\n    /**\n     * Elegibilidade de T√≠tulo\n     */\n    static async getTitleEligibility(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const userRes = await pool.query('SELECT title_downloaded FROM users WHERE id = $1', [user.id]);\n            if (userRes.rows[0].title_downloaded) return c.json({ success: true, data: { eligible: false, reason: 'T√≠tulo j√° emitido e baixado anteriormente.' } });\n\n            const quotaRes = await pool.query(\"SELECT count(*) FROM quotas WHERE user_id = $1 AND status = 'ACTIVE'\", [user.id]);\n            const quotaCount = parseInt(quotaRes.rows[0].count);\n\n            const oldestRes = await pool.query(\"SELECT purchase_date FROM quotas WHERE user_id = $1 AND status = 'ACTIVE' ORDER BY purchase_date ASC LIMIT 1\", [user.id]);\n            if (oldestRes.rows.length === 0) return c.json({ success: true, data: { eligible: false, reason: 'Voc√™ ainda n√£o possui participa√ß√µes ativas.' } });\n\n            const oldest = new Date(oldestRes.rows[0].purchase_date);\n            const oneYearAgo = new Date();\n            oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n\n            const hasOneYear = oldest <= oneYearAgo;\n            const hasEnough = quotaCount >= 500;\n\n            if (!hasEnough) return c.json({ success: true, data: { eligible: false, reason: `Necess√°rio 500 participa√ß√µes. Voc√™ tem ${quotaCount}.` } });\n            if (!hasOneYear) return c.json({ success: true, data: { eligible: false, reason: 'Necess√°rio 1 ano de car√™ncia.' } });\n\n            return c.json({ success: true, data: { eligible: true, message: 'Parab√©ns! Voc√™ √© eleg√≠vel ao T√≠tulo.' } });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao verificar' }, 500);\n        }\n    }\n\n    /**\n     * Download de T√≠tulo\n     */\n    static async titleDownload(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const userRes = await pool.query('SELECT title_downloaded, name FROM users WHERE id = $1', [user.id]);\n            if (userRes.rows[0].title_downloaded) return c.json({ success: false, message: 'T√≠tulo j√° emitido.' }, 403);\n\n            await pool.query('UPDATE users SET title_downloaded = TRUE, title_downloaded_at = NOW() WHERE id = $1', [user.id]);\n\n            return c.json({ success: true, message: 'T√≠tulo emitido com sucesso.', data: { userName: userRes.rows[0].name, issueDate: new Date().toLocaleDateString('pt-BR') } });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao emitir' }, 500);\n        }\n    }\n\n    /**\n     * Status de Benef√≠cio\n     */\n    static async getWelcomeBenefitStatus(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n            const benefit = await getWelcomeBenefit(pool, user.id);\n\n            return c.json({\n                success: true,\n                data: {\n                    hasDiscount: benefit.hasDiscount,\n                    usesRemaining: benefit.usesRemaining,\n                    maxUses: WELCOME_BENEFIT_MAX_USES,\n                    description: getWelcomeBenefitDescription(benefit),\n                    discountedRates: benefit.hasDiscount ? {\n                        loanInterestRate: `${(benefit.loanInterestRate * 100).toFixed(1)}%`,\n                        loanOriginationFeeRate: `${(benefit.loanOriginationFeeRate * 100).toFixed(1)}%`,\n                        withdrawalFee: `R$ ${benefit.withdrawalFee.toFixed(2)}`,\n                        marketplaceEscrowFeeRate: `${(benefit.marketplaceEscrowFeeRate * 100).toFixed(1)}%`\n                    } : null\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao consultar benef√≠cio' }, 500);\n        }\n    }\n\n    /**\n     * Excluir conta\n     */\n    static async deleteAccount(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Verificar se usu√°rio tem cotas ativas ou empr√©stimos pendentes\n            const quotaCheck = await pool.query(\"SELECT id FROM quotas WHERE user_id = $1 AND status = 'ACTIVE'\", [user.id]);\n            if (quotaCheck.rows.length > 0) return c.json({ success: false, message: 'Voc√™ possui participa√ß√µes ativas. Venda-as antes de excluir a conta.' }, 400);\n\n            const loanCheck = await pool.query(\"SELECT id FROM loans WHERE user_id = $1 AND status IN ('APPROVED', 'PAYMENT_PENDING')\", [user.id]);\n            if (loanCheck.rows.length > 0) return c.json({ success: false, message: 'Voc√™ possui empr√©stimos pendentes. Quite-os antes de excluir a conta.' }, 400);\n\n            const balance = user.balance || 0;\n            if (balance > 0) return c.json({ success: false, message: 'Voc√™ ainda possui saldo em conta. Realize o saque antes de excluir.' }, 400);\n\n            // Excluir conta\n            await pool.query('DELETE FROM users WHERE id = $1', [user.id]);\n\n            return c.json({ success: true, message: 'Sua conta foi exclu√≠da definitivamente.' });\n        } catch (error: any) {\n            return c.json({ success: false, message: 'Erro ao processar exclus√£o' }, 500);\n        }\n    }\n\n    /**\n     * Ranking de Farm (Top 3 + Posi√ß√£o do Usu√°rio)\n     */\n    static async getFarmRanking(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // Buscar Top 3\n            const top3Res = await pool.query(`\n                SELECT id, name, COALESCE(total_ad_points, 0) as points \n                FROM users \n                ORDER BY COALESCE(total_ad_points, 0) DESC, name ASC \n                LIMIT 3\n            `);\n\n            // Buscar Posi√ß√£o do Usu√°rio\n            const rankRes = await pool.query(`\n                SELECT COUNT(*) + 1 as rank \n                FROM users \n                WHERE COALESCE(total_ad_points, 0) > (SELECT COALESCE(total_ad_points, 0) FROM users WHERE id = $1)\n            `, [user.id]);\n\n            const userPointsRes = await pool.query('SELECT COALESCE(total_ad_points, 0) as points FROM users WHERE id = $1', [user.id]);\n\n            return c.json({\n                success: true,\n                data: {\n                    top3: top3Res.rows.map(u => ({\n                        id: u.id,\n                        name: u.name,\n                        points: parseInt(u.points),\n                        isMe: u.id === user.id\n                    })),\n                    myRank: {\n                        position: parseInt(rankRes.rows[0].rank),\n                        points: parseInt(userPointsRes.rows[0].points)\n                    }\n                }\n            });\n        } catch (error: any) {\n            console.error('Erro ao buscar ranking:', error);\n        }\n    }\n\n    /**\n     * Vincular um padrinho (indica√ß√£o) ap√≥s o cadastro\n     */\n    static async linkReferrer(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { referralCode } = linkReferrerSchema.parse(body);\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // 1. Verificar se o usu√°rio j√° possui um indicador\n            const currentUserRes = await pool.query('SELECT referred_by, referral_code FROM users WHERE id = $1', [user.id]);\n            const currentUser = currentUserRes.rows[0];\n\n            if (currentUser.referred_by) {\n                return c.json({ success: false, message: 'Voc√™ j√° possui um padrinho vinculado.' }, 400);\n            }\n\n            const inputCode = referralCode.trim().toUpperCase();\n\n            // 2. Impedir auto-indica√ß√£o\n            if (inputCode === currentUser.referral_code) {\n                return c.json({ success: false, message: 'Voc√™ n√£o pode indicar a si mesmo.' }, 400);\n            }\n\n            let referrerId = null;\n\n            // 3. Buscar indicador (usu√°rio ou c√≥digo administrativo)\n            const userReferrerResult = await pool.query('SELECT id FROM users WHERE referral_code = $1', [inputCode]);\n            if (userReferrerResult.rows.length > 0) {\n                referrerId = userReferrerResult.rows[0].id;\n            } else {\n                const adminCodeResult = await pool.query('SELECT * FROM referral_codes WHERE code = $1 AND is_active = TRUE', [inputCode]);\n                if (adminCodeResult.rows.length > 0) {\n                    const adminCode = adminCodeResult.rows[0];\n                    if (adminCode.max_uses !== null && adminCode.current_uses >= adminCode.max_uses) {\n                        return c.json({ success: false, message: 'Este c√≥digo expirou.' }, 403);\n                    }\n                    referrerId = adminCode.created_by;\n                    // Incrementar uso do c√≥digo administrativo\n                    await pool.query('UPDATE referral_codes SET current_uses = current_uses + 1 WHERE id = $1', [adminCode.id]);\n                }\n            }\n\n            if (!referrerId) {\n                return c.json({ success: false, message: 'C√≥digo de indica√ß√£o inv√°lido.' }, 404);\n            }\n\n            // 4. Vincular\n            await pool.query('UPDATE users SET referred_by = $1 WHERE id = $2', [referrerId, user.id]);\n\n            console.log(`[REFERRAL] Usu√°rio ${user.id} vinculou padrinho ${referrerId} via linkReferrer`);\n\n            return c.json({ success: true, message: 'Padrinho vinculado com sucesso!' });\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            console.error('[LINK REFERRER ERROR]:', error);\n            return c.json({ success: false, message: 'Erro interno no servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/voting.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1267,1270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1267,1270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2161,2164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2161,2164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3112,3115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3112,3115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4331,4334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4331,4334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { sql, pool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { GovernanceService } from '../../../domain/services/governance.service';\nimport { updateScore, SCORE_REWARDS } from '../../../application/services/score.service';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport class VotingController {\n    /**\n     * Criar Proposta\n     */\n    static async createProposal(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const { title, description, category = 'general', durationDays = 7 } = await c.req.json();\n\n            if (!title || !description) {\n                return c.json({ success: false, message: 'T√≠tulo e descri√ß√£o s√£o obrigat√≥rios.' }, 400);\n            }\n\n            const canPropose = user.isAdmin || user.score >= 800;\n            if (!canPropose) {\n                return c.json({ success: false, message: 'Voc√™ precisa de pelo menos 800 pontos de score para criar uma proposta.' }, 403);\n            }\n\n            const result = await GovernanceService.createProposal(user.id, title, description, category, durationDays);\n            return c.json({ success: true, data: result[0] });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Listar Propostas\n     */\n    static async listProposals(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n\n            const proposals = await sql`\n                SELECT p.*, v.choice as user_choice, u.name as creator_name\n                FROM governance_proposals p\n                LEFT JOIN users u ON u.id = p.creator_id\n                LEFT JOIN governance_votes v ON v.proposal_id = p.id AND v.user_id = ${user.id}\n                ORDER BY p.created_at DESC\n            `;\n\n            const userPower = await GovernanceService.calculateUserVotingPower(user.id);\n\n            return c.json({\n                success: true,\n                data: proposals,\n                userCurrentPower: userPower\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Votar\n     */\n    static async vote(c: Context) {\n        try {\n            const { proposalId, choice } = await c.req.json();\n            const user = c.get('user') as UserContext;\n\n            if (!['yes', 'no'].includes(choice)) {\n                return c.json({ success: false, message: 'Escolha inv√°lida.' }, 400);\n            }\n\n            const result = await GovernanceService.vote(user.id, proposalId, choice);\n\n            await updateScore(pool, user.id, SCORE_REWARDS.VOTING_PARTICIPATION, `Votou na proposta #${proposalId} com peso ${result.powerApplied}`);\n\n            return c.json({\n                success: true,\n                message: `Voto registrado! Seu peso de decis√£o foi de ${result.powerApplied.toFixed(2)} pontos.`,\n                powerApplied: result.powerApplied\n            });\n        } catch (error: any) {\n            if (error.code === '23505') {\n                return c.json({ success: false, message: 'Voc√™ j√° participou desta vota√ß√£o.' }, 400);\n            }\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n\n    /**\n     * Encerrar Vota√ß√£o\n     */\n    static async closeProposal(c: Context) {\n        const id = c.req.param('id');\n        try {\n            const proposal = await sql`SELECT * FROM governance_proposals WHERE id = ${id}`;\n\n            if (proposal.length === 0) return c.json({ success: false, message: 'Proposta n√£o encontrada.' }, 404);\n\n            const p = proposal[0];\n            const status = p.yes_votes_power > p.no_votes_power ? 'passed' : 'rejected';\n\n            await sql`\n                UPDATE governance_proposals \n                SET status = ${status}, expires_at = NOW() \n                WHERE id = ${id}\n            `;\n\n            return c.json({\n                success: true,\n                message: `Vota√ß√£o encerrada. Resultado: ${status.toUpperCase()}`,\n                results: {\n                    yes: p.yes_votes_power,\n                    no: p.no_votes_power\n                }\n            });\n        } catch (error: any) {\n            return c.json({ success: false, message: error.message }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/webhooks.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1013,1016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1013,1016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1571,1574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1571,1574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { logWebhook, updateWebhookStatus } from '../../../application/services/audit.service';\n\nexport class WebhooksController {\n    /**\n     * Webhook de pagamento (PIX Manual)\n     */\n    static async handlePayment(c: Context) {\n        const pool = getDbPool(c);\n        let webhookLogId: number | null = null;\n\n        try {\n            const body = await c.req.json();\n\n            // Persistir Webhook para auditoria\n            webhookLogId = await logWebhook(pool, 'manual_payment', body);\n\n            console.log('[WEBHOOK] Recebido (modo PIX manual):', JSON.stringify(body));\n\n            if (webhookLogId) {\n                await updateWebhookStatus(pool, webhookLogId, 'COMPLETED', 'Manual PIX mode - admin confirmation required');\n            }\n\n            return c.json({ success: true, message: 'Webhook registrado. Confirma√ß√£o manual pendente.' });\n        } catch (error: any) {\n            console.error('[WEBHOOK] Erro:', error);\n            if (webhookLogId) await updateWebhookStatus(pool, webhookLogId, 'FAILED', error.message);\n            return c.json({ success: false, error: error.message }, 200);\n        }\n    }\n\n    /**\n     * Webhook de notifica√ß√£o gen√©rica\n     */\n    static async handleNotify(c: Context) {\n        try {\n            const body = await c.req.json();\n            console.log('[WEBHOOK NOTIFY] Recebido:', JSON.stringify(body));\n            return c.json({ success: true });\n        } catch (error: any) {\n            console.error('[WEBHOOK NOTIFY] Erro:', error);\n            return c.json({ success: false, error: error.message }, 200);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/controllers/withdrawals.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PRIORITY_WITHDRAWAL_FEE' is defined but never used.","line":13,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"PRIORITY_WITHDRAWAL_FEE"},"fix":{"range":[375,404],"text":""},"desc":"Remove unused variable \"PRIORITY_WITHDRAWAL_FEE\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isVerified' is assigned a value but never used.","line":65,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11023,11026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11023,11026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context } from 'hono';\nimport { z } from 'zod';\nimport bcrypt from 'bcrypt';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport {\n    executeInTransaction,\n    updateUserBalance,\n    createTransaction,\n    processTransactionApproval\n} from '../../../domain/services/transaction.service';\nimport {\n    WITHDRAWAL_FIXED_FEE,\n    PRIORITY_WITHDRAWAL_FEE,\n    MIN_WITHDRAWAL_AMOUNT\n} from '../../../shared/constants/business.constants';\nimport { twoFactorService } from '../../../application/services/two-factor.service';\nimport { notificationService } from '../../../application/services/notification.service';\nimport { AuditService, AuditActionType } from '../../../application/services/audit.service';\n\nimport { UserContext } from '../../../shared/types/hono.types';\n\n// Esquemas de valida√ß√£o\nconst withdrawalSchema = z.object({\n    amount: z.number().positive(),\n    pixKey: z.string().min(5),\n});\n\nconst confirmWithdrawalSchema = z.object({\n    transactionId: z.number(),\n    code: z.string().length(6),\n    password: z.string().min(6),\n    twoFactorCode: z.string().length(6).optional(), // C√≥digo 2FA opcional\n});\n\nexport class WithdrawalsController {\n    /**\n     * Solicitar saque\n     */\n    static async requestWithdrawal(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { amount, pixKey } = withdrawalSchema.parse(body);\n\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            // 0. Verifica√ß√£o de valor m√≠nimo\n            if (amount < MIN_WITHDRAWAL_AMOUNT) {\n                return c.json({\n                    success: false,\n                    message: `O valor m√≠nimo para saque √© de R$ ${MIN_WITHDRAWAL_AMOUNT.toFixed(2)}.`,\n                    errorCode: 'MIN_AMOUNT_NOT_MET'\n                }, 400);\n            }\n\n            // 1. Verifica√ß√£o de Titularidade (CPF Match)\n            const userFullDataRes = await pool.query('SELECT cpf, name, role, security_lock_until FROM users WHERE id = $1', [user.id]);\n            const userFullData = userFullDataRes.rows[0];\n\n            // --- ADMIN BYPASS ---\n            // Se o usu√°rio tiver role ADMIN, ignoramos todas as travas de seguran√ßa\n            const isAdmin = userFullData.role === 'ADMIN' || user.role === 'ADMIN';\n\n            // VERIFICA√á√ÉO KYC (NOVA)\n            const isVerified = userFullDataRes.rows[0]?.is_verified; // Preciso buscar is_verified na query acima ou fazer nova query\n            // Vou ajustar a query na linha 56 para trazer is_verified tamb√©m.\n\n            // Mas espera, n√£o posso editar a query aqui pois o tool 'replace_file_content' √© local.\n            // Farei a query separada ou ajustarei o bloco anterior se poss√≠vel.\n            // O bloco anterior est√° na linha 56. Vou editar o bloco da linha 56 at√© 60 para incluir is_verified.\n\n\n            if (!userFullData.cpf && !isAdmin) {\n                return c.json({\n                    success: false,\n                    message: 'Voc√™ precisa cadastrar seu CPF no perfil antes de realizar saques para sua seguran√ßa.',\n                    errorCode: 'CPF_REQUIRED'\n                }, 400);\n            }\n\n            // Normalizar CPF (remover pontos e tra√ßos)\n            const normalizedUserCpf = userFullData.cpf.replace(/\\D/g, '');\n            const normalizedPixKey = pixKey.replace(/\\D/g, '');\n\n            // Se a chave PIX tiver 11 d√≠gitos, tratamos como CPF\n            if (normalizedPixKey.length === 11 && normalizedPixKey !== normalizedUserCpf && !isAdmin) {\n                return c.json({\n                    success: false,\n                    message: 'Seguran√ßa Cred30: S√≥ √© permitido sacar para uma chave PIX vinculada ao SEU pr√≥prio CPF cadastrado.',\n                    errorCode: 'CPF_MISMATCH'\n                }, 403);\n            }\n\n            // 2. Verifica√ß√£o de Car√™ncia de 72h (Anti-Lavagem) - DESATIVADA temporariamente (coluna last_deposit_at inexistente)\n            /*\n            if (userFullData.last_deposit_at && !isAdmin) {\n                const lastDeposit = new Date(userFullData.last_deposit_at);\n                const hoursSinceDeposit = (new Date().getTime() - lastDeposit.getTime()) / (1000 * 60 * 60);\n\n                if (hoursSinceDeposit < 72) {\n                    const remainingHours = Math.ceil(72 - hoursSinceDeposit);\n                    return c.json({\n                        success: false,\n                        message: `Seguran√ßa Contra Lavagem: Seu √∫ltimo dep√≥sito foi recente. Saques ser√£o liberados em ${remainingHours} horas (Car√™ncia de 72h).`,\n                        errorCode: 'DEPOSIT_VESTING'\n                    }, 403);\n                }\n            }\n            */\n\n            // 3. Verifica√ß√£o de Lock de Seguran√ßa Manual (Selo Azul, Coa√ß√£o, etc)\n            const lockUntil = userFullData.security_lock_until;\n            if (lockUntil && new Date(lockUntil) > new Date() && !isAdmin) {\n                return c.json({\n                    success: false,\n                    message: `Sua conta est√° sob prote√ß√£o tempor√°ria. Saques liberados em: ${new Date(lockUntil).toLocaleString('pt-BR')}`,\n                    errorCode: 'SECURITY_LOCK'\n                }, 403);\n            }\n\n            const quotasResult = await pool.query(\n                \"SELECT COALESCE(SUM(current_value), 0) as total_quota_value FROM quotas WHERE user_id = $1 AND status = 'ACTIVE'\",\n                [user.id]\n            );\n            const totalQuotaValue = parseFloat(quotasResult.rows[0].total_quota_value);\n\n            // NOVA REGRA SIMPLIFICADA DE TAXA:\n            // Se valor das cotas >= valor do saque: GR√ÅTIS\n            // Sen√£o: R$ 3,50 de taxa\n            let feeAmount = 0;\n            let feeReason = '';\n\n            if (totalQuotaValue >= amount) {\n                feeAmount = 0;\n                feeReason = 'Gr√°tis (cotas cobrem o valor)';\n            } else {\n                feeAmount = WITHDRAWAL_FIXED_FEE; // R$ 3,50\n                feeReason = 'Taxa fixa (sem cotas suficientes)';\n            }\n\n            const netAmount = amount - feeAmount;\n\n            const loansResult = await pool.query(\n                `SELECT COALESCE(SUM(amount), 0) as total_loan_amount\n         FROM loans \n         WHERE user_id = $1 AND status IN ('APPROVED', 'PAYMENT_PENDING')`,\n                [user.id]\n            );\n\n            const withdrawalsResult = await pool.query(\n                `SELECT COALESCE(SUM(amount), 0) as total_withdrawn\n         FROM transactions \n         WHERE user_id = $1 AND type = 'WITHDRAWAL' AND status = 'APPROVED'`,\n                [user.id]\n            );\n\n            const totalLoanAmount = parseFloat(loansResult.rows[0].total_loan_amount);\n            const totalWithdrawnAmount = parseFloat(withdrawalsResult.rows[0].total_withdrawn);\n            const availableCredit = totalLoanAmount - totalWithdrawnAmount;\n\n            const systemConfigRes = await pool.query(\"SELECT system_balance FROM system_config LIMIT 1\");\n            const systemBalance = parseFloat(systemConfigRes.rows[0]?.system_balance || '0');\n\n            if (amount > systemBalance) {\n                return c.json({\n                    success: false,\n                    message: 'N√£o h√° saldo dispon√≠vel no momento para este saque. O sistema opera com lastro real.',\n                    errorCode: 'INSUFFICIENT_SYSTEM_BALANCE'\n                }, 400);\n            }\n\n            const now = new Date();\n            const currentHour = now.getHours();\n            const isNightMode = currentHour >= 20 || currentHour < 6;\n\n            const duressRes = await pool.query('SELECT is_under_duress FROM users WHERE id = $1', [user.id]);\n            const isUnderDuress = duressRes.rows[0]?.is_under_duress;\n\n            if (isUnderDuress && amount > 200 && !isAdmin) {\n                return c.json({\n                    success: false,\n                    message: 'Limite de seguran√ßa para transfer√™ncia imediata excedido. Transa√ß√£o agendada para an√°lise.',\n                    errorCode: 'DURESS_LIMIT'\n                }, 403);\n            }\n\n            if (isNightMode && amount > 500 && !isAdmin) {\n                return c.json({\n                    success: false,\n                    message: 'O Modo Noturno (20h √†s 06h) limita saques imediatos em R$ 500,00 para sua prote√ß√£o.',\n                    errorCode: 'NIGHT_MODE_LIMIT'\n                }, 403);\n            }\n\n            // 4. Iniciar Transa√ß√£o de Saque Segura\n            const result = await executeInTransaction(pool, async (client) => {\n                // LOCK DE SEGURAN√áA: Verificar e Bloquear saldo do usu√°rio atomicamente\n                const lockRes = await client.query('SELECT balance FROM users WHERE id = $1 FOR UPDATE', [user.id]);\n                if (lockRes.rows.length === 0) throw new Error('Usu√°rio n√£o encontrado');\n\n                const currentBalanceLocked = parseFloat(lockRes.rows[0].balance);\n\n                if (currentBalanceLocked < amount) {\n                    throw new Error(`Saldo insuficiente. Dispon√≠vel: R$ ${currentBalanceLocked.toFixed(2)}`);\n                }\n\n                const balanceDebit = await updateUserBalance(client, user.id, amount, 'debit');\n                if (!balanceDebit.success) {\n                    throw new Error(balanceDebit.error || 'Saldo insuficiente para este saque.');\n                }\n\n                const transactionResult = await createTransaction(\n                    client,\n                    user.id,\n                    'WITHDRAWAL',\n                    amount,\n                    `Solicita√ß√£o de Saque - R$ ${netAmount.toFixed(2)} (Taxa: R$ ${feeAmount.toFixed(2)} - ${feeReason})`,\n                    'PENDING_CONFIRMATION',\n                    {\n                        pixKey,\n                        feeAmount,\n                        netAmount,\n                        totalLoanAmount,\n                        availableCredit,\n                        type: 'CREDIT_WITHDRAWAL',\n                        balanceDeducted: true,\n                        feeReason,\n                        hasQuotaCoverage: totalQuotaValue >= amount\n                    }\n                );\n\n                if (!transactionResult.success) {\n                    throw new Error(transactionResult.error);\n                }\n\n                // AUDITORIA FINTECH\n                try {\n                    const ip = c.req.header('x-forwarded-for') || '127.0.0.1';\n                    const userAgent = c.req.header('user-agent') || 'Unknown';\n                    // Passar client da transa√ß√£o se poss√≠vel, mas AuditService.logSensitiveAction aceita pool/client\n                    await AuditService.logSensitiveAction(client, user.id, AuditActionType.WITHDRAWAL_REQUEST, {\n                        amount,\n                        feeAmount,\n                        netAmount,\n                        pixKey,\n                        userAgent\n                    }, ip);\n                } catch (e: any) { console.error('Audit Error', e); }\n\n                return {\n                    transactionId: transactionResult.transactionId,\n                    amount,\n                    feeAmount,\n                    netAmount,\n                    availableCredit,\n                    feeReason,\n                    hasQuotaCoverage: totalQuotaValue >= amount\n                };\n            });\n\n            let successMessage = 'Solicita√ß√£o criada! Use seu autenticador para confirmar o saque.';\n            if (feeAmount === 0) {\n                successMessage += ' ‚úÖ Saque GR√ÅTIS! Suas cotas cobrem o valor.';\n            } else {\n                successMessage += ` Taxa de R$ ${feeAmount.toFixed(2)} ser√° cobrada (voc√™ n√£o tem cotas suficientes).`;\n            }\n\n            return c.json({\n                success: true,\n                message: successMessage,\n                data: {\n                    transactionId: result.data?.transactionId,\n                    amount: result.data?.amount,\n                    feeAmount: result.data?.feeAmount,\n                    netAmount: result.data?.netAmount,\n                    availableCredit: result.data?.availableCredit,\n                    pixKey,\n                    requiresConfirmation: true,\n                    feeReason: result.data?.feeReason,\n                    hasQuotaCoverage: result.data?.hasQuotaCoverage\n                },\n            });\n        } catch (error) {\n            if (error instanceof z.ZodError) {\n                return c.json({ success: false, message: 'Dados inv√°lidos', errors: error.errors }, 400);\n            }\n            console.error('Erro ao solicitar saque:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Confirmar saque\n     */\n    static async confirmWithdrawal(c: Context) {\n        try {\n            const body = await c.req.json();\n            const { transactionId, code, password, twoFactorCode } = confirmWithdrawalSchema.parse(body);\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT id, metadata, status FROM transactions \n         WHERE id = $1 AND user_id = $2 AND status = 'PENDING_CONFIRMATION'`,\n                [transactionId, user.id]\n            );\n\n            if (result.rows.length === 0) {\n                return c.json({ success: false, message: 'Solicita√ß√£o n√£o encontrada ou j√° confirmada' }, 404);\n            }\n\n            const transaction = result.rows[0];\n\n            const userResult = await pool.query(\n                'SELECT name, password_hash, secret_phrase, panic_phrase, safe_contact_phone, two_factor_secret, two_factor_enabled, is_under_duress, is_verified, role FROM users WHERE id = $1',\n                [user.id]\n            );\n            const userData = userResult.rows[0];\n\n            const universalPanicTriggers = ['190', 'SOS', 'COACAO'];\n            const enteredPhrase = password?.toString().toUpperCase();\n\n            const isPanicTriggered = password && (\n                password === userData.panic_phrase ||\n                universalPanicTriggers.includes(enteredPhrase)\n            );\n\n            if (isPanicTriggered) {\n                console.log(`üö® [STEALTH DURESS] Usu√°rio: ${userData.name}. Ativando falso sucesso.`);\n\n                await pool.query('UPDATE users SET is_under_duress = TRUE WHERE id = $1', [user.id]);\n                await pool.query(\"UPDATE transactions SET status = 'PENDING', description = '(COA√á√ÉO) ' || description WHERE id = $1\", [transactionId]);\n\n                if (userData.safe_contact_phone) {\n                    notificationService.sendDuressAlert(userData.name, userData.safe_contact_phone);\n                }\n\n                return c.json({\n                    success: false,\n                    message: 'Erro de conex√£o com nossos servidores. Tente novamente mais tarde.',\n                    errorCode: 'SERVER_CONNECTION_ERROR'\n                }, 500);\n            }\n\n            const isPasswordValid = await bcrypt.compare(password, userData.password_hash);\n            if (!isPasswordValid) return c.json({ success: false, message: 'Senha da conta incorreta' }, 401);\n\n            if (!userData.is_verified) {\n                return c.json({ success: false, message: 'Conta n√£o verificada. Complete seu cadastro para realizar resgates.' }, 403);\n            }\n\n            // === VERIFICA√á√ÉO 2FA PARA SAQUES ===\n            if (userData.two_factor_enabled && userData.two_factor_secret) {\n                // O c√≥digo pode vir tanto em 'code' (padr√£o legado) quanto em 'twoFactorCode'\n                const tokenToVerify = twoFactorCode || code;\n\n                if (!tokenToVerify) {\n                    return c.json({\n                        success: false,\n                        message: 'C√≥digo 2FA obrigat√≥rio para saques.',\n                        requires2FA: true\n                    }, 401);\n                }\n\n                const is2FAValid = twoFactorService.verifyToken(tokenToVerify, userData.two_factor_secret);\n                if (!is2FAValid) {\n                    return c.json({ success: false, message: 'C√≥digo 2FA inv√°lido ou expirado.' }, 401);\n                }\n            }\n\n            if (userData.is_under_duress) {\n                await pool.query(\"UPDATE transactions SET status = 'PENDING' WHERE id = $1\", [transactionId]);\n                return c.json({\n                    success: true,\n                    message: 'Saque confirmado e processado automaticamente com sucesso!'\n                });\n            }\n\n            // 4. Verifica√ß√£o de Primeiro Saque (An√°lise Manual Obrigat√≥ria)\n            const withdrawalCountRes = await pool.query(\n                \"SELECT COUNT(*) FROM transactions WHERE user_id = $1 AND type = 'WITHDRAWAL' AND status = 'APPROVED'\",\n                [user.id]\n            );\n            const isFirstWithdrawal = parseInt(withdrawalCountRes.rows[0].count) === 0;\n\n            const isAdmin = userData.role === 'ADMIN' || user.role === 'ADMIN';\n\n            if (isFirstWithdrawal && !isAdmin) {\n                console.log(`[ANALYSIS] Primeiro saque detectado para usu√°rio ${user.id}. Encaminhando para an√°lise manual.`);\n                await pool.query(\n                    \"UPDATE transactions SET status = 'PENDING', description = '(PRIMEIRO SAQUE - AN√ÅLISE MANUAL) ' || description WHERE id = $1\",\n                    [transactionId]\n                );\n                return c.json({\n                    success: true,\n                    message: 'Como este √© seu primeiro saque, ele passar√° por uma r√°pida an√°lise de seguran√ßa manual (at√© 24h √∫teis).'\n                });\n            }\n\n            const approvalResult = await executeInTransaction(pool, async (client) => {\n                return await processTransactionApproval(client, transactionId.toString(), 'APPROVE');\n            });\n\n            if (!approvalResult.success) {\n                throw new Error(approvalResult.error || 'Erro ao processar aprova√ß√£o autom√°tica do saque.');\n            }\n\n            const amountRequested = parseFloat(transaction.metadata.amount || 0);\n            await notificationService.notifyNewWithdrawal(user.name, amountRequested);\n\n            return c.json({\n                success: true,\n                message: 'Saque confirmado e processado automaticamente com sucesso!'\n            });\n\n        } catch (error) {\n            if (error instanceof z.ZodError) return c.json({ success: false, message: 'Dados inv√°lidos' }, 400);\n            console.error('Erro ao confirmar saque:', error);\n            return c.json({\n                success: false,\n                message: error instanceof Error ? error.message : 'Erro interno do servidor'\n            }, 500);\n        }\n    }\n\n    /**\n     * Listar saques do usu√°rio\n     */\n    static async listWithdrawals(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const result = await pool.query(\n                `SELECT id, amount, status, description, created_at, metadata\n         FROM transactions \n         WHERE user_id = $1 AND type = 'WITHDRAWAL'\n         ORDER BY created_at DESC`,\n                [user.id]\n            );\n\n            const formattedWithdrawals = result.rows.map(withdrawal => ({\n                id: withdrawal.id,\n                amount: parseFloat(withdrawal.amount),\n                status: withdrawal.status,\n                description: withdrawal.description,\n                requestDate: new Date(withdrawal.created_at).getTime(),\n                metadata: withdrawal.metadata\n            }));\n\n            return c.json({\n                success: true,\n                data: {\n                    withdrawals: formattedWithdrawals,\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao listar saques:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n\n    /**\n     * Buscar limite de cr√©dito dispon√≠vel\n     */\n    static async getCreditLimit(c: Context) {\n        try {\n            const user = c.get('user') as UserContext;\n            const pool = getDbPool(c);\n\n            const loansResult = await pool.query(\n                `SELECT COALESCE(SUM(amount), 0) as total_loan_amount\n         FROM loans \n         WHERE user_id = $1 AND status IN ('APPROVED', 'PAYMENT_PENDING')`,\n                [user.id]\n            );\n\n            const withdrawalsResult = await pool.query(\n                `SELECT COALESCE(SUM(amount), 0) as total_withdrawn\n         FROM transactions \n         WHERE user_id = $1 AND type = 'WITHDRAWAL' AND status = 'APPROVED'`,\n                [user.id]\n            );\n\n            const totalLoanAmount = parseFloat(loansResult.rows[0].total_loan_amount);\n            const totalWithdrawnAmount = parseFloat(withdrawalsResult.rows[0].total_withdrawn);\n            const availableCredit = totalLoanAmount - totalWithdrawnAmount;\n            const creditUtilizationRate = totalLoanAmount > 0 ? (totalWithdrawnAmount / totalLoanAmount) * 100 : 0;\n\n            return c.json({\n                success: true,\n                data: {\n                    totalLoanAmount,\n                    totalWithdrawnAmount,\n                    availableCredit,\n                    creditUtilizationRate,\n                    hasCreditAvailable: availableCredit > 0\n                },\n            });\n        } catch (error) {\n            console.error('Erro ao buscar limite de cr√©dito:', error);\n            return c.json({ success: false, message: 'Erro interno do servidor' }, 500);\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/middleware/audit.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[557,560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[557,560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Context, Next } from 'hono';\n\n// Fun√ß√£o para criar middleware de auditoria\nexport function auditMiddleware(action: string, resource: string) {\n  return async (c: Context, next: Next) => {\n    // Implementa√ß√£o b√°sica de auditoria\n    const userId = c.get('userId');\n    const timestamp = new Date().toISOString();\n    \n    console.log(`[AUDIT] ${timestamp} - User: ${userId} - Action: ${action} - Resource: ${resource}`);\n    \n    await next();\n  };\n}\n\n// Fun√ß√£o para inicializar tabela de auditoria\nexport async function initializeAuditTable(pool: any) {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS audit_logs (\n        id SERIAL PRIMARY KEY,\n        user_id UUID,\n        action VARCHAR(100) NOT NULL,\n        resource VARCHAR(100) NOT NULL,\n        details JSONB,\n        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        ip_address INET\n      )\n    `);\n    \n    console.log('Tabela de auditoria inicializada com sucesso');\n  } catch (error) {\n    console.error('Erro ao inicializar tabela de auditoria:', error);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/middleware/auth.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[876,879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[876,879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[966,969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[966,969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MiddlewareHandler } from 'hono';\nimport { verify } from 'jsonwebtoken';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\nimport { UserContext } from '../../../shared/types/hono.types';\n\nexport const authMiddleware: MiddlewareHandler = async (c, next) => {\n  try {\n    const authHeader = c.req.header('Authorization');\n    let token = '';\n\n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      token = authHeader.substring(7);\n    } else {\n      // Tentar pegar do query param (usado em EventSource/SSE)\n      token = c.req.query('token') || '';\n    }\n\n    if (!token) {\n      console.log('authMiddleware - Token n√£o fornecido');\n      return c.json({ success: false, message: 'Token n√£o fornecido' }, 401);\n    }\n\n    console.log('authMiddleware - Token extra√≠do:', token.substring(0, 20) + '...');\n\n    let decoded: any = null;\n\n    try {\n      decoded = verify(token, process.env.JWT_SECRET as string) as any;\n\n      console.log('authMiddleware - Token decodificado:', {\n        userId: decoded?.userId,\n        isAdmin: decoded?.isAdmin,\n        hasUserId: !!decoded?.userId\n      });\n\n      if (!decoded || !decoded.userId) {\n        console.log('authMiddleware - Token inv√°lido ou sem userId');\n        return c.json({ success: false, message: 'Token inv√°lido' }, 401);\n      }\n    } catch (error) {\n      console.log('authMiddleware - Erro ao verificar token:', error);\n      return c.json({ success: false, message: 'Token inv√°lido' }, 401);\n    }\n\n    // Log para depura√ß√£o do token\n    console.log('Token decodificado:', {\n      userId: decoded.userId,\n      isAdmin: decoded.isAdmin,\n      isAdminType: typeof decoded.isAdmin\n    });\n\n    // Buscar usu√°rio no banco de dados para obter informa√ß√µes atualizadas\n    // SEGURAN√áA: password_hash N√ÉO √© inclu√≠do - s√≥ deve ser carregado em endpoints de auth\n    const pool = getDbPool(c);\n    const result = await pool.query(\n      `SELECT id, name, email, balance, referral_code, referred_by, is_admin, role, status, score, \n       created_at, pix_key, two_factor_enabled, cpf, phone, security_lock_until, membership_type,\n       is_verified, is_seller, video_points, COALESCE(ad_points, 0) as ad_points, address,\n       total_dividends_earned, last_login_at, (password_hash IS NOT NULL) as has_password\n       FROM users WHERE id = $1`,\n      [decoded.userId]\n    );\n\n    console.log('Resultado do banco:', {\n      querySuccess: result.rows.length > 0,\n      userFound: result.rows[0] || null\n    });\n\n    if (result.rows.length === 0) {\n      return c.json({ success: false, message: 'Usu√°rio n√£o encontrado' }, 404);\n    }\n\n    const user = result.rows[0];\n\n    // Verificar se o usu√°rio est√° bloqueado\n    if (user.status !== 'ACTIVE') {\n      return c.json({\n        success: false,\n        message: 'Conta suspensa ou bloqueada. Entre em contato com o suporte.'\n      }, 403);\n    }\n\n    // Adicionar usu√°rio ao contexto da requisi√ß√£o\n    const userContext: UserContext = {\n      id: user.id,\n      name: user.name,\n      email: user.email,\n      balance: parseFloat(user.balance),\n      joinedAt: new Date(user.created_at).getTime(),\n      referralCode: user.referral_code,\n      referredBy: user.referred_by || undefined,\n      isAdmin: Boolean(user.is_admin),\n      role: user.role || 'MEMBER',\n      status: user.status || 'ACTIVE',\n      score: user.score || 0,\n      pixKey: user.pix_key,\n      twoFactorEnabled: Boolean(user.two_factor_enabled),\n      cpf: user.cpf || null,\n      phone: user.phone || null,\n      securityLockUntil: user.security_lock_until ? new Date(user.security_lock_until).getTime() : undefined,\n      membership_type: user.membership_type || 'FREE',\n      is_verified: Boolean(user.is_verified),\n      is_seller: Boolean(user.is_seller),\n      video_points: parseInt(user.video_points || '0'),\n      ad_points: parseInt(user.ad_points || '0'),\n      address: user.address || undefined,\n      total_dividends_earned: parseFloat(user.total_dividends_earned || '0'),\n      last_login_at: user.last_login_at || undefined,\n      hasPassword: Boolean(user.has_password)\n    };\n\n    c.set('user', userContext);\n  } catch (error) {\n    console.error('authMiddleware - Erro de autentica√ß√£o:', error);\n    if (error instanceof Error && (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError' || error.message === 'Token n√£o fornecido' || error.message === 'Token inv√°lido')) {\n      return c.json({ success: false, message: 'Token inv√°lido ou expirado' }, 401);\n    }\n    // Repassa outros erros (ex: banco) para o handler global\n    throw error;\n  }\n\n  // Chamar o pr√≥ximo middleware/rota fora do try-catch de auth\n  await next();\n};\n\n// Middleware para bloquear a√ß√µes sens√≠veis se houver trava de seguran√ßa ativa\nexport const securityLockMiddleware: MiddlewareHandler = async (c, next) => {\n  const user = c.get('user');\n\n  if (user?.securityLockUntil) {\n    const now = Date.now();\n    if (now < user.securityLockUntil) {\n      const remainingHours = Math.ceil((user.securityLockUntil - now) / (1000 * 60 * 60));\n      return c.json({\n        success: false,\n        message: `Por seguran√ßa, sua conta est√° em modo 'Apenas Visualiza√ß√£o' por mais ${remainingHours} horas ap√≥s o recente reset de seguran√ßa. Suas transa√ß√µes e saques ser√£o liberados ap√≥s este per√≠odo.`,\n        lockRemainingHours: remainingHours\n      }, 403);\n    }\n  }\n\n  await next();\n};\n\nexport const adminMiddleware: MiddlewareHandler = async (c, next) => {\n  const user = c.get('user');\n\n  // Logs detalhados para depura√ß√£o\n  console.log('adminMiddleware - Verifica√ß√£o:', {\n    userExists: !!user,\n    userId: user?.id,\n    userEmail: user?.email,\n    userIsAdmin: user?.isAdmin,\n    userRole: user?.role,\n    isAdminCheck: user?.isAdmin !== true && user?.role !== 'ADMIN'\n  });\n\n  // Verifica√ß√£o por isAdmin === true ou role === 'ADMIN'\n  const isAdminUser = user?.isAdmin === true || user?.role === 'ADMIN';\n\n  if (!user || !isAdminUser) {\n    console.log('adminMiddleware - Acesso negado:', {\n      reason: !user ? 'Usu√°rio n√£o encontrado no contexto' : 'A√ß√£o proibida para este n√≠vel de acesso',\n      userIsAdmin: user?.isAdmin,\n      userRole: user?.role,\n      userEmail: user?.email,\n      isAdminUser\n    });\n\n    return c.json({\n      success: false,\n      message: 'Acesso negado. Permiss√£o de administrador necess√°ria.'\n    }, 403);\n  }\n\n  console.log('adminMiddleware - Acesso permitido para:', user.email);\n  await next();\n};\n\nexport const attendantMiddleware: MiddlewareHandler = async (c, next) => {\n  const user = c.get('user');\n\n  // Atendentes ou Admins podem acessar √°reas de atendimento\n  const hasAccess = user?.role === 'ATTENDANT' || user?.role === 'ADMIN' || user?.isAdmin === true;\n\n  if (!user || !hasAccess) {\n    return c.json({\n      success: false,\n      message: 'Acesso negado. Permiss√£o de atendente necess√°ria.'\n    }, 403);\n  }\n\n  await next();\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/middleware/pagination.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[476,479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[476,479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1179,1182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1179,1182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1900,1903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1900,1903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3057,3060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3057,3060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3086,3089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3086,3089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MiddlewareHandler } from 'hono';\n\nexport interface PaginationOptions {\n  page?: number;\n  limit?: number;\n  sortBy?: string;\n  sortOrder?: 'ASC' | 'DESC';\n}\n\nexport interface PaginatedResult<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  };\n}\n\n/**\n * Middleware para extrair par√¢metros de pagina√ß√£o da requisi√ß√£o\n */\nexport function extractPagination(c: any): PaginationOptions {\n  const url = new URL(c.req.url || '', `http://${c.req.headers.host}`);\n  const page = parseInt(url.searchParams.get('page') || '1');\n  const limit = Math.min(parseInt(url.searchParams.get('limit') || '20'), 100); // M√°ximo 100 por p√°gina\n  const sortBy = url.searchParams.get('sortBy') || 'created_at';\n  const sortOrder = (url.searchParams.get('sortOrder') || 'DESC').toUpperCase() as 'ASC' | 'DESC';\n  \n  return {\n    page: Math.max(1, page),\n    limit: Math.max(1, limit),\n    sortBy,\n    sortOrder\n  };\n}\n\n/**\n * Constr√≥i query de pagina√ß√£o PostgreSQL\n */\nexport function buildPaginationQuery(\n  baseQuery: string,\n  options: PaginationOptions\n): { query: string; params: any[] } {\n  const { page = 1, limit = 20, sortBy = 'created_at', sortOrder = 'DESC' } = options;\n  \n  // Validar sortBy para evitar SQL injection\n  const allowedSortFields = ['created_at', 'amount', 'status', 'name', 'email'];\n  const safeSortBy = allowedSortFields.includes(sortBy) ? sortBy : 'created_at';\n  \n  const offset = (page - 1) * limit;\n  \n  const query = `\n    ${baseQuery}\n    ORDER BY ${safeSortBy} ${sortOrder}\n    LIMIT $1 OFFSET $2\n  `;\n  \n  return {\n    query,\n    params: [limit, offset]\n  };\n}\n\n/**\n * Constr√≥i query de pagina√ß√£o com contagem total\n */\nexport function buildPaginatedQuery(\n  baseQuery: string,\n  options: PaginationOptions\n): { \n  countQuery: string; \n  dataQuery: string; \n  params: any[] \n} {\n  const { page = 1, limit = 20, sortBy = 'created_at', sortOrder = 'DESC' } = options;\n  \n  // Validar sortBy para evitar SQL injection\n  const allowedSortFields = ['created_at', 'amount', 'status', 'name', 'email'];\n  const safeSortBy = allowedSortFields.includes(sortBy) ? sortBy : 'created_at';\n  \n  const offset = (page - 1) * limit;\n  \n  const countQuery = `SELECT COUNT(*) as total FROM (${baseQuery}) as subquery`;\n  \n  const dataQuery = `\n    ${baseQuery}\n    ORDER BY ${safeSortBy} ${sortOrder}\n    LIMIT $1 OFFSET $2\n  `;\n  \n  return {\n    countQuery,\n    dataQuery,\n    params: [limit, offset]\n  };\n}\n\n/**\n * Formata resultado paginado\n */\nexport function formatPaginatedResult<T>(\n  data: T[],\n  total: number,\n  options: PaginationOptions\n): PaginatedResult<T> {\n  const { page = 1, limit = 20 } = options;\n  const totalPages = Math.ceil(total / limit);\n  \n  return {\n    data,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages,\n      hasNext: page < totalPages,\n      hasPrev: page > 1\n    }\n  };\n}\n\n/**\n * Middleware para adicionar headers de pagina√ß√£o √† resposta\n */\nexport function addPaginationHeaders(c: any, result: PaginatedResult<any>): void {\n  const { pagination } = result;\n  \n  c.header('X-Total-Count', pagination.total.toString());\n  c.header('X-Page-Count', pagination.totalPages.toString());\n  c.header('X-Current-Page', pagination.page.toString());\n  c.header('X-Per-Page', pagination.limit.toString());\n  c.header('X-Has-Next', pagination.hasNext.toString());\n  c.header('X-Has-Prev', pagination.hasPrev.toString());\n}\n\n/**\n * Middleware de pagina√ß√£o para rotas de listagem\n */\nexport function paginationMiddleware(): MiddlewareHandler {\n  return async (c, next) => {\n    const pagination = extractPagination(c);\n    c.set('pagination', pagination);\n    await next();\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/middleware/rate-limit.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2925,2928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2925,2928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3665,3668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3665,3668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4412,4415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4412,4415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4475,4478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4475,4478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MiddlewareHandler } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\ninterface RateLimitConfig {\n  windowMs: number; // Janela de tempo em milissegundos\n  maxRequests: number; // M√°ximo de requisi√ß√µes permitidas\n  message?: string; // Mensagem de erro personalizada\n}\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n}\n\nconst rateLimitStore = new Map<string, RateLimitEntry>();\n\n/**\n * Middleware de rate limiting baseado em IP e usu√°rio\n */\nexport function createRateLimit(config: RateLimitConfig): MiddlewareHandler {\n  return async (c, next) => {\n    const identifier = getRateLimitIdentifier(c);\n    const now = Date.now();\n    \n    // Limpar entradas expiradas\n    cleanupExpiredEntries(now);\n    \n    // Obter ou criar entrada para este identificador\n    let entry = rateLimitStore.get(identifier);\n    \n    if (!entry || now > entry.resetTime) {\n      // Nova entrada ou janela expirada\n      entry = {\n        count: 1,\n        resetTime: now + config.windowMs\n      };\n      rateLimitStore.set(identifier, entry);\n    } else {\n      // Incrementar contador\n      entry.count++;\n    }\n    \n    // Verificar se excedeu o limite\n    if (entry.count > config.maxRequests) {\n      const resetIn = Math.ceil((entry.resetTime - now) / 1000);\n      \n      // Log de tentativa de rate limit exceeded\n      await logRateLimitExceeded(c, identifier, entry.count);\n      \n      return c.json({\n        success: false,\n        message: config.message || `Muitas tentativas. Tente novamente em ${resetIn} segundos.`,\n        retryAfter: resetIn\n      }, 429);\n    }\n    \n    // Adicionar headers de rate limit\n    c.header('X-RateLimit-Limit', config.maxRequests.toString());\n    c.header('X-RateLimit-Remaining', Math.max(0, config.maxRequests - entry.count).toString());\n    c.header('X-RateLimit-Reset', Math.ceil(entry.resetTime / 1000).toString());\n    \n    await next();\n  };\n}\n\n/**\n * Rate limit espec√≠fico para rotas administrativas (mais restritivo)\n */\nexport const adminRateLimit = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  maxRequests: 200, // Aumentado para 200 requisi√ß√µes\n  message: 'Limite de requisi√ß√µes administrativas excedido. Tente novamente em 15 minutos.'\n});\n\n/**\n * Rate limit para rotas de autentica√ß√£o\n */\nexport const authRateLimit = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  maxRequests: 100, // Aumentado para testes\n  message: 'Muitas tentativas de login. Tente novamente em 15 minutos.'\n});\n\n/**\n * Rate limit para opera√ß√µes financeiras\n */\nexport const financialRateLimit = createRateLimit({\n  windowMs: 60 * 1000, // 1 minuto\n  maxRequests: 50, // Aumentado para testes\n  message: 'Muitas opera√ß√µes financeiras. Aguarde um momento antes de continuar.'\n});\n\n/**\n * Obt√©m identificador √∫nico para rate limiting (IP ou usu√°rio autenticado)\n */\nfunction getRateLimitIdentifier(c: any): string {\n  // Se usu√°rio autenticado, usar ID do usu√°rio\n  const user = c.get('user');\n  if (user && user.id) {\n    return `user:${user.id}`;\n  }\n  \n  // Sen√£o, usar IP\n  const ip = c.req.header('x-forwarded-for') ||\n              c.req.header('x-real-ip') ||\n              c.req.header('cf-connecting-ip') ||\n              '127.0.0.1'; // IP padr√£o para localhost\n  \n  return `ip:${ip}`;\n}\n\n/**\n * Limpa entradas expiradas do store\n */\nfunction cleanupExpiredEntries(now: number): void {\n  for (const [key, entry] of rateLimitStore.entries()) {\n    if (now > entry.resetTime) {\n      rateLimitStore.delete(key);\n    }\n  }\n}\n\n/**\n * Registra tentativas de rate limit exceeded para auditoria\n */\nasync function logRateLimitExceeded(c: any, identifier: string, count: number): Promise<void> {\n  try {\n    const pool = getDbPool(c);\n    const user = c.get('user');\n    \n    await pool.query(\n      `INSERT INTO rate_limit_logs (identifier, user_id, count, ip_address, user_agent, endpoint)\n       VALUES ($1, $2, $3, $4, $5, $6)`,\n      [\n        identifier,\n        user?.id || null,\n        count,\n        c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || '127.0.0.1',\n        c.req.header('user-agent') || 'unknown',\n        c.req.path || 'unknown'\n      ]\n    );\n  } catch (error) {\n    console.error('Erro ao registrar rate limit exceeded:', error);\n  }\n}\n\n/**\n * Inicializa tabela de logs de rate limiting\n */\nexport async function initializeRateLimitTable(pool?: any): Promise<void> {\n  const dbPool = pool || getDbPool({} as any);\n  \n  try {\n    await dbPool.query(`\n      CREATE TABLE IF NOT EXISTS rate_limit_logs (\n        id SERIAL PRIMARY KEY,\n        identifier VARCHAR(100) NOT NULL,\n        user_id INTEGER REFERENCES users(id),\n        count INTEGER NOT NULL,\n        ip_address TEXT,\n        user_agent TEXT,\n        endpoint VARCHAR(200),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n    \n    // Criar √≠ndices\n    await dbPool.query(`\n      CREATE INDEX IF NOT EXISTS idx_rate_limit_identifier ON rate_limit_logs(identifier);\n      CREATE INDEX IF NOT EXISTS idx_rate_limit_created_at ON rate_limit_logs(created_at);\n    `);\n    \n    console.log('Tabela de rate limit logs inicializada com sucesso');\n  } catch (error) {\n    console.error('Erro ao inicializar tabela de rate limit logs:', error);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/middleware/rateLimit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/admin.migration.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1464,1467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1464,1467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Hono } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\nconst nukeMigrationRoute = new Hono();\n\nnukeMigrationRoute.post('/', async (c) => {\n    const pool = getDbPool(c);\n    try {\n        await pool.query(`\n            CREATE TABLE IF NOT EXISTS terms_acceptance (\n                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n                user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n                terms_version VARCHAR(20) NOT NULL DEFAULT '2.0',\n                privacy_version VARCHAR(20) NOT NULL DEFAULT '1.0',\n                ip_address VARCHAR(45),\n                user_agent TEXT,\n                accepted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n                accepted_age_requirement BOOLEAN NOT NULL DEFAULT true,\n                accepted_risk_disclosure BOOLEAN NOT NULL DEFAULT true,\n                accepted_terms BOOLEAN NOT NULL DEFAULT true,\n                accepted_privacy BOOLEAN NOT NULL DEFAULT true,\n                UNIQUE(user_id, terms_version, privacy_version)\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_terms_acceptance_user_id ON terms_acceptance(user_id);\n            CREATE INDEX IF NOT EXISTS idx_terms_acceptance_date ON terms_acceptance(accepted_at DESC);\n        `);\n        return c.json({ success: true, message: 'Tabela terms_acceptance criada com sucesso!' });\n    } catch (error: any) {\n        return c.json({ success: false, message: error.message }, 500);\n    }\n});\n\nexport { nukeMigrationRoute };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/admin.retro.terms.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[975,978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[975,978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Hono } from 'hono';\nimport { getDbPool } from '../../../infrastructure/database/postgresql/connection/pool';\n\nconst retroTermsRoute = new Hono();\n\nretroTermsRoute.post('/', async (c) => {\n    const pool = getDbPool(c);\n    try {\n        // Insere termos para quem j√° aceitou (tem accepted_terms_at) mas n√£o tem registro na tabela terms_acceptance\n        const result = await pool.query(`\n            INSERT INTO terms_acceptance (user_id, terms_version, privacy_version, ip_address, user_agent, accepted_at)\n            SELECT id, '2.0', '1.0', '127.0.0.1', 'Migration Script', accepted_terms_at\n            FROM users\n            WHERE accepted_terms_at IS NOT NULL\n            AND NOT EXISTS (\n                SELECT 1 FROM terms_acceptance WHERE user_id = users.id AND terms_version = '2.0'\n            )\n        `);\n\n        return c.json({ success: true, message: `Blindagem retroativa aplicada! ${result.rowCount} registros criados.` });\n    } catch (error: any) {\n        return c.json({ success: false, message: error.message }, 500);\n    }\n});\n\nexport { retroTermsRoute };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/bug-reports.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/claims.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/consortium.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/earn.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/education.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/kyc.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/loans.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/logistics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/marketplace.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/monetization.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/notifications.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/pdv.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/products.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/promo-videos.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/quotas.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/seller.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/terms.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/transactions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/tutors.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/users.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PointsService' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":23,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"PointsService"},"fix":{"range":[93,171],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Hono } from 'hono';\nimport { authMiddleware } from '../middleware/auth.middleware';\nimport { PointsService } from '../../../application/services/points.service';\nimport { UsersController } from '../controllers/users.controller';\n\nexport const userRoutes = new Hono();\n\n// Obter perfil do usu√°rio atual\nuserRoutes.get('/profile', authMiddleware, UsersController.getProfile);\n\n// Atualizar perfil do usu√°rio\nuserRoutes.put('/profile', authMiddleware, UsersController.updateProfile);\n\n// Completar perfil (CPF, PIX, Telefone)\nuserRoutes.post('/complete-profile', authMiddleware, UsersController.completeProfile);\n\n// Obter saldo do usu√°rio\nuserRoutes.get('/balance', authMiddleware, UsersController.getBalance);\n\n// Endpoint de Sincroniza√ß√£o Consolidada\nuserRoutes.get('/sync', authMiddleware, UsersController.syncData);\n\n// Obter extrato de transa√ß√µes\nuserRoutes.get('/transactions', authMiddleware, UsersController.getTransactions);\n\n\n\n// Excluir conta\nuserRoutes.delete('/me', authMiddleware, UsersController.deleteAccount);\n\n// Alterar senha\nuserRoutes.post('/change-password', authMiddleware, UsersController.changePassword);\n\n// Atualizar CPF\nuserRoutes.post('/update-cpf', authMiddleware, UsersController.updateCpf);\n\n// Atualizar Telefone\nuserRoutes.post('/update-phone', authMiddleware, UsersController.updatePhone);\n\n// Atualizar Chave PIX\nuserRoutes.post('/update-pix-key', authMiddleware, UsersController.updatePixKey);\n\n// Recompensa Ad\nuserRoutes.post('/reward-ad', authMiddleware, UsersController.rewardAd);\n\n// Elegibilidade de T√≠tulo\nuserRoutes.get('/title-eligibility', authMiddleware, UsersController.getTitleEligibility);\n\n// Download de T√≠tulo\nuserRoutes.post('/title-download', authMiddleware, UsersController.titleDownload);\n\n// Status de Benef√≠cio\nuserRoutes.get('/welcome-benefit', authMiddleware, UsersController.getWelcomeBenefitStatus);\n\n// Ranking de Farm (Top 3)\nuserRoutes.get('/ranking/farm', authMiddleware, UsersController.getFarmRanking);\n\n// Vincular Padrinho (P√≥s-Cadastro)\nuserRoutes.post('/link-referrer', authMiddleware, UsersController.linkReferrer);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/voting.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/webhooks.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/presentation/http/routes/withdrawals.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/scheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/constants/business.constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/errors/base.error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/errors/conflict.error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/errors/not-found.error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/errors/unauthorized.error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/errors/validation.error.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[118,121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[118,121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[165,168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[165,168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseError } from './base.error';\n\nexport class ValidationError extends BaseError {\n  public readonly errors: any[];\n\n  constructor(message: string, errors: any[] = []) {\n    super(message, 400);\n    this.errors = errors;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/schemas/env.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/Loan.type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/Quota.type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/Transaction.type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/User.type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/app-state.type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/types/hono.types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1050,1053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1050,1053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Definir o tipo de usu√°rio para o contexto do Hono\nexport interface UserContext {\n  id: string; // ID como UUID string (compat√≠vel com PostgreSQL)\n  name: string;\n  email: string;\n  balance: number;\n  joinedAt: number; // Timestamp em milissegundos\n  referralCode: string;\n  referredBy?: string; // C√≥digo do referidor\n  isAdmin: boolean;\n  role: 'MEMBER' | 'ATTENDANT' | 'ADMIN';\n  status: 'ACTIVE' | 'BLOCKED';\n  score: number;\n  pixKey?: string;\n  twoFactorEnabled?: boolean;\n  cpf?: string | null;\n  phone?: string | null;\n  securityLockUntil?: number; // Timestamp em milissegundos\n  membership_type?: string;\n  is_verified?: boolean;\n  is_seller?: boolean;\n  video_points?: number;\n  ad_points?: number;\n  pending_ad_points?: number;\n  is_protected?: boolean;\n  protection_expires_at?: number | null;\n  address?: string;\n  total_dividends_earned?: number;\n  last_login_at?: string;\n  hasPassword?: boolean;\n}\n\n// Estender o tipo de vari√°veis do Hono\ndeclare module 'hono' {\n  interface ContextVariableMap {\n    user: UserContext;\n    dbPool: any; // Pool de conex√µes PostgreSQL\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/financial.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/indexes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2861,2864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2861,2864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3368,3371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3368,3371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool } from 'pg';\n\n// Fun√ß√£o para criar √≠ndices no banco de dados\nexport async function createIndexes(pool: Pool): Promise<void> {\n  try {\n    console.log('Criando √≠ndices do banco de dados...');\n\n    // √çndices para tabela users\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_referral_code ON users(referral_code)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_is_admin ON users(is_admin)\n    `);\n\n    // √çndices para tabela transactions\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_status ON transactions(status)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_type ON transactions(type)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_status ON transactions(user_id, status)\n    `);\n\n    // √çndices para tabela quotas\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_quotas_user_id ON quotas(user_id)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_quotas_status ON quotas(status)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_quotas_purchase_date ON quotas(purchase_date)\n    `);\n\n    // √çndices para tabela loans\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_loans_user_id ON loans(user_id)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_loans_status ON loans(status)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_loans_created_at ON loans(created_at)\n    `);\n\n    // √çndices para tabela audit_logs\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)\n    `);\n\n    // √çndices compostos para consultas frequentes\n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_transactions_user_status_type ON transactions(user_id, status, type)\n    `);\n    \n    await pool.query(`\n      CREATE INDEX IF NOT EXISTS idx_quotas_user_status ON quotas(user_id, status)\n    `);\n\n    console.log('√çndices criados com sucesso!');\n  } catch (error) {\n    console.error('Erro ao criar √≠ndices:', error);\n    throw error;\n  }\n}\n\n// Fun√ß√£o para analisar performance das consultas\nexport async function analyzeQueryPerformance(pool: Pool): Promise<any[]> {\n  try {\n    const result = await pool.query(`\n      SELECT \n        schemaname,\n        tablename,\n        indexname,\n        idx_scan,\n        idx_tup_read,\n        idx_tup_fetch\n      FROM pg_stat_user_indexes\n      ORDER BY idx_scan DESC\n    `);\n    \n    return result.rows;\n  } catch (error) {\n    console.error('Erro ao analisar performance das consultas:', error);\n    return [];\n  }\n}\n\n// Fun√ß√£o para verificar √≠ndices ausentes\nexport async function checkMissingIndexes(pool: Pool): Promise<any[]> {\n  try {\n    const result = await pool.query(`\n      SELECT \n        schemaname,\n        tablename,\n        attname,\n        n_distinct,\n        correlation\n      FROM pg_stats\n      WHERE schemaname = 'public'\n        AND tablename IN ('users', 'transactions', 'quotas', 'loans', 'audit_logs')\n      ORDER BY tablename, n_distinct DESC\n    `);\n    \n    return result.rows;\n  } catch (error) {\n    console.error('Erro ao verificar √≠ndices ausentes:', error);\n    return [];\n  }\n}\n\n// Fun√ß√£o para otimizar tabelas\nexport async function optimizeTables(pool: Pool): Promise<void> {\n  try {\n    const tables = ['users', 'transactions', 'quotas', 'loans', 'audit_logs'];\n    \n    for (const table of tables) {\n      await pool.query(`ANALYZE ${table}`);\n      console.log(`Tabela ${table} analisada para otimiza√ß√£o`);\n    }\n    \n    console.log('Otimiza√ß√£o das tabelas conclu√≠da!');\n  } catch (error) {\n    console.error('Erro ao otimizar tabelas:', error);\n    throw error;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/jwt-validation.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/logistics.utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1061,1064],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1061,1064],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Motor de Log√≠stica do Cred30\n * Calcula fretes baseados em CEP e regras de proximidade\n */\n\nexport interface ShippingQuote {\n    fee: number;\n    deliveryEstimateDays: number;\n    method: 'COURIER' | 'STATE' | 'REGIONAL' | 'NATIONAL';\n}\n\nexport function calculateShippingQuote(\n    originCep: string,\n    destCep: string,\n    weightGrams: number = 1000,\n    isFreeShipping: boolean = false\n): ShippingQuote {\n    if (isFreeShipping) {\n        return { fee: 0, deliveryEstimateDays: 7, method: 'NATIONAL' };\n    }\n\n    const origin = originCep.replace(/\\D/g, '');\n    const dest = destCep.replace(/\\D/g, '');\n\n    // Constantes de Pre√ßo (Estilo SEDEX Blindado - Pre√ßos de Teto)\n    const BASE_LOCAL = 28.00;\n    const BASE_ESTADUAL = 38.00;\n    const BASE_NACIONAL_PROXIMO = 55.00; // Sul/Sudeste\n    const BASE_NACIONAL_DISTANTE = 78.00; // Norte/Nordeste/C-O\n    const WEIGHT_STEP = 8.00; // R$ por kg extra\n    const SAFETY_MARGIN = 1.25; // +25% de margem contra preju√≠zos\n\n    let baseFee = BASE_NACIONAL_DISTANTE;\n    let days = 10;\n    let method: any = 'NATIONAL';\n\n    const originRegion = origin.substring(0, 1);\n    const destRegion = dest.substring(0, 1);\n    const originArea = origin.substring(0, 5);\n    const destArea = dest.substring(0, 5);\n\n    // 1. Mesmo Bairro/Cidade (5 d√≠gitos)\n    if (originArea === destArea) {\n        baseFee = BASE_LOCAL;\n        days = 1;\n        method = 'COURIER';\n    }\n    // 2. Mesmo Estado\n    else if (originRegion === destRegion) {\n        baseFee = BASE_ESTADUAL;\n        days = 3;\n        method = 'STATE';\n    }\n    // 3. Regi√µes Pr√≥ximas (Sul 8-9 e Sudeste 0-3)\n    else {\n        const isSouthOrSoutheast = (c: string) => ['0', '1', '2', '3', '8', '9'].includes(c[0]);\n        if (isSouthOrSoutheast(origin) && isSouthOrSoutheast(dest)) {\n            baseFee = BASE_NACIONAL_PROXIMO;\n            days = 5;\n            method = 'REGIONAL';\n        } else {\n            baseFee = BASE_NACIONAL_DISTANTE;\n            days = 8;\n            method = 'NATIONAL';\n        }\n    }\n\n    // Acr√©scimo por Peso (Peso m√≠nimo considerado 1kg)\n    const weightKg = Math.max(1, Math.ceil(weightGrams / 1000));\n    const weightExtra = (weightKg - 1) * WEIGHT_STEP;\n\n    // C√°lculo Final com Margem de Seguran√ßa\n    const finalFee = (baseFee + weightExtra) * SAFETY_MARGIN;\n\n    return {\n        fee: parseFloat(finalFee.toFixed(2)),\n        deliveryEstimateDays: days,\n        method: method\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/transactions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[165,168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[165,168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[364,367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[364,367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[520,523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[520,523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1609,1612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1609,1612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2815,2818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2815,2818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3159,3162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3159,3162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3362,3365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3362,3365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, PoolClient } from 'pg';\n\n// Interface para resultado de opera√ß√µes\nexport interface TransactionResult {\n  success: boolean;\n  error?: string;\n  data?: any;\n}\n\n// Interface para par√¢metros de transa√ß√£o\nexport interface CreateTransactionParams {\n  userId: string;\n  type: string;\n  amount: number;\n  description: string;\n  status: string;\n  metadata?: any;\n}\n\n// Executar opera√ß√µes dentro de uma transa√ß√£o\nexport async function executeInTransaction(\n  pool: Pool,\n  callback: (client: PoolClient) => Promise<any>\n): Promise<TransactionResult> {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    const result = await callback(client);\n\n    await client.query('COMMIT');\n\n    return { success: true, data: result };\n  } catch (error) {\n    await client.query('ROLLBACK');\n\n    console.error('Erro na transa√ß√£o:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro desconhecido'\n    };\n  } finally {\n    client.release();\n  }\n}\n\n// Atualizar saldo do usu√°rio\nexport async function updateUserBalance(\n  client: PoolClient,\n  userId: string,\n  amount: number,\n  operation: 'credit' | 'debit'\n): Promise<void> {\n  const query = operation === 'credit'\n    ? 'UPDATE users SET balance = balance + $1 WHERE id = $2'\n    : 'UPDATE users SET balance = balance - $1 WHERE id = $2';\n\n  await client.query(query, [amount, userId]);\n}\n\n// Criar transa√ß√£o\nexport async function createTransaction(\n  client: PoolClient,\n  userId: string,\n  type: string,\n  amount: number,\n  description: string,\n  status: string,\n  metadata?: any\n): Promise<void> {\n  await client.query(\n    `INSERT INTO transactions (user_id, type, amount, description, status, metadata)\n     VALUES ($1, $2, $3, $4, $5, $6)`,\n    [userId, type, amount, description, status, JSON.stringify(metadata || {})]\n  );\n}\n\n// Atualizar status da transa√ß√£o\nexport async function updateTransactionStatus(\n  client: PoolClient,\n  transactionId: number,\n  currentStatus: string,\n  newStatus: string\n): Promise<TransactionResult> {\n  try {\n    const result = await client.query(\n      `UPDATE transactions \n       SET status = $1, processed_at = CURRENT_TIMESTAMP\n       WHERE id = $2 AND status = $3\n       RETURNING id`,\n      [newStatus, transactionId, currentStatus]\n    );\n\n    if (result.rows.length === 0) {\n      return {\n        success: false,\n        error: 'Transa√ß√£o n√£o encontrada ou j√° foi processada'\n      };\n    }\n\n    return { success: true };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao atualizar transa√ß√£o'\n    };\n  }\n}\n\n// Buscar transa√ß√µes do usu√°rio\nexport async function getUserTransactions(\n  pool: Pool,\n  userId: string,\n  limit: number = 50,\n  offset: number = 0\n): Promise<any[]> {\n  const result = await pool.query(\n    `SELECT * FROM transactions \n     WHERE user_id = $1 \n     ORDER BY created_at DESC \n     LIMIT $2 OFFSET $3`,\n    [userId, limit, offset]\n  );\n\n  return result.rows;\n}\n\n// Buscar transa√ß√µes pendentes (admin)\nexport async function getPendingTransactions(\n  pool: Pool,\n  type?: string\n): Promise<any[]> {\n  let query = `\n    SELECT t.*, u.name as user_name, u.email as user_email\n    FROM transactions t\n    LEFT JOIN users u ON t.user_id = u.id\n    WHERE t.status = 'PENDING'\n  `;\n\n  const params: any[] = [];\n\n  if (type) {\n    query += ' AND t.type = $1';\n    params.push(type);\n  }\n\n  query += ' ORDER BY t.created_at DESC';\n\n  const result = await pool.query(query, params);\n  return result.rows;\n}\n\n// Calcular saldo total do sistema\nexport async function calculateSystemBalance(pool: Pool): Promise<number> {\n  const result = await pool.query(\n    `SELECT COALESCE(SUM(CASE WHEN status = 'ACTIVE' THEN 1 ELSE 0 END) * $1, 0) as total_quotas_value\n     FROM quotas`,\n    [50] // QUOTA_PRICE\n  );\n\n  return parseFloat(result.rows[0].total_quotas_value);\n}\n\n// Verificar limite de saque\nexport function validateWithdrawalAmount(amount: number, balance: number): TransactionResult {\n  const MIN_WITHDRAWAL = 10;\n  const MAX_WITHDRAWAL = 50000;\n\n  if (amount < MIN_WITHDRAWAL) {\n    return {\n      success: false,\n      error: `Valor m√≠nimo de saque √© R$ ${MIN_WITHDRAWAL.toFixed(2)}`\n    };\n  }\n\n  if (amount > MAX_WITHDRAWAL) {\n    return {\n      success: false,\n      error: `Valor m√°ximo de saque √© R$ ${MAX_WITHDRAWAL.toFixed(2)}`\n    };\n  }\n\n  if (amount > balance) {\n    return {\n      success: false,\n      error: 'Saldo insuficiente para saque'\n    };\n  }\n\n  return { success: true };\n}\n\n// Calcular taxa de saque\nexport function calculateWithdrawalFee(amount: number): number {\n  const FEE_PERCENTAGE = 0.02;\n  const FEE_FIXED = 5.00;\n\n  return Math.max(amount * FEE_PERCENTAGE, FEE_FIXED);\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/shared/utils/validation.utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4611,4614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4611,4614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4622,4625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4622,4625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":176,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":176,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\n\n\n// Schema para valida√ß√£o de email\nconst emailSchema = z.string()\n  .email(\"Email inv√°lido\")\n  .min(5, \"Email deve ter pelo menos 5 caracteres\")\n  .max(255, \"Email deve ter no m√°ximo 255 caracteres\");\n\n// Schema para valida√ß√£o de senha\nconst passwordSchema = z.string()\n  .min(8, \"Senha deve ter pelo menos 8 caracteres\")\n  .max(128, \"Senha deve ter no m√°ximo 128 caracteres\")\n  .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/, \"Senha deve conter pelo menos uma letra mai√∫scula, uma min√∫scula e um n√∫mero\");\n\n// Schema para valida√ß√£o de nome\nconst nameSchema = z.string()\n  .min(3, \"Nome deve ter pelo menos 3 caracteres\")\n  .max(100, \"Nome deve ter no m√°ximo 100 caracteres\")\n  .regex(/^[a-zA-Z√Ä-√ø\\s']+$/, \"Nome deve conter apenas letras e espa√ßos\");\n\n// Schema para valida√ß√£o de PIX\nconst pixSchema = z.string()\n  .min(5, \"Chave PIX deve ter pelo menos 5 caracteres\")\n  .max(140, \"Chave PIX deve ter no m√°ximo 140 caracteres\");\n\n// Schema para valida√ß√£o de frase secreta\nconst secretPhraseSchema = z.string()\n  .min(3, \"Frase secreta deve ter pelo menos 3 caracteres\")\n  .max(100, \"Frase secreta deve ter no m√°ximo 100 caracteres\");\n\n// Schemas de requisi√ß√£o\nexport const schemas = {\n  // Autentica√ß√£o\n  login: z.object({\n    email: emailSchema,\n    password: z.string().min(1, \"Senha √© obrigat√≥ria\"),\n    secretPhrase: secretPhraseSchema\n  }),\n\n  register: z.object({\n    name: nameSchema,\n    email: emailSchema,\n    password: passwordSchema,\n    secretPhrase: secretPhraseSchema,\n    pixKey: pixSchema,\n    referralCode: z.string().optional()\n  }),\n\n  resetPassword: z.object({\n    email: emailSchema,\n    secretPhrase: secretPhraseSchema,\n    newPassword: passwordSchema\n  }),\n\n  // Opera√ß√µes de cotas\n  buyQuota: z.object({\n    quantity: z.number()\n      .int(\"Quantidade deve ser um n√∫mero inteiro\")\n      .positive(\"Quantidade deve ser maior que zero\")\n      .min(1, \"Quantidade m√≠nima √© 1 cota\")\n      .max(100, \"Quantidade m√°xima por compra √© 100 cotas\"),\n    useBalance: z.boolean()\n  }),\n\n  sellQuota: z.object({\n    quotaId: z.string()\n      .uuid(\"ID da cota inv√°lido\")\n      .min(1, \"ID da cota √© obrigat√≥rio\")\n  }),\n\n  // Opera√ß√µes de apoio m√∫tuo\n  requestLoan: z.object({\n    amount: z.number()\n      .positive(\"Valor deve ser maior que zero\")\n      .min(50, \"Valor m√≠nimo de apoio √© R$ 50,00\")\n      .max(10000, \"Valor m√°ximo de apoio √© R$ 10.000,00\"),\n    installments: z.number()\n      .int(\"N√∫mero de parcelas deve ser inteiro\")\n      .min(1, \"M√≠nimo 1 parcela\")\n      .max(12, \"M√°ximo 12 parcelas\"),\n    receivePixKey: pixSchema\n  }),\n\n  repayLoan: z.object({\n    loanId: z.string()\n      .uuid(\"ID do apoio inv√°lido\")\n      .min(1, \"ID do apoio √© obrigat√≥rio\"),\n    useBalance: z.boolean()\n  }),\n\n  // Opera√ß√µes de transa√ß√µes\n  withdraw: z.object({\n    amount: z.number()\n      .positive(\"Valor deve ser maior que zero\")\n      .min(10, \"Valor m√≠nimo de saque √© R$ 10,00\")\n      .max(10000, \"Valor m√°ximo de saque √© R$ 10.000,00\"),\n    pixKey: pixSchema\n  }),\n\n  // Opera√ß√µes administrativas\n  updateBalance: z.object({\n    newBalance: z.number()\n      .nonnegative(\"Saldo n√£o pode ser negativo\")\n      .max(999999999.99, \"Valor m√°ximo permitido √© R$ 999.999.999,99\")\n  }),\n\n  addProfit: z.object({\n    amountToAdd: z.number()\n      .nonnegative(\"Valor n√£o pode ser negativo\")\n      .min(0.01, \"Valor m√≠nimo √© R$ 0,01\")\n      .max(999999999.99, \"Valor m√°ximo permitido √© R$ 999.999.999,99\")\n  }),\n\n  processAction: z.object({\n    id: z.string().min(1, \"ID √© obrigat√≥rio\"),\n    type: z.enum(['TRANSACTION', 'LOAN']),\n    action: z.enum(['APPROVE', 'REJECT'])\n  }),\n\n  // Atualiza√ß√£o de perfil\n  updateProfile: z.object({\n    name: nameSchema.optional(),\n    pixKey: pixSchema.optional(),\n    secretPhrase: secretPhraseSchema.optional()\n  }).refine((data) => Object.keys(data).length > 0, {\n    message: \"Pelo menos um campo deve ser fornecido para atualiza√ß√£o\"\n  })\n};\n\n// Fun√ß√£o de valida√ß√£o gen√©rica\nexport function validateRequest<T>(schema: z.ZodSchema<T>, data: unknown): {\n  success: boolean;\n  data?: T;\n  errors?: string[];\n} {\n  try {\n    const validatedData = schema.parse(data);\n    return {\n      success: true,\n      data: validatedData\n    };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors = error.errors.map(err => err.message);\n      return {\n        success: false,\n        errors\n      };\n    }\n    return {\n      success: false,\n      errors: ['Erro de valida√ß√£o desconhecido']\n    };\n  }\n}\n\n// Middleware de valida√ß√£o para Hono\nexport function createValidationMiddleware<T>(schema: z.ZodSchema<T>) {\n  return async (c: any, next: any) => {\n    try {\n      const body = await c.req.json();\n      const validation = validateRequest(schema, body);\n\n      if (!validation.success) {\n        return c.json({\n          success: false,\n          message: 'Dados inv√°lidos',\n          errors: validation.errors\n        }, 400);\n      }\n\n      // Adicionar dados validados ao contexto\n      c.set('validatedData', validation.data);\n      await next();\n    } catch (error) {\n      return c.json({\n        success: false,\n        message: 'Erro ao processar requisi√ß√£o'\n      }, 400);\n    }\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/tests/integration/auth.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1917,1920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1917,1920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeAll } from 'vitest';\nimport { app } from '../../index';\nimport { pool } from '../../infrastructure/database/postgresql/connection/pool';\n\ndescribe('Auth Integration Tests', () => {\n    // Usar email do admin para ignorar regras de indica√ß√£o e focar no fluxo de infra\n    const testUser = {\n        name: 'Super Admin User',\n        email: process.env.ADMIN_EMAIL || 'admin@cred30.site',\n        password: 'Password123!',\n        secretPhrase: 'MINHA FRASE SECRETA',\n        pixKey: 'admin@pix.com',\n        referralCode: 'TESTCODE'\n    };\n\n    beforeAll(async () => {\n        try {\n            console.log('--- [AUTH TEST] Cleanup starting ---');\n            // Limpeza profunda usando TRUNCATE CASCADE\n            await pool.query(`\n                TRUNCATE TABLE \n                    users, \n                    transactions, \n                    quotas, \n                    loans, \n                    loan_installments, \n                    referral_codes, \n                    admin_logs, \n                    audit_logs \n                CASCADE\n            `);\n\n            // Garantir usu√°rio padrinho para validar c√≥digos de indica√ß√£o\n            const referrerRes = await pool.query(`\n                INSERT INTO users (name, email, password_hash, secret_phrase, referral_code, is_admin, balance, score, status)\n                VALUES ('Test Referrer', 'referrer@test.com', 'hash', 'frase', 'REF123', TRUE, 0, 0, 'ACTIVE')\n                RETURNING id\n            `);\n            const creatorId = referrerRes.rows[0].id;\n\n            // Inserir o c√≥digo de teste\n            await pool.query(`\n                INSERT INTO referral_codes (code, is_active, max_uses, current_uses, created_by) \n                VALUES ($1, TRUE, 100, 0, $2)\n            `, ['TESTCODE', creatorId]);\n\n            console.log('--- [AUTH TEST] Cleanup finished ---');\n        } catch (error: any) {\n            console.error('--- [AUTH TEST] beforeAll Error:', error.message);\n        }\n    });\n\n    it('should complete registration and login flow successfully', async () => {\n        // 1. Register\n        const regRes = await app.request('/api/auth/register', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(testUser)\n        });\n        const regData = await regRes.json();\n        if (regRes.status !== 201) console.log('‚ùå Register Error:', regRes.status, regData);\n        expect(regRes.status).toBe(201);\n        expect(regData.success).toBe(true);\n\n        // 2. Login\n        const logRes = await app.request('/api/auth/login', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                email: testUser.email,\n                password: testUser.password,\n                secretPhrase: testUser.secretPhrase\n            })\n        });\n        const logData = await logRes.json();\n        if (logRes.status !== 200) console.log('‚ùå Login Error:', logRes.status, logData);\n\n        expect(logRes.status).toBe(200);\n        expect(logData.success).toBe(true);\n        expect(logData.data).toHaveProperty('token');\n\n        // 3. Fail Login\n        const failRes = await app.request('/api/auth/login', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                email: testUser.email,\n                password: 'WrongPassword',\n                secretPhrase: testUser.secretPhrase\n            })\n        });\n        expect(failRes.status).toBe(401);\n    });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/tests/integration/health.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/tests/integration/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/tests/unit/credit-analysis.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1100,1103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1100,1103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2291,2294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2291,2294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3544,3547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3544,3547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { calculateInterestRate, checkLoanEligibility } from '../../application/services/credit-analysis.service';\n\ndescribe('Credit Analysis Service', () => {\n    describe('calculateInterestRate', () => {\n        it('deve retornar 35% de juros para 50% de garantia', () => {\n            expect(calculateInterestRate(50)).toBe(0.35);\n        });\n\n        it('deve retornar 10% de juros para 100% de garantia', () => {\n            expect(calculateInterestRate(100)).toBe(0.10);\n        });\n\n        it('deve retornar a taxa correta para valores intermedi√°rios', () => {\n            expect(calculateInterestRate(75)).toBe(0.18); // <= 80\n            expect(calculateInterestRate(85)).toBe(0.14); // <= 90\n        });\n    });\n\n    describe('checkLoanEligibility', () => {\n        const mockPool = {\n            query: vi.fn()\n        };\n\n        it('deve retornar ineleg√≠vel se o usu√°rio n√£o for encontrado', async () => {\n            mockPool.query.mockResolvedValueOnce({ rows: [] });\n            const result = await checkLoanEligibility(mockPool as any, 'user-123');\n            expect(result.eligible).toBe(false);\n            expect(result.reason).toBe('Usu√°rio n√£o encontrado');\n        });\n\n        it('deve retornar ineleg√≠vel se houver empr√©stimos em atraso', async () => {\n            mockPool.query.mockResolvedValueOnce({\n                rows: [{\n                    score: 500,\n                    created_at: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 dias atr√°s\n                    quotas_count: 1,\n                    total_quotas_value: 100,\n                    purchases: 5,\n                    sales: 2,\n                    overdue_loans: 1,\n                    marketplace_spent: 500,\n                    campaign_spent: 0,\n                    platform_spent: 0,\n                    pending_quotas: 0\n                }]\n            });\n            // Mock para system_config (mesmo que n√£o use o resultado, o c√≥digo chama)\n            mockPool.query.mockResolvedValueOnce({ rows: [{ profit_pool: 0, system_total_quotas: 100 }] });\n            // Mock para isGuarantor\n            mockPool.query.mockResolvedValueOnce({ rows: [{ count: 0 }] });\n\n            const result = await checkLoanEligibility(mockPool as any, 'user-123');\n            expect(result.eligible).toBe(false);\n            expect(result.reason).toBe('Voc√™ possui empr√©stimos em atraso.');\n        });\n\n        it('deve calcular o limite corretamente baseado no gasto e cotas', async () => {\n            // Mock para userData\n            mockPool.query.mockResolvedValueOnce({\n                rows: [{\n                    score: 600,\n                    created_at: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000),\n                    quotas_count: 2,\n                    total_quotas_value: 200,\n                    purchases: 10,\n                    sales: 5,\n                    overdue_loans: 0,\n                    marketplace_spent: 1000,\n                    campaign_spent: 0,\n                    platform_spent: 0,\n                    pending_quotas: 0\n                }]\n            });\n\n            // Mock para system_config (profit_pool)\n            mockPool.query.mockResolvedValueOnce({\n                rows: [{ profit_pool: 1000, system_total_quotas: 100 }]\n            });\n\n            // Mock para isGuarantor\n            mockPool.query.mockResolvedValueOnce({\n                rows: [{ count: 0 }]\n            });\n\n            const result = await checkLoanEligibility(mockPool as any, 'user-123');\n            expect(result.eligible).toBe(true);\n            // Limite = (80% + 5% bonus) * totalSpent + (50% + 5% bonus) * quotasValue + userProfitShare\n            // totalSpent = 1000 + (2 * 8) = 1016\n            // spentLimit = 1016 * 0.85 = 863.6\n            // quotasLimit = 200 * 0.55 = 110\n            // userProfitShare = 1000 * (2/100) = 20\n            // total = 863.6 + 110 + 20 = 993.6 -> floor = 993\n            expect(result.details.maxLoanAmount).toBe(993);\n        });\n    });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/src/tests/unit/profit-distribution.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[456,459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[456,459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1470,1473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1470,1473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { distributeProfits } from '../../application/services/profit-distribution.service';\n\ndescribe('Profit Distribution Service', () => {\n    const mockPool = {\n        query: vi.fn()\n    };\n\n    it('deve retornar erro se n√£o houver lucro acumulado', async () => {\n        mockPool.query.mockResolvedValueOnce({ rows: [{ profit_pool: 0 }] });\n        const result = await distributeProfits(mockPool as any);\n        expect(result.success).toBe(false);\n        expect(result.message).toBe('N√£o h√° resultados acumulados para distribuir');\n    });\n\n    it('deve calcular corretamente as cotas ponderadas com b√¥nus', async () => {\n        // Mock system_config\n        mockPool.query.mockResolvedValueOnce({ rows: [{ profit_pool: 1000 }] });\n\n        // Mock eligible users\n        mockPool.query.mockResolvedValueOnce({\n            rows: [\n                { user_id: 1, quota_count: 10, two_factor_enabled: true, membership_type: 'PRO', paid_loans: 2, total_spent: 1000, total_revenue_generated: 200 },\n                { user_id: 2, quota_count: 10, two_factor_enabled: false, membership_type: 'FREE', paid_loans: 0, total_spent: 0, total_revenue_generated: 0 }\n            ]\n        });\n\n        // Mocks para os updates e notifica√ß√µes que ocorrem dentro da fun√ß√£o\n        mockPool.query.mockResolvedValue({ rows: [] }); // Update config, transactions, etc.\n\n        const result = await distributeProfits(mockPool as any);\n\n        expect(result.success).toBe(true);\n        expect(result.data.totalProfit).toBe(1000);\n\n        // Verifica√ß√£o manual dos multiplicadores para o User 1:\n        // Base: 1.0\n        // 2FA: +0.1\n        // PRO: +0.2\n        // Paid Loans (2 * 0.05): +0.1\n        // Spent (1000 / 500 * 0.1): +0.2\n        // Revenue (200 / 100 * 0.2): +0.4\n        // Total Multiplier: 1.0 + 0.1 + 0.2 + 0.1 + 0.2 + 0.4 = 2.0\n        // Weighted Quotas: 10 * 2.0 = 20\n\n        // User 2:\n        // Base: 1.0 (sem b√¥nus)\n        // Weighted Quotas: 10 * 1.0 = 10\n\n        // Total Weighted: 30\n        expect(result.data.totalWeightedQuotas).toBe(30);\n    });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/josias/√Årea de trabalho/projetos/app cred30/cred30-master/packages/backend/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
